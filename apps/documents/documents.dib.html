<!DOCTYPE html>

<html lang="en">
<head><meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>documents.dib</title><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.10/require.min.js"></script>
<style type="text/css">
    pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.highlight .hll { background-color: var(--jp-cell-editor-active-background) }
.highlight { background: var(--jp-cell-editor-background); color: var(--jp-mirror-editor-variable-color) }
.highlight .c { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment */
.highlight .err { color: var(--jp-mirror-editor-error-color) } /* Error */
.highlight .k { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword */
.highlight .o { color: var(--jp-mirror-editor-operator-color); font-weight: bold } /* Operator */
.highlight .p { color: var(--jp-mirror-editor-punctuation-color) } /* Punctuation */
.highlight .ch { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment.Multiline */
.highlight .cp { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment.Preproc */
.highlight .cpf { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment.Single */
.highlight .cs { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment.Special */
.highlight .kc { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword.Type */
.highlight .m { color: var(--jp-mirror-editor-number-color) } /* Literal.Number */
.highlight .s { color: var(--jp-mirror-editor-string-color) } /* Literal.String */
.highlight .ow { color: var(--jp-mirror-editor-operator-color); font-weight: bold } /* Operator.Word */
.highlight .pm { color: var(--jp-mirror-editor-punctuation-color) } /* Punctuation.Marker */
.highlight .w { color: var(--jp-mirror-editor-variable-color) } /* Text.Whitespace */
.highlight .mb { color: var(--jp-mirror-editor-number-color) } /* Literal.Number.Bin */
.highlight .mf { color: var(--jp-mirror-editor-number-color) } /* Literal.Number.Float */
.highlight .mh { color: var(--jp-mirror-editor-number-color) } /* Literal.Number.Hex */
.highlight .mi { color: var(--jp-mirror-editor-number-color) } /* Literal.Number.Integer */
.highlight .mo { color: var(--jp-mirror-editor-number-color) } /* Literal.Number.Oct */
.highlight .sa { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Affix */
.highlight .sb { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Backtick */
.highlight .sc { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Char */
.highlight .dl { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Delimiter */
.highlight .sd { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Doc */
.highlight .s2 { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Double */
.highlight .se { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Escape */
.highlight .sh { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Heredoc */
.highlight .si { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Interpol */
.highlight .sx { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Other */
.highlight .sr { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Regex */
.highlight .s1 { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Single */
.highlight .ss { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Symbol */
.highlight .il { color: var(--jp-mirror-editor-number-color) } /* Literal.Number.Integer.Long */
  </style>
<style type="text/css">
/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*
 * Mozilla scrollbar styling
 */

/* use standard opaque scrollbars for most nodes */
[data-jp-theme-scrollbars='true'] {
  scrollbar-color: rgb(var(--jp-scrollbar-thumb-color))
    var(--jp-scrollbar-background-color);
}

/* for code nodes, use a transparent style of scrollbar. These selectors
 * will match lower in the tree, and so will override the above */
[data-jp-theme-scrollbars='true'] .CodeMirror-hscrollbar,
[data-jp-theme-scrollbars='true'] .CodeMirror-vscrollbar {
  scrollbar-color: rgba(var(--jp-scrollbar-thumb-color), 0.5) transparent;
}

/* tiny scrollbar */

.jp-scrollbar-tiny {
  scrollbar-color: rgba(var(--jp-scrollbar-thumb-color), 0.5) transparent;
  scrollbar-width: thin;
}

/* tiny scrollbar */

.jp-scrollbar-tiny::-webkit-scrollbar,
.jp-scrollbar-tiny::-webkit-scrollbar-corner {
  background-color: transparent;
  height: 4px;
  width: 4px;
}

.jp-scrollbar-tiny::-webkit-scrollbar-thumb {
  background: rgba(var(--jp-scrollbar-thumb-color), 0.5);
}

.jp-scrollbar-tiny::-webkit-scrollbar-track:horizontal {
  border-left: 0 solid transparent;
  border-right: 0 solid transparent;
}

.jp-scrollbar-tiny::-webkit-scrollbar-track:vertical {
  border-top: 0 solid transparent;
  border-bottom: 0 solid transparent;
}

/*
 * Lumino
 */

.lm-ScrollBar[data-orientation='horizontal'] {
  min-height: 16px;
  max-height: 16px;
  min-width: 45px;
  border-top: 1px solid #a0a0a0;
}

.lm-ScrollBar[data-orientation='vertical'] {
  min-width: 16px;
  max-width: 16px;
  min-height: 45px;
  border-left: 1px solid #a0a0a0;
}

.lm-ScrollBar-button {
  background-color: #f0f0f0;
  background-position: center center;
  min-height: 15px;
  max-height: 15px;
  min-width: 15px;
  max-width: 15px;
}

.lm-ScrollBar-button:hover {
  background-color: #dadada;
}

.lm-ScrollBar-button.lm-mod-active {
  background-color: #cdcdcd;
}

.lm-ScrollBar-track {
  background: #f0f0f0;
}

.lm-ScrollBar-thumb {
  background: #cdcdcd;
}

.lm-ScrollBar-thumb:hover {
  background: #bababa;
}

.lm-ScrollBar-thumb.lm-mod-active {
  background: #a0a0a0;
}

.lm-ScrollBar[data-orientation='horizontal'] .lm-ScrollBar-thumb {
  height: 100%;
  min-width: 15px;
  border-left: 1px solid #a0a0a0;
  border-right: 1px solid #a0a0a0;
}

.lm-ScrollBar[data-orientation='vertical'] .lm-ScrollBar-thumb {
  width: 100%;
  min-height: 15px;
  border-top: 1px solid #a0a0a0;
  border-bottom: 1px solid #a0a0a0;
}

.lm-ScrollBar[data-orientation='horizontal']
  .lm-ScrollBar-button[data-action='decrement'] {
  background-image: var(--jp-icon-caret-left);
  background-size: 17px;
}

.lm-ScrollBar[data-orientation='horizontal']
  .lm-ScrollBar-button[data-action='increment'] {
  background-image: var(--jp-icon-caret-right);
  background-size: 17px;
}

.lm-ScrollBar[data-orientation='vertical']
  .lm-ScrollBar-button[data-action='decrement'] {
  background-image: var(--jp-icon-caret-up);
  background-size: 17px;
}

.lm-ScrollBar[data-orientation='vertical']
  .lm-ScrollBar-button[data-action='increment'] {
  background-image: var(--jp-icon-caret-down);
  background-size: 17px;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-Widget {
  box-sizing: border-box;
  position: relative;
  overflow: hidden;
}

.lm-Widget.lm-mod-hidden {
  display: none !important;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

.lm-AccordionPanel[data-orientation='horizontal'] > .lm-AccordionPanel-title {
  /* Title is rotated for horizontal accordion panel using CSS */
  display: block;
  transform-origin: top left;
  transform: rotate(-90deg) translate(-100%);
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-CommandPalette {
  display: flex;
  flex-direction: column;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.lm-CommandPalette-search {
  flex: 0 0 auto;
}

.lm-CommandPalette-content {
  flex: 1 1 auto;
  margin: 0;
  padding: 0;
  min-height: 0;
  overflow: auto;
  list-style-type: none;
}

.lm-CommandPalette-header {
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.lm-CommandPalette-item {
  display: flex;
  flex-direction: row;
}

.lm-CommandPalette-itemIcon {
  flex: 0 0 auto;
}

.lm-CommandPalette-itemContent {
  flex: 1 1 auto;
  overflow: hidden;
}

.lm-CommandPalette-itemShortcut {
  flex: 0 0 auto;
}

.lm-CommandPalette-itemLabel {
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.lm-close-icon {
  border: 1px solid transparent;
  background-color: transparent;
  position: absolute;
  z-index: 1;
  right: 3%;
  top: 0;
  bottom: 0;
  margin: auto;
  padding: 7px 0;
  display: none;
  vertical-align: middle;
  outline: 0;
  cursor: pointer;
}
.lm-close-icon:after {
  content: 'X';
  display: block;
  width: 15px;
  height: 15px;
  text-align: center;
  color: #000;
  font-weight: normal;
  font-size: 12px;
  cursor: pointer;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-DockPanel {
  z-index: 0;
}

.lm-DockPanel-widget {
  z-index: 0;
}

.lm-DockPanel-tabBar {
  z-index: 1;
}

.lm-DockPanel-handle {
  z-index: 2;
}

.lm-DockPanel-handle.lm-mod-hidden {
  display: none !important;
}

.lm-DockPanel-handle:after {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  content: '';
}

.lm-DockPanel-handle[data-orientation='horizontal'] {
  cursor: ew-resize;
}

.lm-DockPanel-handle[data-orientation='vertical'] {
  cursor: ns-resize;
}

.lm-DockPanel-handle[data-orientation='horizontal']:after {
  left: 50%;
  min-width: 8px;
  transform: translateX(-50%);
}

.lm-DockPanel-handle[data-orientation='vertical']:after {
  top: 50%;
  min-height: 8px;
  transform: translateY(-50%);
}

.lm-DockPanel-overlay {
  z-index: 3;
  box-sizing: border-box;
  pointer-events: none;
}

.lm-DockPanel-overlay.lm-mod-hidden {
  display: none !important;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-Menu {
  z-index: 10000;
  position: absolute;
  white-space: nowrap;
  overflow-x: hidden;
  overflow-y: auto;
  outline: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.lm-Menu-content {
  margin: 0;
  padding: 0;
  display: table;
  list-style-type: none;
}

.lm-Menu-item {
  display: table-row;
}

.lm-Menu-item.lm-mod-hidden,
.lm-Menu-item.lm-mod-collapsed {
  display: none !important;
}

.lm-Menu-itemIcon,
.lm-Menu-itemSubmenuIcon {
  display: table-cell;
  text-align: center;
}

.lm-Menu-itemLabel {
  display: table-cell;
  text-align: left;
}

.lm-Menu-itemShortcut {
  display: table-cell;
  text-align: right;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-MenuBar {
  outline: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.lm-MenuBar-content {
  margin: 0;
  padding: 0;
  display: flex;
  flex-direction: row;
  list-style-type: none;
}

.lm-MenuBar-item {
  box-sizing: border-box;
}

.lm-MenuBar-itemIcon,
.lm-MenuBar-itemLabel {
  display: inline-block;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-ScrollBar {
  display: flex;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.lm-ScrollBar[data-orientation='horizontal'] {
  flex-direction: row;
}

.lm-ScrollBar[data-orientation='vertical'] {
  flex-direction: column;
}

.lm-ScrollBar-button {
  box-sizing: border-box;
  flex: 0 0 auto;
}

.lm-ScrollBar-track {
  box-sizing: border-box;
  position: relative;
  overflow: hidden;
  flex: 1 1 auto;
}

.lm-ScrollBar-thumb {
  box-sizing: border-box;
  position: absolute;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-SplitPanel-child {
  z-index: 0;
}

.lm-SplitPanel-handle {
  z-index: 1;
}

.lm-SplitPanel-handle.lm-mod-hidden {
  display: none !important;
}

.lm-SplitPanel-handle:after {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  content: '';
}

.lm-SplitPanel[data-orientation='horizontal'] > .lm-SplitPanel-handle {
  cursor: ew-resize;
}

.lm-SplitPanel[data-orientation='vertical'] > .lm-SplitPanel-handle {
  cursor: ns-resize;
}

.lm-SplitPanel[data-orientation='horizontal'] > .lm-SplitPanel-handle:after {
  left: 50%;
  min-width: 8px;
  transform: translateX(-50%);
}

.lm-SplitPanel[data-orientation='vertical'] > .lm-SplitPanel-handle:after {
  top: 50%;
  min-height: 8px;
  transform: translateY(-50%);
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-TabBar {
  display: flex;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.lm-TabBar[data-orientation='horizontal'] {
  flex-direction: row;
  align-items: flex-end;
}

.lm-TabBar[data-orientation='vertical'] {
  flex-direction: column;
  align-items: flex-end;
}

.lm-TabBar-content {
  margin: 0;
  padding: 0;
  display: flex;
  flex: 1 1 auto;
  list-style-type: none;
}

.lm-TabBar[data-orientation='horizontal'] > .lm-TabBar-content {
  flex-direction: row;
}

.lm-TabBar[data-orientation='vertical'] > .lm-TabBar-content {
  flex-direction: column;
}

.lm-TabBar-tab {
  display: flex;
  flex-direction: row;
  box-sizing: border-box;
  overflow: hidden;
  touch-action: none; /* Disable native Drag/Drop */
}

.lm-TabBar-tabIcon,
.lm-TabBar-tabCloseIcon {
  flex: 0 0 auto;
}

.lm-TabBar-tabLabel {
  flex: 1 1 auto;
  overflow: hidden;
  white-space: nowrap;
}

.lm-TabBar-tabInput {
  user-select: all;
  width: 100%;
  box-sizing: border-box;
}

.lm-TabBar-tab.lm-mod-hidden {
  display: none !important;
}

.lm-TabBar-addButton.lm-mod-hidden {
  display: none !important;
}

.lm-TabBar.lm-mod-dragging .lm-TabBar-tab {
  position: relative;
}

.lm-TabBar.lm-mod-dragging[data-orientation='horizontal'] .lm-TabBar-tab {
  left: 0;
  transition: left 150ms ease;
}

.lm-TabBar.lm-mod-dragging[data-orientation='vertical'] .lm-TabBar-tab {
  top: 0;
  transition: top 150ms ease;
}

.lm-TabBar.lm-mod-dragging .lm-TabBar-tab.lm-mod-dragging {
  transition: none;
}

.lm-TabBar-tabLabel .lm-TabBar-tabInput {
  user-select: all;
  width: 100%;
  box-sizing: border-box;
  background: inherit;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-TabPanel-tabBar {
  z-index: 1;
}

.lm-TabPanel-stackedPanel {
  z-index: 0;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-Collapse {
  display: flex;
  flex-direction: column;
  align-items: stretch;
}

.jp-Collapse-header {
  padding: 1px 12px;
  background-color: var(--jp-layout-color1);
  border-bottom: solid var(--jp-border-width) var(--jp-border-color2);
  color: var(--jp-ui-font-color1);
  cursor: pointer;
  display: flex;
  align-items: center;
  font-size: var(--jp-ui-font-size0);
  font-weight: 600;
  text-transform: uppercase;
  user-select: none;
}

.jp-Collapser-icon {
  height: 16px;
}

.jp-Collapse-header-collapsed .jp-Collapser-icon {
  transform: rotate(-90deg);
  margin: auto 0;
}

.jp-Collapser-title {
  line-height: 25px;
}

.jp-Collapse-contents {
  padding: 0 12px;
  background-color: var(--jp-layout-color1);
  color: var(--jp-ui-font-color1);
  overflow: auto;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/* This file was auto-generated by ensureUiComponents() in @jupyterlab/buildutils */

/**
 * (DEPRECATED) Support for consuming icons as CSS background images
 */

/* Icons urls */

:root {
  --jp-icon-add-above: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHZpZXdCb3g9IjAgMCAxNCAxNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzEzN18xOTQ5MikiPgo8cGF0aCBjbGFzcz0ianAtaWNvbjMiIGQ9Ik00Ljc1IDQuOTMwNjZINi42MjVWNi44MDU2NkM2LjYyNSA3LjAxMTkxIDYuNzkzNzUgNy4xODA2NiA3IDcuMTgwNjZDNy4yMDYyNSA3LjE4MDY2IDcuMzc1IDcuMDExOTEgNy4zNzUgNi44MDU2NlY0LjkzMDY2SDkuMjVDOS40NTYyNSA0LjkzMDY2IDkuNjI1IDQuNzYxOTEgOS42MjUgNC41NTU2NkM5LjYyNSA0LjM0OTQxIDkuNDU2MjUgNC4xODA2NiA5LjI1IDQuMTgwNjZINy4zNzVWMi4zMDU2NkM3LjM3NSAyLjA5OTQxIDcuMjA2MjUgMS45MzA2NiA3IDEuOTMwNjZDNi43OTM3NSAxLjkzMDY2IDYuNjI1IDIuMDk5NDEgNi42MjUgMi4zMDU2NlY0LjE4MDY2SDQuNzVDNC41NDM3NSA0LjE4MDY2IDQuMzc1IDQuMzQ5NDEgNC4zNzUgNC41NTU2NkM0LjM3NSA0Ljc2MTkxIDQuNTQzNzUgNC45MzA2NiA0Ljc1IDQuOTMwNjZaIiBmaWxsPSIjNjE2MTYxIiBzdHJva2U9IiM2MTYxNjEiIHN0cm9rZS13aWR0aD0iMC43Ii8+CjwvZz4KPHBhdGggY2xhc3M9ImpwLWljb24zIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTExLjUgOS41VjExLjVMMi41IDExLjVWOS41TDExLjUgOS41Wk0xMiA4QzEyLjU1MjMgOCAxMyA4LjQ0NzcyIDEzIDlWMTJDMTMgMTIuNTUyMyAxMi41NTIzIDEzIDEyIDEzTDIgMTNDMS40NDc3MiAxMyAxIDEyLjU1MjMgMSAxMlY5QzEgOC40NDc3MiAxLjQ0NzcxIDggMiA4TDEyIDhaIiBmaWxsPSIjNjE2MTYxIi8+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzEzN18xOTQ5MiI+CjxyZWN0IGNsYXNzPSJqcC1pY29uMyIgd2lkdGg9IjYiIGhlaWdodD0iNiIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0ibWF0cml4KC0xIDAgMCAxIDEwIDEuNTU1NjYpIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg==);
  --jp-icon-add-below: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHZpZXdCb3g9IjAgMCAxNCAxNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzEzN18xOTQ5OCkiPgo8cGF0aCBjbGFzcz0ianAtaWNvbjMiIGQ9Ik05LjI1IDEwLjA2OTNMNy4zNzUgMTAuMDY5M0w3LjM3NSA4LjE5NDM0QzcuMzc1IDcuOTg4MDkgNy4yMDYyNSA3LjgxOTM0IDcgNy44MTkzNEM2Ljc5Mzc1IDcuODE5MzQgNi42MjUgNy45ODgwOSA2LjYyNSA4LjE5NDM0TDYuNjI1IDEwLjA2OTNMNC43NSAxMC4wNjkzQzQuNTQzNzUgMTAuMDY5MyA0LjM3NSAxMC4yMzgxIDQuMzc1IDEwLjQ0NDNDNC4zNzUgMTAuNjUwNiA0LjU0Mzc1IDEwLjgxOTMgNC43NSAxMC44MTkzTDYuNjI1IDEwLjgxOTNMNi42MjUgMTIuNjk0M0M2LjYyNSAxMi45MDA2IDYuNzkzNzUgMTMuMDY5MyA3IDEzLjA2OTNDNy4yMDYyNSAxMy4wNjkzIDcuMzc1IDEyLjkwMDYgNy4zNzUgMTIuNjk0M0w3LjM3NSAxMC44MTkzTDkuMjUgMTAuODE5M0M5LjQ1NjI1IDEwLjgxOTMgOS42MjUgMTAuNjUwNiA5LjYyNSAxMC40NDQzQzkuNjI1IDEwLjIzODEgOS40NTYyNSAxMC4wNjkzIDkuMjUgMTAuMDY5M1oiIGZpbGw9IiM2MTYxNjEiIHN0cm9rZT0iIzYxNjE2MSIgc3Ryb2tlLXdpZHRoPSIwLjciLz4KPC9nPgo8cGF0aCBjbGFzcz0ianAtaWNvbjMiIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMi41IDUuNUwyLjUgMy41TDExLjUgMy41TDExLjUgNS41TDIuNSA1LjVaTTIgN0MxLjQ0NzcyIDcgMSA2LjU1MjI4IDEgNkwxIDNDMSAyLjQ0NzcyIDEuNDQ3NzIgMiAyIDJMMTIgMkMxMi41NTIzIDIgMTMgMi40NDc3MiAxMyAzTDEzIDZDMTMgNi41NTIyOSAxMi41NTIzIDcgMTIgN0wyIDdaIiBmaWxsPSIjNjE2MTYxIi8+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzEzN18xOTQ5OCI+CjxyZWN0IGNsYXNzPSJqcC1pY29uMyIgd2lkdGg9IjYiIGhlaWdodD0iNiIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0ibWF0cml4KDEgMS43NDg0NmUtMDcgMS43NDg0NmUtMDcgLTEgNCAxMy40NDQzKSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo=);
  --jp-icon-add: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTE5IDEzaC02djZoLTJ2LTZINXYtMmg2VjVoMnY2aDZ2MnoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-bell: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE2IDE2IiB2ZXJzaW9uPSIxLjEiPgogICA8cGF0aCBjbGFzcz0ianAtaWNvbjIganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjMzMzMzMzIgogICAgICBkPSJtOCAwLjI5Yy0xLjQgMC0yLjcgMC43My0zLjYgMS44LTEuMiAxLjUtMS40IDMuNC0xLjUgNS4yLTAuMTggMi4yLTAuNDQgNC0yLjMgNS4zbDAuMjggMS4zaDVjMC4wMjYgMC42NiAwLjMyIDEuMSAwLjcxIDEuNSAwLjg0IDAuNjEgMiAwLjYxIDIuOCAwIDAuNTItMC40IDAuNi0xIDAuNzEtMS41aDVsMC4yOC0xLjNjLTEuOS0wLjk3LTIuMi0zLjMtMi4zLTUuMy0wLjEzLTEuOC0wLjI2LTMuNy0xLjUtNS4yLTAuODUtMS0yLjItMS44LTMuNi0xLjh6bTAgMS40YzAuODggMCAxLjkgMC41NSAyLjUgMS4zIDAuODggMS4xIDEuMSAyLjcgMS4yIDQuNCAwLjEzIDEuNyAwLjIzIDMuNiAxLjMgNS4yaC0xMGMxLjEtMS42IDEuMi0zLjQgMS4zLTUuMiAwLjEzLTEuNyAwLjMtMy4zIDEuMi00LjQgMC41OS0wLjcyIDEuNi0xLjMgMi41LTEuM3ptLTAuNzQgMTJoMS41Yy0wLjAwMTUgMC4yOCAwLjAxNSAwLjc5LTAuNzQgMC43OS0wLjczIDAuMDAxNi0wLjcyLTAuNTMtMC43NC0wLjc5eiIgLz4KPC9zdmc+Cg==);
  --jp-icon-bug-dot: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyBqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiM2MTYxNjEiPgogICAgICAgIDxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTcuMTkgOEgyMFYxMEgxNy45MUMxNy45NiAxMC4zMyAxOCAxMC42NiAxOCAxMVYxMkgyMFYxNEgxOC41SDE4VjE0LjAyNzVDMTUuNzUgMTQuMjc2MiAxNCAxNi4xODM3IDE0IDE4LjVDMTQgMTkuMjA4IDE0LjE2MzUgMTkuODc3OSAxNC40NTQ5IDIwLjQ3MzlDMTMuNzA2MyAyMC44MTE3IDEyLjg3NTcgMjEgMTIgMjFDOS43OCAyMSA3Ljg1IDE5Ljc5IDYuODEgMThINFYxNkg2LjA5QzYuMDQgMTUuNjcgNiAxNS4zNCA2IDE1VjE0SDRWMTJINlYxMUM2IDEwLjY2IDYuMDQgMTAuMzMgNi4wOSAxMEg0VjhINi44MUM3LjI2IDcuMjIgNy44OCA2LjU1IDguNjIgNi4wNEw3IDQuNDFMOC40MSAzTDEwLjU5IDUuMTdDMTEuMDQgNS4wNiAxMS41MSA1IDEyIDVDMTIuNDkgNSAxMi45NiA1LjA2IDEzLjQyIDUuMTdMMTUuNTkgM0wxNyA0LjQxTDE1LjM3IDYuMDRDMTYuMTIgNi41NSAxNi43NCA3LjIyIDE3LjE5IDhaTTEwIDE2SDE0VjE0SDEwVjE2Wk0xMCAxMkgxNFYxMEgxMFYxMloiIGZpbGw9IiM2MTYxNjEiLz4KICAgICAgICA8cGF0aCBkPSJNMjIgMTguNUMyMiAyMC40MzMgMjAuNDMzIDIyIDE4LjUgMjJDMTYuNTY3IDIyIDE1IDIwLjQzMyAxNSAxOC41QzE1IDE2LjU2NyAxNi41NjcgMTUgMTguNSAxNUMyMC40MzMgMTUgMjIgMTYuNTY3IDIyIDE4LjVaIiBmaWxsPSIjNjE2MTYxIi8+CiAgICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-bug: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIj4KICAgIDxwYXRoIGQ9Ik0yMCA4aC0yLjgxYy0uNDUtLjc4LTEuMDctMS40NS0xLjgyLTEuOTZMMTcgNC40MSAxNS41OSAzbC0yLjE3IDIuMTdDMTIuOTYgNS4wNiAxMi40OSA1IDEyIDVjLS40OSAwLS45Ni4wNi0xLjQxLjE3TDguNDEgMyA3IDQuNDFsMS42MiAxLjYzQzcuODggNi41NSA3LjI2IDcuMjIgNi44MSA4SDR2MmgyLjA5Yy0uMDUuMzMtLjA5LjY2LS4wOSAxdjFINHYyaDJ2MWMwIC4zNC4wNC42Ny4wOSAxSDR2MmgyLjgxYzEuMDQgMS43OSAyLjk3IDMgNS4xOSAzczQuMTUtMS4yMSA1LjE5LTNIMjB2LTJoLTIuMDljLjA1LS4zMy4wOS0uNjYuMDktMXYtMWgydi0yaC0ydi0xYzAtLjM0LS4wNC0uNjctLjA5LTFIMjBWOHptLTYgOGgtNHYtMmg0djJ6bTAtNGgtNHYtMmg0djJ6Ii8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-build: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIHZpZXdCb3g9IjAgMCAyNCAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTE0LjkgMTcuNDVDMTYuMjUgMTcuNDUgMTcuMzUgMTYuMzUgMTcuMzUgMTVDMTcuMzUgMTMuNjUgMTYuMjUgMTIuNTUgMTQuOSAxMi41NUMxMy41NCAxMi41NSAxMi40NSAxMy42NSAxMi40NSAxNUMxMi40NSAxNi4zNSAxMy41NCAxNy40NSAxNC45IDE3LjQ1Wk0yMC4xIDE1LjY4TDIxLjU4IDE2Ljg0QzIxLjcxIDE2Ljk1IDIxLjc1IDE3LjEzIDIxLjY2IDE3LjI5TDIwLjI2IDE5LjcxQzIwLjE3IDE5Ljg2IDIwIDE5LjkyIDE5LjgzIDE5Ljg2TDE4LjA5IDE5LjE2QzE3LjczIDE5LjQ0IDE3LjMzIDE5LjY3IDE2LjkxIDE5Ljg1TDE2LjY0IDIxLjdDMTYuNjIgMjEuODcgMTYuNDcgMjIgMTYuMyAyMkgxMy41QzEzLjMyIDIyIDEzLjE4IDIxLjg3IDEzLjE1IDIxLjdMMTIuODkgMTkuODVDMTIuNDYgMTkuNjcgMTIuMDcgMTkuNDQgMTEuNzEgMTkuMTZMOS45NjAwMiAxOS44NkM5LjgxMDAyIDE5LjkyIDkuNjIwMDIgMTkuODYgOS41NDAwMiAxOS43MUw4LjE0MDAyIDE3LjI5QzguMDUwMDIgMTcuMTMgOC4wOTAwMiAxNi45NSA4LjIyMDAyIDE2Ljg0TDkuNzAwMDIgMTUuNjhMOS42NTAwMSAxNUw5LjcwMDAyIDE0LjMxTDguMjIwMDIgMTMuMTZDOC4wOTAwMiAxMy4wNSA4LjA1MDAyIDEyLjg2IDguMTQwMDIgMTIuNzFMOS41NDAwMiAxMC4yOUM5LjYyMDAyIDEwLjEzIDkuODEwMDIgMTAuMDcgOS45NjAwMiAxMC4xM0wxMS43MSAxMC44NEMxMi4wNyAxMC41NiAxMi40NiAxMC4zMiAxMi44OSAxMC4xNUwxMy4xNSA4LjI4OTk4QzEzLjE4IDguMTI5OTggMTMuMzIgNy45OTk5OCAxMy41IDcuOTk5OThIMTYuM0MxNi40NyA3Ljk5OTk4IDE2LjYyIDguMTI5OTggMTYuNjQgOC4yODk5OEwxNi45MSAxMC4xNUMxNy4zMyAxMC4zMiAxNy43MyAxMC41NiAxOC4wOSAxMC44NEwxOS44MyAxMC4xM0MyMCAxMC4wNyAyMC4xNyAxMC4xMyAyMC4yNiAxMC4yOUwyMS42NiAxMi43MUMyMS43NSAxMi44NiAyMS43MSAxMy4wNSAyMS41OCAxMy4xNkwyMC4xIDE0LjMxTDIwLjE1IDE1TDIwLjEgMTUuNjhaIi8+CiAgICA8cGF0aCBkPSJNNy4zMjk2NiA3LjQ0NDU0QzguMDgzMSA3LjAwOTU0IDguMzM5MzIgNi4wNTMzMiA3LjkwNDMyIDUuMjk5ODhDNy40NjkzMiA0LjU0NjQzIDYuNTA4MSA0LjI4MTU2IDUuNzU0NjYgNC43MTY1NkM1LjM5MTc2IDQuOTI2MDggNS4xMjY5NSA1LjI3MTE4IDUuMDE4NDkgNS42NzU5NEM0LjkxMDA0IDYuMDgwNzEgNC45NjY4MiA2LjUxMTk4IDUuMTc2MzQgNi44NzQ4OEM1LjYxMTM0IDcuNjI4MzIgNi41NzYyMiA3Ljg3OTU0IDcuMzI5NjYgNy40NDQ1NFpNOS42NTcxOCA0Ljc5NTkzTDEwLjg2NzIgNC45NTE3OUMxMC45NjI4IDQuOTc3NDEgMTEuMDQwMiA1LjA3MTMzIDExLjAzODIgNS4xODc5M0wxMS4wMzg4IDYuOTg4OTNDMTEuMDQ1NSA3LjEwMDU0IDEwLjk2MTYgNy4xOTUxOCAxMC44NTUgNy4yMTA1NEw5LjY2MDAxIDcuMzgwODNMOS4yMzkxNSA4LjEzMTg4TDkuNjY5NjEgOS4yNTc0NUM5LjcwNzI5IDkuMzYyNzEgOS42NjkzNCA5LjQ3Njk5IDkuNTc0MDggOS41MzE5OUw4LjAxNTIzIDEwLjQzMkM3LjkxMTMxIDEwLjQ5MiA3Ljc5MzM3IDEwLjQ2NzcgNy43MjEwNSAxMC4zODI0TDYuOTg3NDggOS40MzE4OEw2LjEwOTMxIDkuNDMwODNMNS4zNDcwNCAxMC4zOTA1QzUuMjg5MDkgMTAuNDcwMiA1LjE3MzgzIDEwLjQ5MDUgNS4wNzE4NyAxMC40MzM5TDMuNTEyNDUgOS41MzI5M0MzLjQxMDQ5IDkuNDc2MzMgMy4zNzY0NyA5LjM1NzQxIDMuNDEwNzUgOS4yNTY3OUwzLjg2MzQ3IDguMTQwOTNMMy42MTc0OSA3Ljc3NDg4TDMuNDIzNDcgNy4zNzg4M0wyLjIzMDc1IDcuMjEyOTdDMi4xMjY0NyA3LjE5MjM1IDIuMDQwNDkgNy4xMDM0MiAyLjA0MjQ1IDYuOTg2ODJMMi4wNDE4NyA1LjE4NTgyQzIuMDQzODMgNS4wNjkyMiAyLjExOTA5IDQuOTc5NTggMi4yMTcwNCA0Ljk2OTIyTDMuNDIwNjUgNC43OTM5M0wzLjg2NzQ5IDQuMDI3ODhMMy40MTEwNSAyLjkxNzMxQzMuMzczMzcgMi44MTIwNCAzLjQxMTMxIDIuNjk3NzYgMy41MTUyMyAyLjYzNzc2TDUuMDc0MDggMS43Mzc3NkM1LjE2OTM0IDEuNjgyNzYgNS4yODcyOSAxLjcwNzA0IDUuMzU5NjEgMS43OTIzMUw2LjExOTE1IDIuNzI3ODhMNi45ODAwMSAyLjczODkzTDcuNzI0OTYgMS43ODkyMkM3Ljc5MTU2IDEuNzA0NTggNy45MTU0OCAxLjY3OTIyIDguMDA4NzkgMS43NDA4Mkw5LjU2ODIxIDIuNjQxODJDOS42NzAxNyAyLjY5ODQyIDkuNzEyODUgMi44MTIzNCA5LjY4NzIzIDIuOTA3OTdMOS4yMTcxOCA0LjAzMzgzTDkuNDYzMTYgNC4zOTk4OEw5LjY1NzE4IDQuNzk1OTNaIi8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-caret-down-empty-thin: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIwIDIwIj4KCTxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iPgoJCTxwb2x5Z29uIGNsYXNzPSJzdDEiIHBvaW50cz0iOS45LDEzLjYgMy42LDcuNCA0LjQsNi42IDkuOSwxMi4yIDE1LjQsNi43IDE2LjEsNy40ICIvPgoJPC9nPgo8L3N2Zz4K);
  --jp-icon-caret-down-empty: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiIHNoYXBlLXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIj4KICAgIDxwYXRoIGQ9Ik01LjIsNS45TDksOS43bDMuOC0zLjhsMS4yLDEuMmwtNC45LDVsLTQuOS01TDUuMiw1Ljl6Ii8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-caret-down: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiIHNoYXBlLXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIj4KICAgIDxwYXRoIGQ9Ik01LjIsNy41TDksMTEuMmwzLjgtMy44SDUuMnoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-caret-left: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE4IDE4Ij4KCTxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iPgoJCTxwYXRoIGQ9Ik0xMC44LDEyLjhMNy4xLDlsMy44LTMuOGwwLDcuNkgxMC44eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-caret-right: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiIHNoYXBlLXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIj4KICAgIDxwYXRoIGQ9Ik03LjIsNS4yTDEwLjksOWwtMy44LDMuOFY1LjJINy4yeiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-caret-up-empty-thin: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIwIDIwIj4KCTxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iPgoJCTxwb2x5Z29uIGNsYXNzPSJzdDEiIHBvaW50cz0iMTUuNCwxMy4zIDkuOSw3LjcgNC40LDEzLjIgMy42LDEyLjUgOS45LDYuMyAxNi4xLDEyLjYgIi8+Cgk8L2c+Cjwvc3ZnPgo=);
  --jp-icon-caret-up: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE4IDE4Ij4KCTxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iPgoJCTxwYXRoIGQ9Ik01LjIsMTAuNUw5LDYuOGwzLjgsMy44SDUuMnoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-case-sensitive: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIwIDIwIj4KICA8ZyBjbGFzcz0ianAtaWNvbjIiIGZpbGw9IiM0MTQxNDEiPgogICAgPHJlY3QgeD0iMiIgeT0iMiIgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2Ii8+CiAgPC9nPgogIDxnIGNsYXNzPSJqcC1pY29uLWFjY2VudDIiIGZpbGw9IiNGRkYiPgogICAgPHBhdGggZD0iTTcuNiw4aDAuOWwzLjUsOGgtMS4xTDEwLDE0SDZsLTAuOSwySDRMNy42LDh6IE04LDkuMUw2LjQsMTNoMy4yTDgsOS4xeiIvPgogICAgPHBhdGggZD0iTTE2LjYsOS44Yy0wLjIsMC4xLTAuNCwwLjEtMC43LDAuMWMtMC4yLDAtMC40LTAuMS0wLjYtMC4yYy0wLjEtMC4xLTAuMi0wLjQtMC4yLTAuNyBjLTAuMywwLjMtMC42LDAuNS0wLjksMC43Yy0wLjMsMC4xLTAuNywwLjItMS4xLDAuMmMtMC4zLDAtMC41LDAtMC43LTAuMWMtMC4yLTAuMS0wLjQtMC4yLTAuNi0wLjNjLTAuMi0wLjEtMC4zLTAuMy0wLjQtMC41IGMtMC4xLTAuMi0wLjEtMC40LTAuMS0wLjdjMC0wLjMsMC4xLTAuNiwwLjItMC44YzAuMS0wLjIsMC4zLTAuNCwwLjQtMC41QzEyLDcsMTIuMiw2LjksMTIuNSw2LjhjMC4yLTAuMSwwLjUtMC4xLDAuNy0wLjIgYzAuMy0wLjEsMC41LTAuMSwwLjctMC4xYzAuMiwwLDAuNC0wLjEsMC42LTAuMWMwLjIsMCwwLjMtMC4xLDAuNC0wLjJjMC4xLTAuMSwwLjItMC4yLDAuMi0wLjRjMC0xLTEuMS0xLTEuMy0xIGMtMC40LDAtMS40LDAtMS40LDEuMmgtMC45YzAtMC40LDAuMS0wLjcsMC4yLTFjMC4xLTAuMiwwLjMtMC40LDAuNS0wLjZjMC4yLTAuMiwwLjUtMC4zLDAuOC0wLjNDMTMuMyw0LDEzLjYsNCwxMy45LDQgYzAuMywwLDAuNSwwLDAuOCwwLjFjMC4zLDAsMC41LDAuMSwwLjcsMC4yYzAuMiwwLjEsMC40LDAuMywwLjUsMC41QzE2LDUsMTYsNS4yLDE2LDUuNnYyLjljMCwwLjIsMCwwLjQsMCwwLjUgYzAsMC4xLDAuMSwwLjIsMC4zLDAuMmMwLjEsMCwwLjIsMCwwLjMsMFY5Ljh6IE0xNS4yLDYuOWMtMS4yLDAuNi0zLjEsMC4yLTMuMSwxLjRjMCwxLjQsMy4xLDEsMy4xLTAuNVY2Ljl6Ii8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-check: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIj4KICAgIDxwYXRoIGQ9Ik05IDE2LjE3TDQuODMgMTJsLTEuNDIgMS40MUw5IDE5IDIxIDdsLTEuNDEtMS40MXoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-circle-empty: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTEyIDJDNi40NyAyIDIgNi40NyAyIDEyczQuNDcgMTAgMTAgMTAgMTAtNC40NyAxMC0xMFMxNy41MyAyIDEyIDJ6bTAgMThjLTQuNDEgMC04LTMuNTktOC04czMuNTktOCA4LTggOCAzLjU5IDggOC0zLjU5IDgtOCA4eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-circle: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTggMTgiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPGNpcmNsZSBjeD0iOSIgY3k9IjkiIHI9IjgiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-clear: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8bWFzayBpZD0iZG9udXRIb2xlIj4KICAgIDxyZWN0IHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgZmlsbD0id2hpdGUiIC8+CiAgICA8Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI4IiBmaWxsPSJibGFjayIvPgogIDwvbWFzaz4KCiAgPGcgY2xhc3M9ImpwLWljb24zIiBmaWxsPSIjNjE2MTYxIj4KICAgIDxyZWN0IGhlaWdodD0iMTgiIHdpZHRoPSIyIiB4PSIxMSIgeT0iMyIgdHJhbnNmb3JtPSJyb3RhdGUoMzE1LCAxMiwgMTIpIi8+CiAgICA8Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSIxMCIgbWFzaz0idXJsKCNkb251dEhvbGUpIi8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-close: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbi1ub25lIGpwLWljb24tc2VsZWN0YWJsZS1pbnZlcnNlIGpwLWljb24zLWhvdmVyIiBmaWxsPSJub25lIj4KICAgIDxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjExIi8+CiAgPC9nPgoKICA8ZyBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIGpwLWljb24tYWNjZW50Mi1ob3ZlciIgZmlsbD0iIzYxNjE2MSI+CiAgICA8cGF0aCBkPSJNMTkgNi40MUwxNy41OSA1IDEyIDEwLjU5IDYuNDEgNSA1IDYuNDEgMTAuNTkgMTIgNSAxNy41OSA2LjQxIDE5IDEyIDEzLjQxIDE3LjU5IDE5IDE5IDE3LjU5IDEzLjQxIDEyeiIvPgogIDwvZz4KCiAgPGcgY2xhc3M9ImpwLWljb24tbm9uZSBqcC1pY29uLWJ1c3kiIGZpbGw9Im5vbmUiPgogICAgPGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iNyIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-code-check: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+CiAgICA8cGF0aCBkPSJNNi41OSwzLjQxTDIsOEw2LjU5LDEyLjZMOCwxMS4xOEw0LjgyLDhMOCw0LjgyTDYuNTksMy40MU0xMi40MSwzLjQxTDExLDQuODJMMTQuMTgsOEwxMSwxMS4xOEwxMi40MSwxMi42TDE3LDhMMTIuNDEsMy40MU0yMS41OSwxMS41OUwxMy41LDE5LjY4TDkuODMsMTZMOC40MiwxNy40MUwxMy41LDIyLjVMMjMsMTNMMjEuNTksMTEuNTlaIiAvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-code: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIiIGhlaWdodD0iMjIiIHZpZXdCb3g9IjAgMCAyOCAyOCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KCTxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CgkJPHBhdGggZD0iTTExLjQgMTguNkw2LjggMTRMMTEuNCA5LjRMMTAgOEw0IDE0TDEwIDIwTDExLjQgMTguNlpNMTYuNiAxOC42TDIxLjIgMTRMMTYuNiA5LjRMMTggOEwyNCAxNEwxOCAyMEwxNi42IDE4LjZWMTguNloiLz4KCTwvZz4KPC9zdmc+Cg==);
  --jp-icon-collapse-all: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGgKICAgICAgICAgICAgZD0iTTggMmMxIDAgMTEgMCAxMiAwczIgMSAyIDJjMCAxIDAgMTEgMCAxMnMwIDItMiAyQzIwIDE0IDIwIDQgMjAgNFMxMCA0IDYgNGMwLTIgMS0yIDItMnoiIC8+CiAgICAgICAgPHBhdGgKICAgICAgICAgICAgZD0iTTE4IDhjMC0xLTEtMi0yLTJTNSA2IDQgNnMtMiAxLTIgMmMwIDEgMCAxMSAwIDEyczEgMiAyIDJjMSAwIDExIDAgMTIgMHMyLTEgMi0yYzAtMSAwLTExIDAtMTJ6bS0yIDB2MTJINFY4eiIgLz4KICAgICAgICA8cGF0aCBkPSJNNiAxM3YyaDh2LTJ6IiAvPgogICAgPC9nPgo8L3N2Zz4K);
  --jp-icon-console: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIwMCAyMDAiPgogIDxnIGNsYXNzPSJqcC1jb25zb2xlLWljb24tYmFja2dyb3VuZC1jb2xvciBqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiMwMjg4RDEiPgogICAgPHBhdGggZD0iTTIwIDE5LjhoMTYwdjE1OS45SDIweiIvPgogIDwvZz4KICA8ZyBjbGFzcz0ianAtY29uc29sZS1pY29uLWNvbG9yIGpwLWljb24tc2VsZWN0YWJsZS1pbnZlcnNlIiBmaWxsPSIjZmZmIj4KICAgIDxwYXRoIGQ9Ik0xMDUgMTI3LjNoNDB2MTIuOGgtNDB6TTUxLjEgNzdMNzQgOTkuOWwtMjMuMyAyMy4zIDEwLjUgMTAuNSAyMy4zLTIzLjNMOTUgOTkuOSA4NC41IDg5LjQgNjEuNiA2Ni41eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-copy: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTggMTgiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTExLjksMUgzLjJDMi40LDEsMS43LDEuNywxLjcsMi41djEwLjJoMS41VjIuNWg4LjdWMXogTTE0LjEsMy45aC04Yy0wLjgsMC0xLjUsMC43LTEuNSwxLjV2MTAuMmMwLDAuOCwwLjcsMS41LDEuNSwxLjVoOCBjMC44LDAsMS41LTAuNywxLjUtMS41VjUuNEMxNS41LDQuNiwxNC45LDMuOSwxNC4xLDMuOXogTTE0LjEsMTUuNWgtOFY1LjRoOFYxNS41eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-copyright: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDI0IDI0IiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCI+CiAgPGcgY2xhc3M9ImpwLWljb24zIiBmaWxsPSIjNjE2MTYxIj4KICAgIDxwYXRoIGQ9Ik0xMS44OCw5LjE0YzEuMjgsMC4wNiwxLjYxLDEuMTUsMS42MywxLjY2aDEuNzljLTAuMDgtMS45OC0xLjQ5LTMuMTktMy40NS0zLjE5QzkuNjQsNy42MSw4LDksOCwxMi4xNCBjMCwxLjk0LDAuOTMsNC4yNCwzLjg0LDQuMjRjMi4yMiwwLDMuNDEtMS42NSwzLjQ0LTIuOTVoLTEuNzljLTAuMDMsMC41OS0wLjQ1LDEuMzgtMS42MywxLjQ0QzEwLjU1LDE0LjgzLDEwLDEzLjgxLDEwLDEyLjE0IEMxMCw5LjI1LDExLjI4LDkuMTYsMTEuODgsOS4xNHogTTEyLDJDNi40OCwyLDIsNi40OCwyLDEyczQuNDgsMTAsMTAsMTBzMTAtNC40OCwxMC0xMFMxNy41MiwyLDEyLDJ6IE0xMiwyMGMtNC40MSwwLTgtMy41OS04LTggczMuNTktOCw4LThzOCwzLjU5LDgsOFMxNi40MSwyMCwxMiwyMHoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-cut: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTkuNjQgNy42NGMuMjMtLjUuMzYtMS4wNS4zNi0xLjY0IDAtMi4yMS0xLjc5LTQtNC00UzIgMy43OSAyIDZzMS43OSA0IDQgNGMuNTkgMCAxLjE0LS4xMyAxLjY0LS4zNkwxMCAxMmwtMi4zNiAyLjM2QzcuMTQgMTQuMTMgNi41OSAxNCA2IDE0Yy0yLjIxIDAtNCAxLjc5LTQgNHMxLjc5IDQgNCA0IDQtMS43OSA0LTRjMC0uNTktLjEzLTEuMTQtLjM2LTEuNjRMMTIgMTRsNyA3aDN2LTFMOS42NCA3LjY0ek02IDhjLTEuMSAwLTItLjg5LTItMnMuOS0yIDItMiAyIC44OSAyIDItLjkgMi0yIDJ6bTAgMTJjLTEuMSAwLTItLjg5LTItMnMuOS0yIDItMiAyIC44OSAyIDItLjkgMi0yIDJ6bTYtNy41Yy0uMjggMC0uNS0uMjItLjUtLjVzLjIyLS41LjUtLjUuNS4yMi41LjUtLjIyLjUtLjUuNXpNMTkgM2wtNiA2IDIgMiA3LTdWM3oiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-delete: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjE2cHgiIGhlaWdodD0iMTZweCI+CiAgICA8cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIiAvPgogICAgPHBhdGggY2xhc3M9ImpwLWljb24zIiBmaWxsPSIjNjI2MjYyIiBkPSJNNiAxOWMwIDEuMS45IDIgMiAyaDhjMS4xIDAgMi0uOSAyLTJWN0g2djEyek0xOSA0aC0zLjVsLTEtMWgtNWwtMSAxSDV2MmgxNFY0eiIgLz4KPC9zdmc+Cg==);
  --jp-icon-download: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTE5IDloLTRWM0g5djZINWw3IDcgNy03ek01IDE4djJoMTR2LTJINXoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-duplicate: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHZpZXdCb3g9IjAgMCAxNCAxNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggY2xhc3M9ImpwLWljb24zIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTIuNzk5OTggMC44NzVIOC44OTU4MkM5LjIwMDYxIDAuODc1IDkuNDQ5OTggMS4xMzkxNCA5LjQ0OTk4IDEuNDYxOThDOS40NDk5OCAxLjc4NDgyIDkuMjAwNjEgMi4wNDg5NiA4Ljg5NTgyIDIuMDQ4OTZIMy4zNTQxNUMzLjA0OTM2IDIuMDQ4OTYgMi43OTk5OCAyLjMxMzEgMi43OTk5OCAyLjYzNTk0VjkuNjc5NjlDMi43OTk5OCAxMC4wMDI1IDIuNTUwNjEgMTAuMjY2NyAyLjI0NTgyIDEwLjI2NjdDMS45NDEwMyAxMC4yNjY3IDEuNjkxNjUgMTAuMDAyNSAxLjY5MTY1IDkuNjc5NjlWMi4wNDg5NkMxLjY5MTY1IDEuNDAzMjggMi4xOTA0IDAuODc1IDIuNzk5OTggMC44NzVaTTUuMzY2NjUgMTEuOVY0LjU1SDExLjA4MzNWMTEuOUg1LjM2NjY1Wk00LjE0MTY1IDQuMTQxNjdDNC4xNDE2NSAzLjY5MDYzIDQuNTA3MjggMy4zMjUgNC45NTgzMiAzLjMyNUgxMS40OTE3QzExLjk0MjcgMy4zMjUgMTIuMzA4MyAzLjY5MDYzIDEyLjMwODMgNC4xNDE2N1YxMi4zMDgzQzEyLjMwODMgMTIuNzU5NCAxMS45NDI3IDEzLjEyNSAxMS40OTE3IDEzLjEyNUg0Ljk1ODMyQzQuNTA3MjggMTMuMTI1IDQuMTQxNjUgMTIuNzU5NCA0LjE0MTY1IDEyLjMwODNWNC4xNDE2N1oiIGZpbGw9IiM2MTYxNjEiLz4KPHBhdGggY2xhc3M9ImpwLWljb24zIiBkPSJNOS40MzU3NCA4LjI2NTA3SDguMzY0MzFWOS4zMzY1QzguMzY0MzEgOS40NTQzNSA4LjI2Nzg4IDkuNTUwNzggOC4xNTAwMiA5LjU1MDc4QzguMDMyMTcgOS41NTA3OCA3LjkzNTc0IDkuNDU0MzUgNy45MzU3NCA5LjMzNjVWOC4yNjUwN0g2Ljg2NDMxQzYuNzQ2NDUgOC4yNjUwNyA2LjY1MDAyIDguMTY4NjQgNi42NTAwMiA4LjA1MDc4QzYuNjUwMDIgNy45MzI5MiA2Ljc0NjQ1IDcuODM2NSA2Ljg2NDMxIDcuODM2NUg3LjkzNTc0VjYuNzY1MDdDNy45MzU3NCA2LjY0NzIxIDguMDMyMTcgNi41NTA3OCA4LjE1MDAyIDYuNTUwNzhDOC4yNjc4OCA2LjU1MDc4IDguMzY0MzEgNi42NDcyMSA4LjM2NDMxIDYuNzY1MDdWNy44MzY1SDkuNDM1NzRDOS41NTM2IDcuODM2NSA5LjY1MDAyIDcuOTMyOTIgOS42NTAwMiA4LjA1MDc4QzkuNjUwMDIgOC4xNjg2NCA5LjU1MzYgOC4yNjUwNyA5LjQzNTc0IDguMjY1MDdaIiBmaWxsPSIjNjE2MTYxIiBzdHJva2U9IiM2MTYxNjEiIHN0cm9rZS13aWR0aD0iMC41Ii8+Cjwvc3ZnPgo=);
  --jp-icon-edit: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTMgMTcuMjVWMjFoMy43NUwxNy44MSA5Ljk0bC0zLjc1LTMuNzVMMyAxNy4yNXpNMjAuNzEgNy4wNGMuMzktLjM5LjM5LTEuMDIgMC0xLjQxbC0yLjM0LTIuMzRjLS4zOS0uMzktMS4wMi0uMzktMS40MSAwbC0xLjgzIDEuODMgMy43NSAzLjc1IDEuODMtMS44M3oiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-ellipses: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPGNpcmNsZSBjeD0iNSIgY3k9IjEyIiByPSIyIi8+CiAgICA8Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSIyIi8+CiAgICA8Y2lyY2xlIGN4PSIxOSIgY3k9IjEyIiByPSIyIi8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-error: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KPGcgY2xhc3M9ImpwLWljb24zIiBmaWxsPSIjNjE2MTYxIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjE5IiByPSIyIi8+PHBhdGggZD0iTTEwIDNoNHYxMmgtNHoiLz48L2c+CjxwYXRoIGZpbGw9Im5vbmUiIGQ9Ik0wIDBoMjR2MjRIMHoiLz4KPC9zdmc+Cg==);
  --jp-icon-expand-all: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGgKICAgICAgICAgICAgZD0iTTggMmMxIDAgMTEgMCAxMiAwczIgMSAyIDJjMCAxIDAgMTEgMCAxMnMwIDItMiAyQzIwIDE0IDIwIDQgMjAgNFMxMCA0IDYgNGMwLTIgMS0yIDItMnoiIC8+CiAgICAgICAgPHBhdGgKICAgICAgICAgICAgZD0iTTE4IDhjMC0xLTEtMi0yLTJTNSA2IDQgNnMtMiAxLTIgMmMwIDEgMCAxMSAwIDEyczEgMiAyIDJjMSAwIDExIDAgMTIgMHMyLTEgMi0yYzAtMSAwLTExIDAtMTJ6bS0yIDB2MTJINFY4eiIgLz4KICAgICAgICA8cGF0aCBkPSJNMTEgMTBIOXYzSDZ2MmgzdjNoMnYtM2gzdi0yaC0zeiIgLz4KICAgIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-extension: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTIwLjUgMTFIMTlWN2MwLTEuMS0uOS0yLTItMmgtNFYzLjVDMTMgMi4xMiAxMS44OCAxIDEwLjUgMVM4IDIuMTIgOCAzLjVWNUg0Yy0xLjEgMC0xLjk5LjktMS45OSAydjMuOEgzLjVjMS40OSAwIDIuNyAxLjIxIDIuNyAyLjdzLTEuMjEgMi43LTIuNyAyLjdIMlYyMGMwIDEuMS45IDIgMiAyaDMuOHYtMS41YzAtMS40OSAxLjIxLTIuNyAyLjctMi43IDEuNDkgMCAyLjcgMS4yMSAyLjcgMi43VjIySDE3YzEuMSAwIDItLjkgMi0ydi00aDEuNWMxLjM4IDAgMi41LTEuMTIgMi41LTIuNVMyMS44OCAxMSAyMC41IDExeiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-fast-forward: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTQgMThsOC41LTZMNCA2djEyem05LTEydjEybDguNS02TDEzIDZ6Ii8+CiAgICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-file-upload: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTkgMTZoNnYtNmg0bC03LTctNyA3aDR6bS00IDJoMTR2Mkg1eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-file: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8cGF0aCBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBkPSJNMTkuMyA4LjJsLTUuNS01LjVjLS4zLS4zLS43LS41LTEuMi0uNUgzLjljLS44LjEtMS42LjktMS42IDEuOHYxNC4xYzAgLjkuNyAxLjYgMS42IDEuNmgxNC4yYy45IDAgMS42LS43IDEuNi0xLjZWOS40Yy4xLS41LS4xLS45LS40LTEuMnptLTUuOC0zLjNsMy40IDMuNmgtMy40VjQuOXptMy45IDEyLjdINC43Yy0uMSAwLS4yIDAtLjItLjJWNC43YzAtLjIuMS0uMy4yLS4zaDcuMnY0LjRzMCAuOC4zIDEuMWMuMy4zIDEuMS4zIDEuMS4zaDQuM3Y3LjJzLS4xLjItLjIuMnoiLz4KPC9zdmc+Cg==);
  --jp-icon-filter-dot: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiNGRkYiPgogICAgPHBhdGggZD0iTTE0LDEyVjE5Ljg4QzE0LjA0LDIwLjE4IDEzLjk0LDIwLjUgMTMuNzEsMjAuNzFDMTMuMzIsMjEuMSAxMi42OSwyMS4xIDEyLjMsMjAuNzFMMTAuMjksMTguN0MxMC4wNiwxOC40NyA5Ljk2LDE4LjE2IDEwLDE3Ljg3VjEySDkuOTdMNC4yMSw0LjYyQzMuODcsNC4xOSAzLjk1LDMuNTYgNC4zOCwzLjIyQzQuNTcsMy4wOCA0Ljc4LDMgNSwzVjNIMTlWM0MxOS4yMiwzIDE5LjQzLDMuMDggMTkuNjIsMy4yMkMyMC4wNSwzLjU2IDIwLjEzLDQuMTkgMTkuNzksNC42MkwxNC4wMywxMkgxNFoiIC8+CiAgPC9nPgogIDxnIGNsYXNzPSJqcC1pY29uLWRvdCIgZmlsbD0iI0ZGRiI+CiAgICA8Y2lyY2xlIGN4PSIxOCIgY3k9IjE3IiByPSIzIj48L2NpcmNsZT4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-filter-list: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTEwIDE4aDR2LTJoLTR2MnpNMyA2djJoMThWNkgzem0zIDdoMTJ2LTJINnYyeiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-filter: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiNGRkYiPgogICAgPHBhdGggZD0iTTE0LDEyVjE5Ljg4QzE0LjA0LDIwLjE4IDEzLjk0LDIwLjUgMTMuNzEsMjAuNzFDMTMuMzIsMjEuMSAxMi42OSwyMS4xIDEyLjMsMjAuNzFMMTAuMjksMTguN0MxMC4wNiwxOC40NyA5Ljk2LDE4LjE2IDEwLDE3Ljg3VjEySDkuOTdMNC4yMSw0LjYyQzMuODcsNC4xOSAzLjk1LDMuNTYgNC4zOCwzLjIyQzQuNTcsMy4wOCA0Ljc4LDMgNSwzVjNIMTlWM0MxOS4yMiwzIDE5LjQzLDMuMDggMTkuNjIsMy4yMkMyMC4wNSwzLjU2IDIwLjEzLDQuMTkgMTkuNzksNC42MkwxNC4wMywxMkgxNFoiIC8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-folder-favorite: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAwIDI0IDI0IiB3aWR0aD0iMjRweCIgZmlsbD0iIzAwMDAwMCI+CiAgPHBhdGggZD0iTTAgMGgyNHYyNEgwVjB6IiBmaWxsPSJub25lIi8+PHBhdGggY2xhc3M9ImpwLWljb24zIGpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iIzYxNjE2MSIgZD0iTTIwIDZoLThsLTItMkg0Yy0xLjEgMC0yIC45LTIgMnYxMmMwIDEuMS45IDIgMiAyaDE2YzEuMSAwIDItLjkgMi0yVjhjMC0xLjEtLjktMi0yLTJ6bS0yLjA2IDExTDE1IDE1LjI4IDEyLjA2IDE3bC43OC0zLjMzLTIuNTktMi4yNCAzLjQxLS4yOUwxNSA4bDEuMzQgMy4xNCAzLjQxLjI5LTIuNTkgMi4yNC43OCAzLjMzeiIvPgo8L3N2Zz4K);
  --jp-icon-folder: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8cGF0aCBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBkPSJNMTAgNEg0Yy0xLjEgMC0xLjk5LjktMS45OSAyTDIgMThjMCAxLjEuOSAyIDIgMmgxNmMxLjEgMCAyLS45IDItMlY4YzAtMS4xLS45LTItMi0yaC04bC0yLTJ6Ii8+Cjwvc3ZnPgo=);
  --jp-icon-home: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAwIDI0IDI0IiB3aWR0aD0iMjRweCIgZmlsbD0iIzAwMDAwMCI+CiAgPHBhdGggZD0iTTAgMGgyNHYyNEgweiIgZmlsbD0ibm9uZSIvPjxwYXRoIGNsYXNzPSJqcC1pY29uMyBqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiM2MTYxNjEiIGQ9Ik0xMCAyMHYtNmg0djZoNXYtOGgzTDEyIDMgMiAxMmgzdjh6Ii8+Cjwvc3ZnPgo=);
  --jp-icon-html5: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDUxMiA1MTIiPgogIDxwYXRoIGNsYXNzPSJqcC1pY29uMCBqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiMwMDAiIGQ9Ik0xMDguNCAwaDIzdjIyLjhoMjEuMlYwaDIzdjY5aC0yM1Y0NmgtMjF2MjNoLTIzLjJNMjA2IDIzaC0yMC4zVjBoNjMuN3YyM0gyMjl2NDZoLTIzbTUzLjUtNjloMjQuMWwxNC44IDI0LjNMMzEzLjIgMGgyNC4xdjY5aC0yM1YzNC44bC0xNi4xIDI0LjgtMTYuMS0yNC44VjY5aC0yMi42bTg5LjItNjloMjN2NDYuMmgzMi42VjY5aC01NS42Ii8+CiAgPHBhdGggY2xhc3M9ImpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iI2U0NGQyNiIgZD0iTTEwNy42IDQ3MWwtMzMtMzcwLjRoMzYyLjhsLTMzIDM3MC4yTDI1NS43IDUxMiIvPgogIDxwYXRoIGNsYXNzPSJqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiNmMTY1MjkiIGQ9Ik0yNTYgNDgwLjVWMTMxaDE0OC4zTDM3NiA0NDciLz4KICA8cGF0aCBjbGFzcz0ianAtaWNvbi1zZWxlY3RhYmxlLWludmVyc2UiIGZpbGw9IiNlYmViZWIiIGQ9Ik0xNDIgMTc2LjNoMTE0djQ1LjRoLTY0LjJsNC4yIDQ2LjVoNjB2NDUuM0gxNTQuNG0yIDIyLjhIMjAybDMuMiAzNi4zIDUwLjggMTMuNnY0Ny40bC05My4yLTI2Ii8+CiAgPHBhdGggY2xhc3M9ImpwLWljb24tc2VsZWN0YWJsZS1pbnZlcnNlIiBmaWxsPSIjZmZmIiBkPSJNMzY5LjYgMTc2LjNIMjU1Ljh2NDUuNGgxMDkuNm0tNC4xIDQ2LjVIMjU1Ljh2NDUuNGg1NmwtNS4zIDU5LTUwLjcgMTMuNnY0Ny4ybDkzLTI1LjgiLz4KPC9zdmc+Cg==);
  --jp-icon-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8cGF0aCBjbGFzcz0ianAtaWNvbi1icmFuZDQganAtaWNvbi1zZWxlY3RhYmxlLWludmVyc2UiIGZpbGw9IiNGRkYiIGQ9Ik0yLjIgMi4yaDE3LjV2MTcuNUgyLjJ6Ii8+CiAgPHBhdGggY2xhc3M9ImpwLWljb24tYnJhbmQwIGpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iIzNGNTFCNSIgZD0iTTIuMiAyLjJ2MTcuNWgxNy41bC4xLTE3LjVIMi4yem0xMi4xIDIuMmMxLjIgMCAyLjIgMSAyLjIgMi4ycy0xIDIuMi0yLjIgMi4yLTIuMi0xLTIuMi0yLjIgMS0yLjIgMi4yLTIuMnpNNC40IDE3LjZsMy4zLTguOCAzLjMgNi42IDIuMi0zLjIgNC40IDUuNEg0LjR6Ii8+Cjwvc3ZnPgo=);
  --jp-icon-info: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDUwLjk3OCA1MC45NzgiPgoJPGcgY2xhc3M9ImpwLWljb24zIiBmaWxsPSIjNjE2MTYxIj4KCQk8cGF0aCBkPSJNNDMuNTIsNy40NThDMzguNzExLDIuNjQ4LDMyLjMwNywwLDI1LjQ4OSwwQzE4LjY3LDAsMTIuMjY2LDIuNjQ4LDcuNDU4LDcuNDU4CgkJCWMtOS45NDMsOS45NDEtOS45NDMsMjYuMTE5LDAsMzYuMDYyYzQuODA5LDQuODA5LDExLjIxMiw3LjQ1NiwxOC4wMzEsNy40NThjMCwwLDAuMDAxLDAsMC4wMDIsMAoJCQljNi44MTYsMCwxMy4yMjEtMi42NDgsMTguMDI5LTcuNDU4YzQuODA5LTQuODA5LDcuNDU3LTExLjIxMiw3LjQ1Ny0xOC4wM0M1MC45NzcsMTguNjcsNDguMzI4LDEyLjI2Niw0My41Miw3LjQ1OHoKCQkJIE00Mi4xMDYsNDIuMTA1Yy00LjQzMiw0LjQzMS0xMC4zMzIsNi44NzItMTYuNjE1LDYuODcyaC0wLjAwMmMtNi4yODUtMC4wMDEtMTIuMTg3LTIuNDQxLTE2LjYxNy02Ljg3MgoJCQljLTkuMTYyLTkuMTYzLTkuMTYyLTI0LjA3MSwwLTMzLjIzM0MxMy4zMDMsNC40NCwxOS4yMDQsMiwyNS40ODksMmM2LjI4NCwwLDEyLjE4NiwyLjQ0LDE2LjYxNyw2Ljg3MgoJCQljNC40MzEsNC40MzEsNi44NzEsMTAuMzMyLDYuODcxLDE2LjYxN0M0OC45NzcsMzEuNzcyLDQ2LjUzNiwzNy42NzUsNDIuMTA2LDQyLjEwNXoiLz4KCQk8cGF0aCBkPSJNMjMuNTc4LDMyLjIxOGMtMC4wMjMtMS43MzQsMC4xNDMtMy4wNTksMC40OTYtMy45NzJjMC4zNTMtMC45MTMsMS4xMS0xLjk5NywyLjI3Mi0zLjI1MwoJCQljMC40NjgtMC41MzYsMC45MjMtMS4wNjIsMS4zNjctMS41NzVjMC42MjYtMC43NTMsMS4xMDQtMS40NzgsMS40MzYtMi4xNzVjMC4zMzEtMC43MDcsMC40OTUtMS41NDEsMC40OTUtMi41CgkJCWMwLTEuMDk2LTAuMjYtMi4wODgtMC43NzktMi45NzljLTAuNTY1LTAuODc5LTEuNTAxLTEuMzM2LTIuODA2LTEuMzY5Yy0xLjgwMiwwLjA1Ny0yLjk4NSwwLjY2Ny0zLjU1LDEuODMyCgkJCWMtMC4zMDEsMC41MzUtMC41MDMsMS4xNDEtMC42MDcsMS44MTRjLTAuMTM5LDAuNzA3LTAuMjA3LDEuNDMyLTAuMjA3LDIuMTc0aC0yLjkzN2MtMC4wOTEtMi4yMDgsMC40MDctNC4xMTQsMS40OTMtNS43MTkKCQkJYzEuMDYyLTEuNjQsMi44NTUtMi40ODEsNS4zNzgtMi41MjdjMi4xNiwwLjAyMywzLjg3NCwwLjYwOCw1LjE0MSwxLjc1OGMxLjI3OCwxLjE2LDEuOTI5LDIuNzY0LDEuOTUsNC44MTEKCQkJYzAsMS4xNDItMC4xMzcsMi4xMTEtMC40MSwyLjkxMWMtMC4zMDksMC44NDUtMC43MzEsMS41OTMtMS4yNjgsMi4yNDNjLTAuNDkyLDAuNjUtMS4wNjgsMS4zMTgtMS43MywyLjAwMgoJCQljLTAuNjUsMC42OTctMS4zMTMsMS40NzktMS45ODcsMi4zNDZjLTAuMjM5LDAuMzc3LTAuNDI5LDAuNzc3LTAuNTY1LDEuMTk5Yy0wLjE2LDAuOTU5LTAuMjE3LDEuOTUxLTAuMTcxLDIuOTc5CgkJCUMyNi41ODksMzIuMjE4LDIzLjU3OCwzMi4yMTgsMjMuNTc4LDMyLjIxOHogTTIzLjU3OCwzOC4yMnYtMy40ODRoMy4wNzZ2My40ODRIMjMuNTc4eiIvPgoJPC9nPgo8L3N2Zz4K);
  --jp-icon-inspector: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8cGF0aCBjbGFzcz0ianAtaW5zcGVjdG9yLWljb24tY29sb3IganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBkPSJNMjAgNEg0Yy0xLjEgMC0xLjk5LjktMS45OSAyTDIgMThjMCAxLjEuOSAyIDIgMmgxNmMxLjEgMCAyLS45IDItMlY2YzAtMS4xLS45LTItMi0yem0tNSAxNEg0di00aDExdjR6bTAtNUg0VjloMTF2NHptNSA1aC00VjloNHY5eiIvPgo8L3N2Zz4K);
  --jp-icon-json: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8ZyBjbGFzcz0ianAtanNvbi1pY29uLWNvbG9yIGpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iI0Y5QTgyNSI+CiAgICA8cGF0aCBkPSJNMjAuMiAxMS44Yy0xLjYgMC0xLjcuNS0xLjcgMSAwIC40LjEuOS4xIDEuMy4xLjUuMS45LjEgMS4zIDAgMS43LTEuNCAyLjMtMy41IDIuM2gtLjl2LTEuOWguNWMxLjEgMCAxLjQgMCAxLjQtLjggMC0uMyAwLS42LS4xLTEgMC0uNC0uMS0uOC0uMS0xLjIgMC0xLjMgMC0xLjggMS4zLTItMS4zLS4yLTEuMy0uNy0xLjMtMiAwLS40LjEtLjguMS0xLjIuMS0uNC4xLS43LjEtMSAwLS44LS40LS43LTEuNC0uOGgtLjVWNC4xaC45YzIuMiAwIDMuNS43IDMuNSAyLjMgMCAuNC0uMS45LS4xIDEuMy0uMS41LS4xLjktLjEgMS4zIDAgLjUuMiAxIDEuNyAxdjEuOHpNMS44IDEwLjFjMS42IDAgMS43LS41IDEuNy0xIDAtLjQtLjEtLjktLjEtMS4zLS4xLS41LS4xLS45LS4xLTEuMyAwLTEuNiAxLjQtMi4zIDMuNS0yLjNoLjl2MS45aC0uNWMtMSAwLTEuNCAwLTEuNC44IDAgLjMgMCAuNi4xIDEgMCAuMi4xLjYuMSAxIDAgMS4zIDAgMS44LTEuMyAyQzYgMTEuMiA2IDExLjcgNiAxM2MwIC40LS4xLjgtLjEgMS4yLS4xLjMtLjEuNy0uMSAxIDAgLjguMy44IDEuNC44aC41djEuOWgtLjljLTIuMSAwLTMuNS0uNi0zLjUtMi4zIDAtLjQuMS0uOS4xLTEuMy4xLS41LjEtLjkuMS0xLjMgMC0uNS0uMi0xLTEuNy0xdi0xLjl6Ii8+CiAgICA8Y2lyY2xlIGN4PSIxMSIgY3k9IjEzLjgiIHI9IjIuMSIvPgogICAgPGNpcmNsZSBjeD0iMTEiIGN5PSI4LjIiIHI9IjIuMSIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-julia: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDMyNSAzMDAiPgogIDxnIGNsYXNzPSJqcC1icmFuZDAganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjY2IzYzMzIj4KICAgIDxwYXRoIGQ9Ik0gMTUwLjg5ODQzOCAyMjUgQyAxNTAuODk4NDM4IDI2Ni40MjE4NzUgMTE3LjMyMDMxMiAzMDAgNzUuODk4NDM4IDMwMCBDIDM0LjQ3NjU2MiAzMDAgMC44OTg0MzggMjY2LjQyMTg3NSAwLjg5ODQzOCAyMjUgQyAwLjg5ODQzOCAxODMuNTc4MTI1IDM0LjQ3NjU2MiAxNTAgNzUuODk4NDM4IDE1MCBDIDExNy4zMjAzMTIgMTUwIDE1MC44OTg0MzggMTgzLjU3ODEyNSAxNTAuODk4NDM4IDIyNSIvPgogIDwvZz4KICA8ZyBjbGFzcz0ianAtYnJhbmQwIGpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iIzM4OTgyNiI+CiAgICA8cGF0aCBkPSJNIDIzNy41IDc1IEMgMjM3LjUgMTE2LjQyMTg3NSAyMDMuOTIxODc1IDE1MCAxNjIuNSAxNTAgQyAxMjEuMDc4MTI1IDE1MCA4Ny41IDExNi40MjE4NzUgODcuNSA3NSBDIDg3LjUgMzMuNTc4MTI1IDEyMS4wNzgxMjUgMCAxNjIuNSAwIEMgMjAzLjkyMTg3NSAwIDIzNy41IDMzLjU3ODEyNSAyMzcuNSA3NSIvPgogIDwvZz4KICA8ZyBjbGFzcz0ianAtYnJhbmQwIGpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iIzk1NThiMiI+CiAgICA8cGF0aCBkPSJNIDMyNC4xMDE1NjIgMjI1IEMgMzI0LjEwMTU2MiAyNjYuNDIxODc1IDI5MC41MjM0MzggMzAwIDI0OS4xMDE1NjIgMzAwIEMgMjA3LjY3OTY4OCAzMDAgMTc0LjEwMTU2MiAyNjYuNDIxODc1IDE3NC4xMDE1NjIgMjI1IEMgMTc0LjEwMTU2MiAxODMuNTc4MTI1IDIwNy42Nzk2ODggMTUwIDI0OS4xMDE1NjIgMTUwIEMgMjkwLjUyMzQzOCAxNTAgMzI0LjEwMTU2MiAxODMuNTc4MTI1IDMyNC4xMDE1NjIgMjI1Ii8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-jupyter-favicon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUyIiBoZWlnaHQ9IjE2NSIgdmlld0JveD0iMCAwIDE1MiAxNjUiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgPGcgY2xhc3M9ImpwLWp1cHl0ZXItaWNvbi1jb2xvciIgZmlsbD0iI0YzNzcyNiI+CiAgICA8cGF0aCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLjA3ODk0NywgMTEwLjU4MjkyNykiIGQ9Ik03NS45NDIyODQyLDI5LjU4MDQ1NjEgQzQzLjMwMjM5NDcsMjkuNTgwNDU2MSAxNC43OTY3ODMyLDE3LjY1MzQ2MzQgMCwwIEM1LjUxMDgzMjExLDE1Ljg0MDY4MjkgMTUuNzgxNTM4OSwyOS41NjY3NzMyIDI5LjM5MDQ5NDcsMzkuMjc4NDE3MSBDNDIuOTk5Nyw0OC45ODk4NTM3IDU5LjI3MzcsNTQuMjA2NzgwNSA3NS45NjA1Nzg5LDU0LjIwNjc4MDUgQzkyLjY0NzQ1NzksNTQuMjA2NzgwNSAxMDguOTIxNDU4LDQ4Ljk4OTg1MzcgMTIyLjUzMDY2MywzOS4yNzg0MTcxIEMxMzYuMTM5NDUzLDI5LjU2Njc3MzIgMTQ2LjQxMDI4NCwxNS44NDA2ODI5IDE1MS45MjExNTgsMCBDMTM3LjA4Nzg2OCwxNy42NTM0NjM0IDEwOC41ODI1ODksMjkuNTgwNDU2MSA3NS45NDIyODQyLDI5LjU4MDQ1NjEgTDc1Ljk0MjI4NDIsMjkuNTgwNDU2MSBaIiAvPgogICAgPHBhdGggdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMzczNjgsIDAuNzA0ODc4KSIgZD0iTTc1Ljk3ODQ1NzksMjQuNjI2NDA3MyBDMTA4LjYxODc2MywyNC42MjY0MDczIDEzNy4xMjQ0NTgsMzYuNTUzNDQxNSAxNTEuOTIxMTU4LDU0LjIwNjc4MDUgQzE0Ni40MTAyODQsMzguMzY2MjIyIDEzNi4xMzk0NTMsMjQuNjQwMTMxNyAxMjIuNTMwNjYzLDE0LjkyODQ4NzggQzEwOC45MjE0NTgsNS4yMTY4NDM5IDkyLjY0NzQ1NzksMCA3NS45NjA1Nzg5LDAgQzU5LjI3MzcsMCA0Mi45OTk3LDUuMjE2ODQzOSAyOS4zOTA0OTQ3LDE0LjkyODQ4NzggQzE1Ljc4MTUzODksMjQuNjQwMTMxNyA1LjUxMDgzMjExLDM4LjM2NjIyMiAwLDU0LjIwNjc4MDUgQzE0LjgzMzA4MTYsMzYuNTg5OTI5MyA0My4zMzg1Njg0LDI0LjYyNjQwNzMgNzUuOTc4NDU3OSwyNC42MjY0MDczIEw3NS45Nzg0NTc5LDI0LjYyNjQwNzMgWiIgLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-jupyter: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzkiIGhlaWdodD0iNTEiIHZpZXdCb3g9IjAgMCAzOSA1MSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTYzOCAtMjI4MSkiPgogICAgIDxnIGNsYXNzPSJqcC1qdXB5dGVyLWljb24tY29sb3IiIGZpbGw9IiNGMzc3MjYiPgogICAgICA8cGF0aCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjM5Ljc0IDIzMTEuOTgpIiBkPSJNIDE4LjI2NDYgNy4xMzQxMUMgMTAuNDE0NSA3LjEzNDExIDMuNTU4NzIgNC4yNTc2IDAgMEMgMS4zMjUzOSAzLjgyMDQgMy43OTU1NiA3LjEzMDgxIDcuMDY4NiA5LjQ3MzAzQyAxMC4zNDE3IDExLjgxNTIgMTQuMjU1NyAxMy4wNzM0IDE4LjI2OSAxMy4wNzM0QyAyMi4yODIzIDEzLjA3MzQgMjYuMTk2MyAxMS44MTUyIDI5LjQ2OTQgOS40NzMwM0MgMzIuNzQyNCA3LjEzMDgxIDM1LjIxMjYgMy44MjA0IDM2LjUzOCAwQyAzMi45NzA1IDQuMjU3NiAyNi4xMTQ4IDcuMTM0MTEgMTguMjY0NiA3LjEzNDExWiIvPgogICAgICA8cGF0aCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjM5LjczIDIyODUuNDgpIiBkPSJNIDE4LjI3MzMgNS45MzkzMUMgMjYuMTIzNSA1LjkzOTMxIDMyLjk3OTMgOC44MTU4MyAzNi41MzggMTMuMDczNEMgMzUuMjEyNiA5LjI1MzAzIDMyLjc0MjQgNS45NDI2MiAyOS40Njk0IDMuNjAwNEMgMjYuMTk2MyAxLjI1ODE4IDIyLjI4MjMgMCAxOC4yNjkgMEMgMTQuMjU1NyAwIDEwLjM0MTcgMS4yNTgxOCA3LjA2ODYgMy42MDA0QyAzLjc5NTU2IDUuOTQyNjIgMS4zMjUzOSA5LjI1MzAzIDAgMTMuMDczNEMgMy41Njc0NSA4LjgyNDYzIDEwLjQyMzIgNS45MzkzMSAxOC4yNzMzIDUuOTM5MzFaIi8+CiAgICA8L2c+CiAgICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgICA8cGF0aCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjY5LjMgMjI4MS4zMSkiIGQ9Ik0gNS44OTM1MyAyLjg0NEMgNS45MTg4OSAzLjQzMTY1IDUuNzcwODUgNC4wMTM2NyA1LjQ2ODE1IDQuNTE2NDVDIDUuMTY1NDUgNS4wMTkyMiA0LjcyMTY4IDUuNDIwMTUgNC4xOTI5OSA1LjY2ODUxQyAzLjY2NDMgNS45MTY4OCAzLjA3NDQ0IDYuMDAxNTEgMi40OTgwNSA1LjkxMTcxQyAxLjkyMTY2IDUuODIxOSAxLjM4NDYzIDUuNTYxNyAwLjk1NDg5OCA1LjE2NDAxQyAwLjUyNTE3IDQuNzY2MzMgMC4yMjIwNTYgNC4yNDkwMyAwLjA4MzkwMzcgMy42Nzc1N0MgLTAuMDU0MjQ4MyAzLjEwNjExIC0wLjAyMTIzIDIuNTA2MTcgMC4xNzg3ODEgMS45NTM2NEMgMC4zNzg3OTMgMS40MDExIDAuNzM2ODA5IDAuOTIwODE3IDEuMjA3NTQgMC41NzM1MzhDIDEuNjc4MjYgMC4yMjYyNTkgMi4yNDA1NSAwLjAyNzU5MTkgMi44MjMyNiAwLjAwMjY3MjI5QyAzLjYwMzg5IC0wLjAzMDcxMTUgNC4zNjU3MyAwLjI0OTc4OSA0Ljk0MTQyIDAuNzgyNTUxQyA1LjUxNzExIDEuMzE1MzEgNS44NTk1NiAyLjA1Njc2IDUuODkzNTMgMi44NDRaIi8+CiAgICAgIDxwYXRoIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE2MzkuOCAyMzIzLjgxKSIgZD0iTSA3LjQyNzg5IDMuNTgzMzhDIDcuNDYwMDggNC4zMjQzIDcuMjczNTUgNS4wNTgxOSA2Ljg5MTkzIDUuNjkyMTNDIDYuNTEwMzEgNi4zMjYwNyA1Ljk1MDc1IDYuODMxNTYgNS4yODQxMSA3LjE0NDZDIDQuNjE3NDcgNy40NTc2MyAzLjg3MzcxIDcuNTY0MTQgMy4xNDcwMiA3LjQ1MDYzQyAyLjQyMDMyIDcuMzM3MTIgMS43NDMzNiA3LjAwODcgMS4yMDE4NCA2LjUwNjk1QyAwLjY2MDMyOCA2LjAwNTIgMC4yNzg2MSA1LjM1MjY4IDAuMTA1MDE3IDQuNjMyMDJDIC0wLjA2ODU3NTcgMy45MTEzNSAtMC4wMjYyMzYxIDMuMTU0OTQgMC4yMjY2NzUgMi40NTg1NkMgMC40Nzk1ODcgMS43NjIxNyAwLjkzMTY5NyAxLjE1NzEzIDEuNTI1NzYgMC43MjAwMzNDIDIuMTE5ODMgMC4yODI5MzUgMi44MjkxNCAwLjAzMzQzOTUgMy41NjM4OSAwLjAwMzEzMzQ0QyA0LjU0NjY3IC0wLjAzNzQwMzMgNS41MDUyOSAwLjMxNjcwNiA2LjIyOTYxIDAuOTg3ODM1QyA2Ljk1MzkzIDEuNjU4OTYgNy4zODQ4NCAyLjU5MjM1IDcuNDI3ODkgMy41ODMzOEwgNy40Mjc4OSAzLjU4MzM4WiIvPgogICAgICA8cGF0aCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjM4LjM2IDIyODYuMDYpIiBkPSJNIDIuMjc0NzEgNC4zOTYyOUMgMS44NDM2MyA0LjQxNTA4IDEuNDE2NzEgNC4zMDQ0NSAxLjA0Nzk5IDQuMDc4NDNDIDAuNjc5MjY4IDMuODUyNCAwLjM4NTMyOCAzLjUyMTE0IDAuMjAzMzcxIDMuMTI2NTZDIDAuMDIxNDEzNiAyLjczMTk4IC0wLjA0MDM3OTggMi4yOTE4MyAwLjAyNTgxMTYgMS44NjE4MUMgMC4wOTIwMDMxIDEuNDMxOCAwLjI4MzIwNCAxLjAzMTI2IDAuNTc1MjEzIDAuNzEwODgzQyAwLjg2NzIyMiAwLjM5MDUxIDEuMjQ2OTEgMC4xNjQ3MDggMS42NjYyMiAwLjA2MjA1OTJDIDIuMDg1NTMgLTAuMDQwNTg5NyAyLjUyNTYxIC0wLjAxNTQ3MTQgMi45MzA3NiAwLjEzNDIzNUMgMy4zMzU5MSAwLjI4Mzk0MSAzLjY4NzkyIDAuNTUxNTA1IDMuOTQyMjIgMC45MDMwNkMgNC4xOTY1MiAxLjI1NDYyIDQuMzQxNjkgMS42NzQzNiA0LjM1OTM1IDIuMTA5MTZDIDQuMzgyOTkgMi42OTEwNyA0LjE3Njc4IDMuMjU4NjkgMy43ODU5NyAzLjY4NzQ2QyAzLjM5NTE2IDQuMTE2MjQgMi44NTE2NiA0LjM3MTE2IDIuMjc0NzEgNC4zOTYyOUwgMi4yNzQ3MSA0LjM5NjI5WiIvPgogICAgPC9nPgogIDwvZz4+Cjwvc3ZnPgo=);
  --jp-icon-jupyterlab-wordmark: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMDAiIHZpZXdCb3g9IjAgMCAxODYwLjggNDc1Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjIiIGZpbGw9IiM0RTRFNEUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDQ4MC4xMzY0MDEsIDY0LjI3MTQ5MykiPgogICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsIDU4Ljg3NTU2NikiPgogICAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLjA4NzYwMywgMC4xNDAyOTQpIj4KICAgICAgICA8cGF0aCBkPSJNLTQyNi45LDE2OS44YzAsNDguNy0zLjcsNjQuNy0xMy42LDc2LjRjLTEwLjgsMTAtMjUsMTUuNS0zOS43LDE1LjVsMy43LDI5IGMyMi44LDAuMyw0NC44LTcuOSw2MS45LTIzLjFjMTcuOC0xOC41LDI0LTQ0LjEsMjQtODMuM1YwSC00Mjd2MTcwLjFMLTQyNi45LDE2OS44TC00MjYuOSwxNjkuOHoiLz4KICAgICAgPC9nPgogICAgPC9nPgogICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTU1LjA0NTI5NiwgNTYuODM3MTA0KSI+CiAgICAgIDxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEuNTYyNDUzLCAxLjc5OTg0MikiPgogICAgICAgIDxwYXRoIGQ9Ik0tMzEyLDE0OGMwLDIxLDAsMzkuNSwxLjcsNTUuNGgtMzEuOGwtMi4xLTMzLjNoLTAuOGMtNi43LDExLjYtMTYuNCwyMS4zLTI4LDI3LjkgYy0xMS42LDYuNi0yNC44LDEwLTM4LjIsOS44Yy0zMS40LDAtNjktMTcuNy02OS04OVYwaDM2LjR2MTEyLjdjMCwzOC43LDExLjYsNjQuNyw0NC42LDY0LjdjMTAuMy0wLjIsMjAuNC0zLjUsMjguOS05LjQgYzguNS01LjksMTUuMS0xNC4zLDE4LjktMjMuOWMyLjItNi4xLDMuMy0xMi41LDMuMy0xOC45VjAuMmgzNi40VjE0OEgtMzEyTC0zMTIsMTQ4eiIvPgogICAgICA8L2c+CiAgICA8L2c+CiAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzOTAuMDEzMzIyLCA1My40Nzk2MzgpIj4KICAgICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMS43MDY0NTgsIDAuMjMxNDI1KSI+CiAgICAgICAgPHBhdGggZD0iTS00NzguNiw3MS40YzAtMjYtMC44LTQ3LTEuNy02Ni43aDMyLjdsMS43LDM0LjhoMC44YzcuMS0xMi41LDE3LjUtMjIuOCwzMC4xLTI5LjcgYzEyLjUtNywyNi43LTEwLjMsNDEtOS44YzQ4LjMsMCw4NC43LDQxLjcsODQuNywxMDMuM2MwLDczLjEtNDMuNywxMDkuMi05MSwxMDkuMmMtMTIuMSwwLjUtMjQuMi0yLjItMzUtNy44IGMtMTAuOC01LjYtMTkuOS0xMy45LTI2LjYtMjQuMmgtMC44VjI5MWgtMzZ2LTIyMEwtNDc4LjYsNzEuNEwtNDc4LjYsNzEuNHogTS00NDIuNiwxMjUuNmMwLjEsNS4xLDAuNiwxMC4xLDEuNywxNS4xIGMzLDEyLjMsOS45LDIzLjMsMTkuOCwzMS4xYzkuOSw3LjgsMjIuMSwxMi4xLDM0LjcsMTIuMWMzOC41LDAsNjAuNy0zMS45LDYwLjctNzguNWMwLTQwLjctMjEuMS03NS42LTU5LjUtNzUuNiBjLTEyLjksMC40LTI1LjMsNS4xLTM1LjMsMTMuNGMtOS45LDguMy0xNi45LDE5LjctMTkuNiwzMi40Yy0xLjUsNC45LTIuMywxMC0yLjUsMTUuMVYxMjUuNkwtNDQyLjYsMTI1LjZMLTQ0Mi42LDEyNS42eiIvPgogICAgICA8L2c+CiAgICA8L2c+CiAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg2MDYuNzQwNzI2LCA1Ni44MzcxMDQpIj4KICAgICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC43NTEyMjYsIDEuOTg5Mjk5KSI+CiAgICAgICAgPHBhdGggZD0iTS00NDAuOCwwbDQzLjcsMTIwLjFjNC41LDEzLjQsOS41LDI5LjQsMTIuOCw0MS43aDAuOGMzLjctMTIuMiw3LjktMjcuNywxMi44LTQyLjQgbDM5LjctMTE5LjJoMzguNUwtMzQ2LjksMTQ1Yy0yNiw2OS43LTQzLjcsMTA1LjQtNjguNiwxMjcuMmMtMTIuNSwxMS43LTI3LjksMjAtNDQuNiwyMy45bC05LjEtMzEuMSBjMTEuNy0zLjksMjIuNS0xMC4xLDMxLjgtMTguMWMxMy4yLTExLjEsMjMuNy0yNS4yLDMwLjYtNDEuMmMxLjUtMi44LDIuNS01LjcsMi45LTguOGMtMC4zLTMuMy0xLjItNi42LTIuNS05LjdMLTQ4MC4yLDAuMSBoMzkuN0wtNDQwLjgsMEwtNDQwLjgsMHoiLz4KICAgICAgPC9nPgogICAgPC9nPgogICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoODIyLjc0ODEwNCwgMC4wMDAwMDApIj4KICAgICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMS40NjQwNTAsIDAuMzc4OTE0KSI+CiAgICAgICAgPHBhdGggZD0iTS00MTMuNywwdjU4LjNoNTJ2MjguMmgtNTJWMTk2YzAsMjUsNywzOS41LDI3LjMsMzkuNWM3LjEsMC4xLDE0LjItMC43LDIxLjEtMi41IGwxLjcsMjcuN2MtMTAuMywzLjctMjEuMyw1LjQtMzIuMiw1Yy03LjMsMC40LTE0LjYtMC43LTIxLjMtMy40Yy02LjgtMi43LTEyLjktNi44LTE3LjktMTIuMWMtMTAuMy0xMC45LTE0LjEtMjktMTQuMS01Mi45IFY4Ni41aC0zMVY1OC4zaDMxVjkuNkwtNDEzLjcsMEwtNDEzLjcsMHoiLz4KICAgICAgPC9nPgogICAgPC9nPgogICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoOTc0LjQzMzI4NiwgNTMuNDc5NjM4KSI+CiAgICAgIDxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAuOTkwMDM0LCAwLjYxMDMzOSkiPgogICAgICAgIDxwYXRoIGQ9Ik0tNDQ1LjgsMTEzYzAuOCw1MCwzMi4yLDcwLjYsNjguNiw3MC42YzE5LDAuNiwzNy45LTMsNTUuMy0xMC41bDYuMiwyNi40IGMtMjAuOSw4LjktNDMuNSwxMy4xLTY2LjIsMTIuNmMtNjEuNSwwLTk4LjMtNDEuMi05OC4zLTEwMi41Qy00ODAuMiw0OC4yLTQ0NC43LDAtMzg2LjUsMGM2NS4yLDAsODIuNyw1OC4zLDgyLjcsOTUuNyBjLTAuMSw1LjgtMC41LDExLjUtMS4yLDE3LjJoLTE0MC42SC00NDUuOEwtNDQ1LjgsMTEzeiBNLTMzOS4yLDg2LjZjMC40LTIzLjUtOS41LTYwLjEtNTAuNC02MC4xIGMtMzYuOCwwLTUyLjgsMzQuNC01NS43LDYwLjFILTMzOS4yTC0zMzkuMiw4Ni42TC0zMzkuMiw4Ni42eiIvPgogICAgICA8L2c+CiAgICA8L2c+CiAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMjAxLjk2MTA1OCwgNTMuNDc5NjM4KSI+CiAgICAgIDxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEuMTc5NjQwLCAwLjcwNTA2OCkiPgogICAgICAgIDxwYXRoIGQ9Ik0tNDc4LjYsNjhjMC0yMy45LTAuNC00NC41LTEuNy02My40aDMxLjhsMS4yLDM5LjloMS43YzkuMS0yNy4zLDMxLTQ0LjUsNTUuMy00NC41IGMzLjUtMC4xLDcsMC40LDEwLjMsMS4ydjM0LjhjLTQuMS0wLjktOC4yLTEuMy0xMi40LTEuMmMtMjUuNiwwLTQzLjcsMTkuNy00OC43LDQ3LjRjLTEsNS43LTEuNiwxMS41LTEuNywxNy4ydjEwOC4zaC0zNlY2OCBMLTQ3OC42LDY4eiIvPgogICAgICA8L2c+CiAgICA8L2c+CiAgPC9nPgoKICA8ZyBjbGFzcz0ianAtaWNvbi13YXJuMCIgZmlsbD0iI0YzNzcyNiI+CiAgICA8cGF0aCBkPSJNMTM1Mi4zLDMyNi4yaDM3VjI4aC0zN1YzMjYuMnogTTE2MDQuOCwzMjYuMmMtMi41LTEzLjktMy40LTMxLjEtMy40LTQ4Ljd2LTc2IGMwLTQwLjctMTUuMS04My4xLTc3LjMtODMuMWMtMjUuNiwwLTUwLDcuMS02Ni44LDE4LjFsOC40LDI0LjRjMTQuMy05LjIsMzQtMTUuMSw1My0xNS4xYzQxLjYsMCw0Ni4yLDMwLjIsNDYuMiw0N3Y0LjIgYy03OC42LTAuNC0xMjIuMywyNi41LTEyMi4zLDc1LjZjMCwyOS40LDIxLDU4LjQsNjIuMiw1OC40YzI5LDAsNTAuOS0xNC4zLDYyLjItMzAuMmgxLjNsMi45LDI1LjZIMTYwNC44eiBNMTU2NS43LDI1Ny43IGMwLDMuOC0wLjgsOC0yLjEsMTEuOGMtNS45LDE3LjItMjIuNywzNC00OS4yLDM0Yy0xOC45LDAtMzQuOS0xMS4zLTM0LjktMzUuM2MwLTM5LjUsNDUuOC00Ni42LDg2LjItNDUuOFYyNTcuN3ogTTE2OTguNSwzMjYuMiBsMS43LTMzLjZoMS4zYzE1LjEsMjYuOSwzOC43LDM4LjIsNjguMSwzOC4yYzQ1LjQsMCw5MS4yLTM2LjEsOTEuMi0xMDguOGMwLjQtNjEuNy0zNS4zLTEwMy43LTg1LjctMTAzLjcgYy0zMi44LDAtNTYuMywxNC43LTY5LjMsMzcuNGgtMC44VjI4aC0zNi42djI0NS43YzAsMTguMS0wLjgsMzguNi0xLjcsNTIuNUgxNjk4LjV6IE0xNzA0LjgsMjA4LjJjMC01LjksMS4zLTEwLjksMi4xLTE1LjEgYzcuNi0yOC4xLDMxLjEtNDUuNCw1Ni4zLTQ1LjRjMzkuNSwwLDYwLjUsMzQuOSw2MC41LDc1LjZjMCw0Ni42LTIzLjEsNzguMS02MS44LDc4LjFjLTI2LjksMC00OC4zLTE3LjYtNTUuNS00My4zIGMtMC44LTQuMi0xLjctOC44LTEuNy0xMy40VjIwOC4yeiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-kernel: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxwYXRoIGNsYXNzPSJqcC1pY29uMiIgZmlsbD0iIzYxNjE2MSIgZD0iTTE1IDlIOXY2aDZWOXptLTIgNGgtMnYtMmgydjJ6bTgtMlY5aC0yVjdjMC0xLjEtLjktMi0yLTJoLTJWM2gtMnYyaC0yVjNIOXYySDdjLTEuMSAwLTIgLjktMiAydjJIM3YyaDJ2MkgzdjJoMnYyYzAgMS4xLjkgMiAyIDJoMnYyaDJ2LTJoMnYyaDJ2LTJoMmMxLjEgMCAyLS45IDItMnYtMmgydi0yaC0ydi0yaDJ6bS00IDZIN1Y3aDEwdjEweiIvPgo8L3N2Zz4K);
  --jp-icon-keyboard: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8cGF0aCBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBkPSJNMjAgNUg0Yy0xLjEgMC0xLjk5LjktMS45OSAyTDIgMTdjMCAxLjEuOSAyIDIgMmgxNmMxLjEgMCAyLS45IDItMlY3YzAtMS4xLS45LTItMi0yem0tOSAzaDJ2MmgtMlY4em0wIDNoMnYyaC0ydi0yek04IDhoMnYySDhWOHptMCAzaDJ2Mkg4di0yem0tMSAySDV2LTJoMnYyem0wLTNINVY4aDJ2MnptOSA3SDh2LTJoOHYyem0wLTRoLTJ2LTJoMnYyem0wLTNoLTJWOGgydjJ6bTMgM2gtMnYtMmgydjJ6bTAtM2gtMlY4aDJ2MnoiLz4KPC9zdmc+Cg==);
  --jp-icon-launch: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMzIgMzIiIHdpZHRoPSIzMiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIj4KICAgIDxwYXRoIGQ9Ik0yNiwyOEg2YTIuMDAyNywyLjAwMjcsMCwwLDEtMi0yVjZBMi4wMDI3LDIuMDAyNywwLDAsMSw2LDRIMTZWNkg2VjI2SDI2VjE2aDJWMjZBMi4wMDI3LDIuMDAyNywwLDAsMSwyNiwyOFoiLz4KICAgIDxwb2x5Z29uIHBvaW50cz0iMjAgMiAyMCA0IDI2LjU4NiA0IDE4IDEyLjU4NiAxOS40MTQgMTQgMjggNS40MTQgMjggMTIgMzAgMTIgMzAgMiAyMCAyIi8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-launcher: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8cGF0aCBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBkPSJNMTkgMTlINVY1aDdWM0g1YTIgMiAwIDAwLTIgMnYxNGEyIDIgMCAwMDIgMmgxNGMxLjEgMCAyLS45IDItMnYtN2gtMnY3ek0xNCAzdjJoMy41OWwtOS44MyA5LjgzIDEuNDEgMS40MUwxOSA2LjQxVjEwaDJWM2gtN3oiLz4KPC9zdmc+Cg==);
  --jp-icon-line-form: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxwYXRoIGZpbGw9IndoaXRlIiBkPSJNNS44OCA0LjEyTDEzLjc2IDEybC03Ljg4IDcuODhMOCAyMmwxMC0xMEw4IDJ6Ii8+Cjwvc3ZnPgo=);
  --jp-icon-link: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTMuOSAxMmMwLTEuNzEgMS4zOS0zLjEgMy4xLTMuMWg0VjdIN2MtMi43NiAwLTUgMi4yNC01IDVzMi4yNCA1IDUgNWg0di0xLjlIN2MtMS43MSAwLTMuMS0xLjM5LTMuMS0zLjF6TTggMTNoOHYtMkg4djJ6bTktNmgtNHYxLjloNGMxLjcxIDAgMy4xIDEuMzkgMy4xIDMuMXMtMS4zOSAzLjEtMy4xIDMuMWgtNFYxN2g0YzIuNzYgMCA1LTIuMjQgNS01cy0yLjI0LTUtNS01eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-list: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxwYXRoIGNsYXNzPSJqcC1pY29uMiBqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiM2MTYxNjEiIGQ9Ik0xOSA1djE0SDVWNWgxNG0xLjEtMkgzLjljLS41IDAtLjkuNC0uOS45djE2LjJjMCAuNC40LjkuOS45aDE2LjJjLjQgMCAuOS0uNS45LS45VjMuOWMwLS41LS41LS45LS45LS45ek0xMSA3aDZ2MmgtNlY3em0wIDRoNnYyaC02di0yem0wIDRoNnYyaC02ek03IDdoMnYySDd6bTAgNGgydjJIN3ptMCA0aDJ2Mkg3eiIvPgo8L3N2Zz4K);
  --jp-icon-markdown: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8cGF0aCBjbGFzcz0ianAtaWNvbi1jb250cmFzdDAganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjN0IxRkEyIiBkPSJNNSAxNC45aDEybC02LjEgNnptOS40LTYuOGMwLTEuMy0uMS0yLjktLjEtNC41LS40IDEuNC0uOSAyLjktMS4zIDQuM2wtMS4zIDQuM2gtMkw4LjUgNy45Yy0uNC0xLjMtLjctMi45LTEtNC4zLS4xIDEuNi0uMSAzLjItLjIgNC42TDcgMTIuNEg0LjhsLjctMTFoMy4zTDEwIDVjLjQgMS4yLjcgMi43IDEgMy45LjMtMS4yLjctMi42IDEtMy45bDEuMi0zLjdoMy4zbC42IDExaC0yLjRsLS4zLTQuMnoiLz4KPC9zdmc+Cg==);
  --jp-icon-move-down: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHZpZXdCb3g9IjAgMCAxNCAxNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggY2xhc3M9ImpwLWljb24zIiBkPSJNMTIuNDcxIDcuNTI4OTlDMTIuNzYzMiA3LjIzNjg0IDEyLjc2MzIgNi43NjMxNiAxMi40NzEgNi40NzEwMVY2LjQ3MTAxQzEyLjE3OSA2LjE3OTA1IDExLjcwNTcgNi4xNzg4NCAxMS40MTM1IDYuNDcwNTRMNy43NSAxMC4xMjc1VjEuNzVDNy43NSAxLjMzNTc5IDcuNDE0MjEgMSA3IDFWMUM2LjU4NTc5IDEgNi4yNSAxLjMzNTc5IDYuMjUgMS43NVYxMC4xMjc1TDIuNTk3MjYgNi40NjgyMkMyLjMwMzM4IDYuMTczODEgMS44MjY0MSA2LjE3MzU5IDEuNTMyMjYgNi40Njc3NFY2LjQ2Nzc0QzEuMjM4MyA2Ljc2MTcgMS4yMzgzIDcuMjM4MyAxLjUzMjI2IDcuNTMyMjZMNi4yOTI4OSAxMi4yOTI5QzYuNjgzNDIgMTIuNjgzNCA3LjMxNjU4IDEyLjY4MzQgNy43MDcxMSAxMi4yOTI5TDEyLjQ3MSA3LjUyODk5WiIgZmlsbD0iIzYxNjE2MSIvPgo8L3N2Zz4K);
  --jp-icon-move-up: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHZpZXdCb3g9IjAgMCAxNCAxNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggY2xhc3M9ImpwLWljb24zIiBkPSJNMS41Mjg5OSA2LjQ3MTAxQzEuMjM2ODQgNi43NjMxNiAxLjIzNjg0IDcuMjM2ODQgMS41Mjg5OSA3LjUyODk5VjcuNTI4OTlDMS44MjA5NSA3LjgyMDk1IDIuMjk0MjYgNy44MjExNiAyLjU4NjQ5IDcuNTI5NDZMNi4yNSAzLjg3MjVWMTIuMjVDNi4yNSAxMi42NjQyIDYuNTg1NzkgMTMgNyAxM1YxM0M3LjQxNDIxIDEzIDcuNzUgMTIuNjY0MiA3Ljc1IDEyLjI1VjMuODcyNUwxMS40MDI3IDcuNTMxNzhDMTEuNjk2NiA3LjgyNjE5IDEyLjE3MzYgNy44MjY0MSAxMi40Njc3IDcuNTMyMjZWNy41MzIyNkMxMi43NjE3IDcuMjM4MyAxMi43NjE3IDYuNzYxNyAxMi40Njc3IDYuNDY3NzRMNy43MDcxMSAxLjcwNzExQzcuMzE2NTggMS4zMTY1OCA2LjY4MzQyIDEuMzE2NTggNi4yOTI4OSAxLjcwNzExTDEuNTI4OTkgNi40NzEwMVoiIGZpbGw9IiM2MTYxNjEiLz4KPC9zdmc+Cg==);
  --jp-icon-new-folder: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTIwIDZoLThsLTItMkg0Yy0xLjExIDAtMS45OS44OS0xLjk5IDJMMiAxOGMwIDEuMTEuODkgMiAyIDJoMTZjMS4xMSAwIDItLjg5IDItMlY4YzAtMS4xMS0uODktMi0yLTJ6bS0xIDhoLTN2M2gtMnYtM2gtM3YtMmgzVjloMnYzaDN2MnoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-not-trusted: url(data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI1IDI1Ij4KICAgIDxwYXRoIGNsYXNzPSJqcC1pY29uMiIgc3Ryb2tlPSIjMzMzMzMzIiBzdHJva2Utd2lkdGg9IjIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDMgMykiIGQ9Ik0xLjg2MDk0IDExLjQ0MDlDMC44MjY0NDggOC43NzAyNyAwLjg2Mzc3OSA2LjA1NzY0IDEuMjQ5MDcgNC4xOTkzMkMyLjQ4MjA2IDMuOTMzNDcgNC4wODA2OCAzLjQwMzQ3IDUuNjAxMDIgMi44NDQ5QzcuMjM1NDkgMi4yNDQ0IDguODU2NjYgMS41ODE1IDkuOTg3NiAxLjA5NTM5QzExLjA1OTcgMS41ODM0MSAxMi42MDk0IDIuMjQ0NCAxNC4yMTggMi44NDMzOUMxNS43NTAzIDMuNDEzOTQgMTcuMzk5NSAzLjk1MjU4IDE4Ljc1MzkgNC4yMTM4NUMxOS4xMzY0IDYuMDcxNzcgMTkuMTcwOSA4Ljc3NzIyIDE4LjEzOSAxMS40NDA5QzE3LjAzMDMgMTQuMzAzMiAxNC42NjY4IDE3LjE4NDQgOS45OTk5OSAxOC45MzU0QzUuMzMzMTkgMTcuMTg0NCAyLjk2OTY4IDE0LjMwMzIgMS44NjA5NCAxMS40NDA5WiIvPgogICAgPHBhdGggY2xhc3M9ImpwLWljb24yIiBzdHJva2U9IiMzMzMzMzMiIHN0cm9rZS13aWR0aD0iMiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoOS4zMTU5MiA5LjMyMDMxKSIgZD0iTTcuMzY4NDIgMEwwIDcuMzY0NzkiLz4KICAgIDxwYXRoIGNsYXNzPSJqcC1pY29uMiIgc3Ryb2tlPSIjMzMzMzMzIiBzdHJva2Utd2lkdGg9IjIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDkuMzE1OTIgMTYuNjgzNikgc2NhbGUoMSAtMSkiIGQ9Ik03LjM2ODQyIDBMMCA3LjM2NDc5Ii8+Cjwvc3ZnPgo=);
  --jp-icon-notebook: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8ZyBjbGFzcz0ianAtbm90ZWJvb2staWNvbi1jb2xvciBqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiNFRjZDMDAiPgogICAgPHBhdGggZD0iTTE4LjcgMy4zdjE1LjRIMy4zVjMuM2gxNS40bTEuNS0xLjVIMS44djE4LjNoMTguM2wuMS0xOC4zeiIvPgogICAgPHBhdGggZD0iTTE2LjUgMTYuNWwtNS40LTQuMy01LjYgNC4zdi0xMWgxMXoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-numbering: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIiIGhlaWdodD0iMjIiIHZpZXdCb3g9IjAgMCAyOCAyOCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KCTxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CgkJPHBhdGggZD0iTTQgMTlINlYxOS41SDVWMjAuNUg2VjIxSDRWMjJIN1YxOEg0VjE5Wk01IDEwSDZWNkg0VjdINVYxMFpNNCAxM0g1LjhMNCAxNS4xVjE2SDdWMTVINS4yTDcgMTIuOVYxMkg0VjEzWk05IDdWOUgyM1Y3SDlaTTkgMjFIMjNWMTlIOVYyMVpNOSAxNUgyM1YxM0g5VjE1WiIvPgoJPC9nPgo8L3N2Zz4K);
  --jp-icon-offline-bolt: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjE2Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTEyIDIuMDJjLTUuNTEgMC05Ljk4IDQuNDctOS45OCA5Ljk4czQuNDcgOS45OCA5Ljk4IDkuOTggOS45OC00LjQ3IDkuOTgtOS45OFMxNy41MSAyLjAyIDEyIDIuMDJ6TTExLjQ4IDIwdi02LjI2SDhMMTMgNHY2LjI2aDMuMzVMMTEuNDggMjB6Ii8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-palette: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTE4IDEzVjIwSDRWNkg5LjAyQzkuMDcgNS4yOSA5LjI0IDQuNjIgOS41IDRINEMyLjkgNCAyIDQuOSAyIDZWMjBDMiAyMS4xIDIuOSAyMiA0IDIySDE4QzE5LjEgMjIgMjAgMjEuMSAyMCAyMFYxNUwxOCAxM1pNMTkuMyA4Ljg5QzE5Ljc0IDguMTkgMjAgNy4zOCAyMCA2LjVDMjAgNC4wMSAxNy45OSAyIDE1LjUgMkMxMy4wMSAyIDExIDQuMDEgMTEgNi41QzExIDguOTkgMTMuMDEgMTEgMTUuNDkgMTFDMTYuMzcgMTEgMTcuMTkgMTAuNzQgMTcuODggMTAuM0wyMSAxMy40MkwyMi40MiAxMkwxOS4zIDguODlaTTE1LjUgOUMxNC4xMiA5IDEzIDcuODggMTMgNi41QzEzIDUuMTIgMTQuMTIgNCAxNS41IDRDMTYuODggNCAxOCA1LjEyIDE4IDYuNUMxOCA3Ljg4IDE2Ljg4IDkgMTUuNSA5WiIvPgogICAgPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00IDZIOS4wMTg5NEM5LjAwNjM5IDYuMTY1MDIgOSA2LjMzMTc2IDkgNi41QzkgOC44MTU3NyAxMC4yMTEgMTAuODQ4NyAxMi4wMzQzIDEySDlWMTRIMTZWMTIuOTgxMUMxNi41NzAzIDEyLjkzNzcgMTcuMTIgMTIuODIwNyAxNy42Mzk2IDEyLjYzOTZMMTggMTNWMjBINFY2Wk04IDhINlYxMEg4VjhaTTYgMTJIOFYxNEg2VjEyWk04IDE2SDZWMThIOFYxNlpNOSAxNkgxNlYxOEg5VjE2WiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-paste: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTE5IDJoLTQuMThDMTQuNC44NCAxMy4zIDAgMTIgMGMtMS4zIDAtMi40Ljg0LTIuODIgMkg1Yy0xLjEgMC0yIC45LTIgMnYxNmMwIDEuMS45IDIgMiAyaDE0YzEuMSAwIDItLjkgMi0yVjRjMC0xLjEtLjktMi0yLTJ6bS03IDBjLjU1IDAgMSAuNDUgMSAxcy0uNDUgMS0xIDEtMS0uNDUtMS0xIC40NS0xIDEtMXptNyAxOEg1VjRoMnYzaDEwVjRoMnYxNnoiLz4KICAgIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-pdf: url(data:image/svg+xml;base64,PHN2ZwogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMiAyMiIgd2lkdGg9IjE2Ij4KICAgIDxwYXRoIHRyYW5zZm9ybT0icm90YXRlKDQ1KSIgY2xhc3M9ImpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iI0ZGMkEyQSIKICAgICAgIGQ9Im0gMjIuMzQ0MzY5LC0zLjAxNjM2NDIgaCA1LjYzODYwNCB2IDEuNTc5MjQzMyBoIC0zLjU0OTIyNyB2IDEuNTA4NjkyOTkgaCAzLjMzNzU3NiBWIDEuNjUwODE1NCBoIC0zLjMzNzU3NiB2IDMuNDM1MjYxMyBoIC0yLjA4OTM3NyB6IG0gLTcuMTM2NDQ0LDEuNTc5MjQzMyB2IDQuOTQzOTU0MyBoIDAuNzQ4OTIgcSAxLjI4MDc2MSwwIDEuOTUzNzAzLC0wLjYzNDk1MzUgMC42NzgzNjksLTAuNjM0OTUzNSAwLjY3ODM2OSwtMS44NDUxNjQxIDAsLTEuMjA0NzgzNTUgLTAuNjcyOTQyLC0xLjgzNDMxMDExIC0wLjY3Mjk0MiwtMC42Mjk1MjY1OSAtMS45NTkxMywtMC42Mjk1MjY1OSB6IG0gLTIuMDg5Mzc3LC0xLjU3OTI0MzMgaCAyLjIwMzM0MyBxIDEuODQ1MTY0LDAgMi43NDYwMzksMC4yNjU5MjA3IDAuOTA2MzAxLDAuMjYwNDkzNyAxLjU1MjEwOCwwLjg5MDAyMDMgMC41Njk4MywwLjU0ODEyMjMgMC44NDY2MDUsMS4yNjQ0ODAwNiAwLjI3Njc3NCwwLjcxNjM1NzgxIDAuMjc2Nzc0LDEuNjIyNjU4OTQgMCwwLjkxNzE1NTEgLTAuMjc2Nzc0LDEuNjM4OTM5OSAtMC4yNzY3NzUsMC43MTYzNTc4IC0wLjg0NjYwNSwxLjI2NDQ4IC0wLjY1MTIzNCwwLjYyOTUyNjYgLTEuNTYyOTYyLDAuODk1NDQ3MyAtMC45MTE3MjgsMC4yNjA0OTM3IC0yLjczNTE4NSwwLjI2MDQ5MzcgaCAtMi4yMDMzNDMgeiBtIC04LjE0NTg1NjUsMCBoIDMuNDY3ODIzIHEgMS41NDY2ODE2LDAgMi4zNzE1Nzg1LDAuNjg5MjIzIDAuODMwMzI0LDAuNjgzNzk2MSAwLjgzMDMyNCwxLjk1MzcwMzE0IDAsMS4yNzUzMzM5NyAtMC44MzAzMjQsMS45NjQ1NTcwNiBRIDkuOTg3MTk2MSwyLjI3NDkxNSA4LjQ0MDUxNDUsMi4yNzQ5MTUgSCA3LjA2MjA2ODQgViA1LjA4NjA3NjcgSCA0Ljk3MjY5MTUgWiBtIDIuMDg5Mzc2OSwxLjUxNDExOTkgdiAyLjI2MzAzOTQzIGggMS4xNTU5NDEgcSAwLjYwNzgxODgsMCAwLjkzODg2MjksLTAuMjkzMDU1NDcgMC4zMzEwNDQxLC0wLjI5ODQ4MjQxIDAuMzMxMDQ0MSwtMC44NDExNzc3MiAwLC0wLjU0MjY5NTMxIC0wLjMzMTA0NDEsLTAuODM1NzUwNzQgLTAuMzMxMDQ0MSwtMC4yOTMwNTU1IC0wLjkzODg2MjksLTAuMjkzMDU1NSB6IgovPgo8L3N2Zz4K);
  --jp-icon-python: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iLTEwIC0xMCAxMzEuMTYxMzYxNjk0MzM1OTQgMTMyLjM4ODk5OTkzODk2NDg0Ij4KICA8cGF0aCBjbGFzcz0ianAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjMzA2OTk4IiBkPSJNIDU0LjkxODc4NSw5LjE5Mjc0MjFlLTQgQyA1MC4zMzUxMzIsMC4wMjIyMTcyNyA0NS45NTc4NDYsMC40MTMxMzY5NyA0Mi4xMDYyODUsMS4wOTQ2NjkzIDMwLjc2MDA2OSwzLjA5OTE3MzEgMjguNzAwMDM2LDcuMjk0NzcxNCAyOC43MDAwMzUsMTUuMDMyMTY5IHYgMTAuMjE4NzUgaCAyNi44MTI1IHYgMy40MDYyNSBoIC0yNi44MTI1IC0xMC4wNjI1IGMgLTcuNzkyNDU5LDAgLTE0LjYxNTc1ODgsNC42ODM3MTcgLTE2Ljc0OTk5OTgsMTMuNTkzNzUgLTIuNDYxODE5OTgsMTAuMjEyOTY2IC0yLjU3MTAxNTA4LDE2LjU4NjAyMyAwLDI3LjI1IDEuOTA1OTI4Myw3LjkzNzg1MiA2LjQ1NzU0MzIsMTMuNTkzNzQ4IDE0LjI0OTk5OTgsMTMuNTkzNzUgaCA5LjIxODc1IHYgLTEyLjI1IGMgMCwtOC44NDk5MDIgNy42NTcxNDQsLTE2LjY1NjI0OCAxNi43NSwtMTYuNjU2MjUgaCAyNi43ODEyNSBjIDcuNDU0OTUxLDAgMTMuNDA2MjUzLC02LjEzODE2NCAxMy40MDYyNSwtMTMuNjI1IHYgLTI1LjUzMTI1IGMgMCwtNy4yNjYzMzg2IC02LjEyOTk4LC0xMi43MjQ3NzcxIC0xMy40MDYyNSwtMTMuOTM3NDk5NyBDIDY0LjI4MTU0OCwwLjMyNzk0Mzk3IDU5LjUwMjQzOCwtMC4wMjAzNzkwMyA1NC45MTg3ODUsOS4xOTI3NDIxZS00IFogbSAtMTQuNSw4LjIxODc1MDEyNTc5IGMgMi43Njk1NDcsMCA1LjAzMTI1LDIuMjk4NjQ1NiA1LjAzMTI1LDUuMTI0OTk5NiAtMmUtNiwyLjgxNjMzNiAtMi4yNjE3MDMsNS4wOTM3NSAtNS4wMzEyNSw1LjA5Mzc1IC0yLjc3OTQ3NiwtMWUtNiAtNS4wMzEyNSwtMi4yNzc0MTUgLTUuMDMxMjUsLTUuMDkzNzUgLTEwZS03LC0yLjgyNjM1MyAyLjI1MTc3NCwtNS4xMjQ5OTk2IDUuMDMxMjUsLTUuMTI0OTk5NiB6Ii8+CiAgPHBhdGggY2xhc3M9ImpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iI2ZmZDQzYiIgZD0ibSA4NS42Mzc1MzUsMjguNjU3MTY5IHYgMTEuOTA2MjUgYyAwLDkuMjMwNzU1IC03LjgyNTg5NSwxNi45OTk5OTkgLTE2Ljc1LDE3IGggLTI2Ljc4MTI1IGMgLTcuMzM1ODMzLDAgLTEzLjQwNjI0OSw2LjI3ODQ4MyAtMTMuNDA2MjUsMTMuNjI1IHYgMjUuNTMxMjQ3IGMgMCw3LjI2NjM0NCA2LjMxODU4OCwxMS41NDAzMjQgMTMuNDA2MjUsMTMuNjI1MDA0IDguNDg3MzMxLDIuNDk1NjEgMTYuNjI2MjM3LDIuOTQ2NjMgMjYuNzgxMjUsMCA2Ljc1MDE1NSwtMS45NTQzOSAxMy40MDYyNTMsLTUuODg3NjEgMTMuNDA2MjUsLTEzLjYyNTAwNCBWIDg2LjUwMDkxOSBoIC0yNi43ODEyNSB2IC0zLjQwNjI1IGggMjYuNzgxMjUgMTMuNDA2MjU0IGMgNy43OTI0NjEsMCAxMC42OTYyNTEsLTUuNDM1NDA4IDEzLjQwNjI0MSwtMTMuNTkzNzUgMi43OTkzMywtOC4zOTg4ODYgMi42ODAyMiwtMTYuNDc1Nzc2IDAsLTI3LjI1IC0xLjkyNTc4LC03Ljc1NzQ0MSAtNS42MDM4NywtMTMuNTkzNzUgLTEzLjQwNjI0MSwtMTMuNTkzNzUgeiBtIC0xNS4wNjI1LDY0LjY1NjI1IGMgMi43Nzk0NzgsM2UtNiA1LjAzMTI1LDIuMjc3NDE3IDUuMDMxMjUsNS4wOTM3NDcgLTJlLTYsMi44MjYzNTQgLTIuMjUxNzc1LDUuMTI1MDA0IC01LjAzMTI1LDUuMTI1MDA0IC0yLjc2OTU1LDAgLTUuMDMxMjUsLTIuMjk4NjUgLTUuMDMxMjUsLTUuMTI1MDA0IDJlLTYsLTIuODE2MzMgMi4yNjE2OTcsLTUuMDkzNzQ3IDUuMDMxMjUsLTUuMDkzNzQ3IHoiLz4KPC9zdmc+Cg==);
  --jp-icon-r-kernel: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8cGF0aCBjbGFzcz0ianAtaWNvbi1jb250cmFzdDMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjMjE5NkYzIiBkPSJNNC40IDIuNWMxLjItLjEgMi45LS4zIDQuOS0uMyAyLjUgMCA0LjEuNCA1LjIgMS4zIDEgLjcgMS41IDEuOSAxLjUgMy41IDAgMi0xLjQgMy41LTIuOSA0LjEgMS4yLjQgMS43IDEuNiAyLjIgMyAuNiAxLjkgMSAzLjkgMS4zIDQuNmgtMy44Yy0uMy0uNC0uOC0xLjctMS4yLTMuN3MtMS4yLTIuNi0yLjYtMi42aC0uOXY2LjRINC40VjIuNXptMy43IDYuOWgxLjRjMS45IDAgMi45LS45IDIuOS0yLjNzLTEtMi4zLTIuOC0yLjNjLS43IDAtMS4zIDAtMS42LjJ2NC41aC4xdi0uMXoiLz4KPC9zdmc+Cg==);
  --jp-icon-react: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMTUwIDE1MCA1NDEuOSAyOTUuMyI+CiAgPGcgY2xhc3M9ImpwLWljb24tYnJhbmQyIGpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iIzYxREFGQiI+CiAgICA8cGF0aCBkPSJNNjY2LjMgMjk2LjVjMC0zMi41LTQwLjctNjMuMy0xMDMuMS04Mi40IDE0LjQtNjMuNiA4LTExNC4yLTIwLjItMTMwLjQtNi41LTMuOC0xNC4xLTUuNi0yMi40LTUuNnYyMi4zYzQuNiAwIDguMy45IDExLjQgMi42IDEzLjYgNy44IDE5LjUgMzcuNSAxNC45IDc1LjctMS4xIDkuNC0yLjkgMTkuMy01LjEgMjkuNC0xOS42LTQuOC00MS04LjUtNjMuNS0xMC45LTEzLjUtMTguNS0yNy41LTM1LjMtNDEuNi01MCAzMi42LTMwLjMgNjMuMi00Ni45IDg0LTQ2LjlWNzhjLTI3LjUgMC02My41IDE5LjYtOTkuOSA1My42LTM2LjQtMzMuOC03Mi40LTUzLjItOTkuOS01My4ydjIyLjNjMjAuNyAwIDUxLjQgMTYuNSA4NCA0Ni42LTE0IDE0LjctMjggMzEuNC00MS4zIDQ5LjktMjIuNiAyLjQtNDQgNi4xLTYzLjYgMTEtMi4zLTEwLTQtMTkuNy01LjItMjktNC43LTM4LjIgMS4xLTY3LjkgMTQuNi03NS44IDMtMS44IDYuOS0yLjYgMTEuNS0yLjZWNzguNWMtOC40IDAtMTYgMS44LTIyLjYgNS42LTI4LjEgMTYuMi0zNC40IDY2LjctMTkuOSAxMzAuMS02Mi4yIDE5LjItMTAyLjcgNDkuOS0xMDIuNyA4Mi4zIDAgMzIuNSA0MC43IDYzLjMgMTAzLjEgODIuNC0xNC40IDYzLjYtOCAxMTQuMiAyMC4yIDEzMC40IDYuNSAzLjggMTQuMSA1LjYgMjIuNSA1LjYgMjcuNSAwIDYzLjUtMTkuNiA5OS45LTUzLjYgMzYuNCAzMy44IDcyLjQgNTMuMiA5OS45IDUzLjIgOC40IDAgMTYtMS44IDIyLjYtNS42IDI4LjEtMTYuMiAzNC40LTY2LjcgMTkuOS0xMzAuMSA2Mi0xOS4xIDEwMi41LTQ5LjkgMTAyLjUtODIuM3ptLTEzMC4yLTY2LjdjLTMuNyAxMi45LTguMyAyNi4yLTEzLjUgMzkuNS00LjEtOC04LjQtMTYtMTMuMS0yNC00LjYtOC05LjUtMTUuOC0xNC40LTIzLjQgMTQuMiAyLjEgMjcuOSA0LjcgNDEgNy45em0tNDUuOCAxMDYuNWMtNy44IDEzLjUtMTUuOCAyNi4zLTI0LjEgMzguMi0xNC45IDEuMy0zMCAyLTQ1LjIgMi0xNS4xIDAtMzAuMi0uNy00NS0xLjktOC4zLTExLjktMTYuNC0yNC42LTI0LjItMzgtNy42LTEzLjEtMTQuNS0yNi40LTIwLjgtMzkuOCA2LjItMTMuNCAxMy4yLTI2LjggMjAuNy0zOS45IDcuOC0xMy41IDE1LjgtMjYuMyAyNC4xLTM4LjIgMTQuOS0xLjMgMzAtMiA0NS4yLTIgMTUuMSAwIDMwLjIuNyA0NSAxLjkgOC4zIDExLjkgMTYuNCAyNC42IDI0LjIgMzggNy42IDEzLjEgMTQuNSAyNi40IDIwLjggMzkuOC02LjMgMTMuNC0xMy4yIDI2LjgtMjAuNyAzOS45em0zMi4zLTEzYzUuNCAxMy40IDEwIDI2LjggMTMuOCAzOS44LTEzLjEgMy4yLTI2LjkgNS45LTQxLjIgOCA0LjktNy43IDkuOC0xNS42IDE0LjQtMjMuNyA0LjYtOCA4LjktMTYuMSAxMy0yNC4xek00MjEuMiA0MzBjLTkuMy05LjYtMTguNi0yMC4zLTI3LjgtMzIgOSAuNCAxOC4yLjcgMjcuNS43IDkuNCAwIDE4LjctLjIgMjcuOC0uNy05IDExLjctMTguMyAyMi40LTI3LjUgMzJ6bS03NC40LTU4LjljLTE0LjItMi4xLTI3LjktNC43LTQxLTcuOSAzLjctMTIuOSA4LjMtMjYuMiAxMy41LTM5LjUgNC4xIDggOC40IDE2IDEzLjEgMjQgNC43IDggOS41IDE1LjggMTQuNCAyMy40ek00MjAuNyAxNjNjOS4zIDkuNiAxOC42IDIwLjMgMjcuOCAzMi05LS40LTE4LjItLjctMjcuNS0uNy05LjQgMC0xOC43LjItMjcuOC43IDktMTEuNyAxOC4zLTIyLjQgMjcuNS0zMnptLTc0IDU4LjljLTQuOSA3LjctOS44IDE1LjYtMTQuNCAyMy43LTQuNiA4LTguOSAxNi0xMyAyNC01LjQtMTMuNC0xMC0yNi44LTEzLjgtMzkuOCAxMy4xLTMuMSAyNi45LTUuOCA0MS4yLTcuOXptLTkwLjUgMTI1LjJjLTM1LjQtMTUuMS01OC4zLTM0LjktNTguMy01MC42IDAtMTUuNyAyMi45LTM1LjYgNTguMy01MC42IDguNi0zLjcgMTgtNyAyNy43LTEwLjEgNS43IDE5LjYgMTMuMiA0MCAyMi41IDYwLjktOS4yIDIwLjgtMTYuNiA0MS4xLTIyLjIgNjAuNi05LjktMy4xLTE5LjMtNi41LTI4LTEwLjJ6TTMxMCA0OTBjLTEzLjYtNy44LTE5LjUtMzcuNS0xNC45LTc1LjcgMS4xLTkuNCAyLjktMTkuMyA1LjEtMjkuNCAxOS42IDQuOCA0MSA4LjUgNjMuNSAxMC45IDEzLjUgMTguNSAyNy41IDM1LjMgNDEuNiA1MC0zMi42IDMwLjMtNjMuMiA0Ni45LTg0IDQ2LjktNC41LS4xLTguMy0xLTExLjMtMi43em0yMzcuMi03Ni4yYzQuNyAzOC4yLTEuMSA2Ny45LTE0LjYgNzUuOC0zIDEuOC02LjkgMi42LTExLjUgMi42LTIwLjcgMC01MS40LTE2LjUtODQtNDYuNiAxNC0xNC43IDI4LTMxLjQgNDEuMy00OS45IDIyLjYtMi40IDQ0LTYuMSA2My42LTExIDIuMyAxMC4xIDQuMSAxOS44IDUuMiAyOS4xem0zOC41LTY2LjdjLTguNiAzLjctMTggNy0yNy43IDEwLjEtNS43LTE5LjYtMTMuMi00MC0yMi41LTYwLjkgOS4yLTIwLjggMTYuNi00MS4xIDIyLjItNjAuNiA5LjkgMy4xIDE5LjMgNi41IDI4LjEgMTAuMiAzNS40IDE1LjEgNTguMyAzNC45IDU4LjMgNTAuNi0uMSAxNS43LTIzIDM1LjYtNTguNCA1MC42ek0zMjAuOCA3OC40eiIvPgogICAgPGNpcmNsZSBjeD0iNDIwLjkiIGN5PSIyOTYuNSIgcj0iNDUuNyIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-redo: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjE2Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgICA8cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTE4LjQgMTAuNkMxNi41NSA4Ljk5IDE0LjE1IDggMTEuNSA4Yy00LjY1IDAtOC41OCAzLjAzLTkuOTYgNy4yMkwzLjkgMTZjMS4wNS0zLjE5IDQuMDUtNS41IDcuNi01LjUgMS45NSAwIDMuNzMuNzIgNS4xMiAxLjg4TDEzIDE2aDlWN2wtMy42IDMuNnoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-refresh: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTkgMTMuNWMtMi40OSAwLTQuNS0yLjAxLTQuNS00LjVTNi41MSA0LjUgOSA0LjVjMS4yNCAwIDIuMzYuNTIgMy4xNyAxLjMzTDEwIDhoNVYzbC0xLjc2IDEuNzZDMTIuMTUgMy42OCAxMC42NiAzIDkgMyA1LjY5IDMgMy4wMSA1LjY5IDMuMDEgOVM1LjY5IDE1IDkgMTVjMi45NyAwIDUuNDMtMi4xNiA1LjktNWgtMS41MmMtLjQ2IDItMi4yNCAzLjUtNC4zOCAzLjV6Ii8+CiAgICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-regex: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIwIDIwIj4KICA8ZyBjbGFzcz0ianAtaWNvbjIiIGZpbGw9IiM0MTQxNDEiPgogICAgPHJlY3QgeD0iMiIgeT0iMiIgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2Ii8+CiAgPC9nPgoKICA8ZyBjbGFzcz0ianAtaWNvbi1hY2NlbnQyIiBmaWxsPSIjRkZGIj4KICAgIDxjaXJjbGUgY2xhc3M9InN0MiIgY3g9IjUuNSIgY3k9IjE0LjUiIHI9IjEuNSIvPgogICAgPHJlY3QgeD0iMTIiIHk9IjQiIGNsYXNzPSJzdDIiIHdpZHRoPSIxIiBoZWlnaHQ9IjgiLz4KICAgIDxyZWN0IHg9IjguNSIgeT0iNy41IiB0cmFuc2Zvcm09Im1hdHJpeCgwLjg2NiAtMC41IDAuNSAwLjg2NiAtMi4zMjU1IDcuMzIxOSkiIGNsYXNzPSJzdDIiIHdpZHRoPSI4IiBoZWlnaHQ9IjEiLz4KICAgIDxyZWN0IHg9IjEyIiB5PSI0IiB0cmFuc2Zvcm09Im1hdHJpeCgwLjUgLTAuODY2IDAuODY2IDAuNSAtMC42Nzc5IDE0LjgyNTIpIiBjbGFzcz0ic3QyIiB3aWR0aD0iMSIgaGVpZ2h0PSI4Ii8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-run: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTggNXYxNGwxMS03eiIvPgogICAgPC9nPgo8L3N2Zz4K);
  --jp-icon-running: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDUxMiA1MTIiPgogIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICA8cGF0aCBkPSJNMjU2IDhDMTE5IDggOCAxMTkgOCAyNTZzMTExIDI0OCAyNDggMjQ4IDI0OC0xMTEgMjQ4LTI0OFMzOTMgOCAyNTYgOHptOTYgMzI4YzAgOC44LTcuMiAxNi0xNiAxNkgxNzZjLTguOCAwLTE2LTcuMi0xNi0xNlYxNzZjMC04LjggNy4yLTE2IDE2LTE2aDE2MGM4LjggMCAxNiA3LjIgMTYgMTZ2MTYweiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-save: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTE3IDNINWMtMS4xMSAwLTIgLjktMiAydjE0YzAgMS4xLjg5IDIgMiAyaDE0YzEuMSAwIDItLjkgMi0yVjdsLTQtNHptLTUgMTZjLTEuNjYgMC0zLTEuMzQtMy0zczEuMzQtMyAzLTMgMyAxLjM0IDMgMy0xLjM0IDMtMyAzem0zLTEwSDVWNWgxMHY0eiIvPgogICAgPC9nPgo8L3N2Zz4K);
  --jp-icon-search: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTggMTgiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTEyLjEsMTAuOWgtMC43bC0wLjItMC4yYzAuOC0wLjksMS4zLTIuMiwxLjMtMy41YzAtMy0yLjQtNS40LTUuNC01LjRTMS44LDQuMiwxLjgsNy4xczIuNCw1LjQsNS40LDUuNCBjMS4zLDAsMi41LTAuNSwzLjUtMS4zbDAuMiwwLjJ2MC43bDQuMSw0LjFsMS4yLTEuMkwxMi4xLDEwLjl6IE03LjEsMTAuOWMtMi4xLDAtMy43LTEuNy0zLjctMy43czEuNy0zLjcsMy43LTMuN3MzLjcsMS43LDMuNywzLjcgUzkuMiwxMC45LDcuMSwxMC45eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-settings: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8cGF0aCBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBkPSJNMTkuNDMgMTIuOThjLjA0LS4zMi4wNy0uNjQuMDctLjk4cy0uMDMtLjY2LS4wNy0uOThsMi4xMS0xLjY1Yy4xOS0uMTUuMjQtLjQyLjEyLS42NGwtMi0zLjQ2Yy0uMTItLjIyLS4zOS0uMy0uNjEtLjIybC0yLjQ5IDFjLS41Mi0uNC0xLjA4LS43My0xLjY5LS45OGwtLjM4LTIuNjVBLjQ4OC40ODggMCAwMDE0IDJoLTRjLS4yNSAwLS40Ni4xOC0uNDkuNDJsLS4zOCAyLjY1Yy0uNjEuMjUtMS4xNy41OS0xLjY5Ljk4bC0yLjQ5LTFjLS4yMy0uMDktLjQ5IDAtLjYxLjIybC0yIDMuNDZjLS4xMy4yMi0uMDcuNDkuMTIuNjRsMi4xMSAxLjY1Yy0uMDQuMzItLjA3LjY1LS4wNy45OHMuMDMuNjYuMDcuOThsLTIuMTEgMS42NWMtLjE5LjE1LS4yNC40Mi0uMTIuNjRsMiAzLjQ2Yy4xMi4yMi4zOS4zLjYxLjIybDIuNDktMWMuNTIuNCAxLjA4LjczIDEuNjkuOThsLjM4IDIuNjVjLjAzLjI0LjI0LjQyLjQ5LjQyaDRjLjI1IDAgLjQ2LS4xOC40OS0uNDJsLjM4LTIuNjVjLjYxLS4yNSAxLjE3LS41OSAxLjY5LS45OGwyLjQ5IDFjLjIzLjA5LjQ5IDAgLjYxLS4yMmwyLTMuNDZjLjEyLS4yMi4wNy0uNDktLjEyLS42NGwtMi4xMS0xLjY1ek0xMiAxNS41Yy0xLjkzIDAtMy41LTEuNTctMy41LTMuNXMxLjU3LTMuNSAzLjUtMy41IDMuNSAxLjU3IDMuNSAzLjUtMS41NyAzLjUtMy41IDMuNXoiLz4KPC9zdmc+Cg==);
  --jp-icon-share: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIHZpZXdCb3g9IjAgMCAyNCAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTSAxOCAyIEMgMTYuMzU0OTkgMiAxNSAzLjM1NDk5MDQgMTUgNSBDIDE1IDUuMTkwOTUyOSAxNS4wMjE3OTEgNS4zNzcxMjI0IDE1LjA1NjY0MSA1LjU1ODU5MzggTCA3LjkyMTg3NSA5LjcyMDcwMzEgQyA3LjM5ODUzOTkgOS4yNzc4NTM5IDYuNzMyMDc3MSA5IDYgOSBDIDQuMzU0OTkwNCA5IDMgMTAuMzU0OTkgMyAxMiBDIDMgMTMuNjQ1MDEgNC4zNTQ5OTA0IDE1IDYgMTUgQyA2LjczMjA3NzEgMTUgNy4zOTg1Mzk5IDE0LjcyMjE0NiA3LjkyMTg3NSAxNC4yNzkyOTcgTCAxNS4wNTY2NDEgMTguNDM5NDUzIEMgMTUuMDIxNTU1IDE4LjYyMTUxNCAxNSAxOC44MDgzODYgMTUgMTkgQyAxNSAyMC42NDUwMSAxNi4zNTQ5OSAyMiAxOCAyMiBDIDE5LjY0NTAxIDIyIDIxIDIwLjY0NTAxIDIxIDE5IEMgMjEgMTcuMzU0OTkgMTkuNjQ1MDEgMTYgMTggMTYgQyAxNy4yNjc0OCAxNiAxNi42MDE1OTMgMTYuMjc5MzI4IDE2LjA3ODEyNSAxNi43MjI2NTYgTCA4Ljk0MzM1OTQgMTIuNTU4NTk0IEMgOC45NzgyMDk1IDEyLjM3NzEyMiA5IDEyLjE5MDk1MyA5IDEyIEMgOSAxMS44MDkwNDcgOC45NzgyMDk1IDExLjYyMjg3OCA4Ljk0MzM1OTQgMTEuNDQxNDA2IEwgMTYuMDc4MTI1IDcuMjc5Mjk2OSBDIDE2LjYwMTQ2IDcuNzIyMTQ2MSAxNy4yNjc5MjMgOCAxOCA4IEMgMTkuNjQ1MDEgOCAyMSA2LjY0NTAwOTYgMjEgNSBDIDIxIDMuMzU0OTkwNCAxOS42NDUwMSAyIDE4IDIgeiBNIDE4IDQgQyAxOC41NjQxMjkgNCAxOSA0LjQzNTg3MDYgMTkgNSBDIDE5IDUuNTY0MTI5NCAxOC41NjQxMjkgNiAxOCA2IEMgMTcuNDM1ODcxIDYgMTcgNS41NjQxMjk0IDE3IDUgQyAxNyA0LjQzNTg3MDYgMTcuNDM1ODcxIDQgMTggNCB6IE0gNiAxMSBDIDYuNTY0MTI5NCAxMSA3IDExLjQzNTg3MSA3IDEyIEMgNyAxMi41NjQxMjkgNi41NjQxMjk0IDEzIDYgMTMgQyA1LjQzNTg3MDYgMTMgNSAxMi41NjQxMjkgNSAxMiBDIDUgMTEuNDM1ODcxIDUuNDM1ODcwNiAxMSA2IDExIHogTSAxOCAxOCBDIDE4LjU2NDEyOSAxOCAxOSAxOC40MzU4NzEgMTkgMTkgQyAxOSAxOS41NjQxMjkgMTguNTY0MTI5IDIwIDE4IDIwIEMgMTcuNDM1ODcxIDIwIDE3IDE5LjU2NDEyOSAxNyAxOSBDIDE3IDE4LjQzNTg3MSAxNy40MzU4NzEgMTggMTggMTggeiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-spreadsheet: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8cGF0aCBjbGFzcz0ianAtaWNvbi1jb250cmFzdDEganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNENBRjUwIiBkPSJNMi4yIDIuMnYxNy42aDE3LjZWMi4ySDIuMnptMTUuNCA3LjdoLTUuNVY0LjRoNS41djUuNXpNOS45IDQuNHY1LjVINC40VjQuNGg1LjV6bS01LjUgNy43aDUuNXY1LjVINC40di01LjV6bTcuNyA1LjV2LTUuNWg1LjV2NS41aC01LjV6Ii8+Cjwvc3ZnPgo=);
  --jp-icon-stop: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTAgMGgyNHYyNEgweiIgZmlsbD0ibm9uZSIvPgogICAgICAgIDxwYXRoIGQ9Ik02IDZoMTJ2MTJINnoiLz4KICAgIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-tab: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTIxIDNIM2MtMS4xIDAtMiAuOS0yIDJ2MTRjMCAxLjEuOSAyIDIgMmgxOGMxLjEgMCAyLS45IDItMlY1YzAtMS4xLS45LTItMi0yem0wIDE2SDNWNWgxMHY0aDh2MTB6Ii8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-table-rows: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTAgMGgyNHYyNEgweiIgZmlsbD0ibm9uZSIvPgogICAgICAgIDxwYXRoIGQ9Ik0yMSw4SDNWNGgxOFY4eiBNMjEsMTBIM3Y0aDE4VjEweiBNMjEsMTZIM3Y0aDE4VjE2eiIvPgogICAgPC9nPgo8L3N2Zz4K);
  --jp-icon-tag: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjgiIGhlaWdodD0iMjgiIHZpZXdCb3g9IjAgMCA0MyAyOCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KCTxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CgkJPHBhdGggZD0iTTI4LjgzMzIgMTIuMzM0TDMyLjk5OTggMTYuNTAwN0wzNy4xNjY1IDEyLjMzNEgyOC44MzMyWiIvPgoJCTxwYXRoIGQ9Ik0xNi4yMDk1IDIxLjYxMDRDMTUuNjg3MyAyMi4xMjk5IDE0Ljg0NDMgMjIuMTI5OSAxNC4zMjQ4IDIxLjYxMDRMNi45ODI5IDE0LjcyNDVDNi41NzI0IDE0LjMzOTQgNi4wODMxMyAxMy42MDk4IDYuMDQ3ODYgMTMuMDQ4MkM1Ljk1MzQ3IDExLjUyODggNi4wMjAwMiA4LjYxOTQ0IDYuMDY2MjEgNy4wNzY5NUM2LjA4MjgxIDYuNTE0NzcgNi41NTU0OCA2LjA0MzQ3IDcuMTE4MDQgNi4wMzA1NUM5LjA4ODYzIDUuOTg0NzMgMTMuMjYzOCA1LjkzNTc5IDEzLjY1MTggNi4zMjQyNUwyMS43MzY5IDEzLjYzOUMyMi4yNTYgMTQuMTU4NSAyMS43ODUxIDE1LjQ3MjQgMjEuMjYyIDE1Ljk5NDZMMTYuMjA5NSAyMS42MTA0Wk05Ljc3NTg1IDguMjY1QzkuMzM1NTEgNy44MjU2NiA4LjYyMzUxIDcuODI1NjYgOC4xODI4IDguMjY1QzcuNzQzNDYgOC43MDU3MSA3Ljc0MzQ2IDkuNDE3MzMgOC4xODI4IDkuODU2NjdDOC42MjM4MiAxMC4yOTY0IDkuMzM1ODIgMTAuMjk2NCA5Ljc3NTg1IDkuODU2NjdDMTAuMjE1NiA5LjQxNzMzIDEwLjIxNTYgOC43MDUzMyA5Ljc3NTg1IDguMjY1WiIvPgoJPC9nPgo8L3N2Zz4K);
  --jp-icon-terminal: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0IiA+CiAgICA8cmVjdCBjbGFzcz0ianAtdGVybWluYWwtaWNvbi1iYWNrZ3JvdW5kLWNvbG9yIGpwLWljb24tc2VsZWN0YWJsZSIgd2lkdGg9IjIwIiBoZWlnaHQ9IjIwIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyIDIpIiBmaWxsPSIjMzMzMzMzIi8+CiAgICA8cGF0aCBjbGFzcz0ianAtdGVybWluYWwtaWNvbi1jb2xvciBqcC1pY29uLXNlbGVjdGFibGUtaW52ZXJzZSIgZD0iTTUuMDU2NjQgOC43NjE3MkM1LjA1NjY0IDguNTk3NjYgNS4wMzEyNSA4LjQ1MzEyIDQuOTgwNDcgOC4zMjgxMkM0LjkzMzU5IDguMTk5MjIgNC44NTU0NyA4LjA4MjAzIDQuNzQ2MDkgNy45NzY1NkM0LjY0MDYyIDcuODcxMDkgNC41IDcuNzc1MzkgNC4zMjQyMiA3LjY4OTQ1QzQuMTUyMzQgNy41OTk2MSAzLjk0MzM2IDcuNTExNzIgMy42OTcyNyA3LjQyNTc4QzMuMzAyNzMgNy4yODUxNiAyLjk0MzM2IDcuMTM2NzIgMi42MTkxNCA2Ljk4MDQ3QzIuMjk0OTIgNi44MjQyMiAyLjAxNzU4IDYuNjQyNTggMS43ODcxMSA2LjQzNTU1QzEuNTYwNTUgNi4yMjg1MiAxLjM4NDc3IDUuOTg4MjggMS4yNTk3NyA1LjcxNDg0QzEuMTM0NzcgNS40Mzc1IDEuMDcyMjcgNS4xMDkzOCAxLjA3MjI3IDQuNzMwNDdDMS4wNzIyNyA0LjM5ODQ0IDEuMTI4OTEgNC4wOTU3IDEuMjQyMTkgMy44MjIyN0MxLjM1NTQ3IDMuNTQ0OTIgMS41MTU2MiAzLjMwNDY5IDEuNzIyNjYgMy4xMDE1NkMxLjkyOTY5IDIuODk4NDQgMi4xNzk2OSAyLjczNDM3IDIuNDcyNjYgMi42MDkzOEMyLjc2NTYyIDIuNDg0MzggMy4wOTE4IDIuNDA0MyAzLjQ1MTE3IDIuMzY5MTRWMS4xMDkzOEg0LjM4ODY3VjIuMzgwODZDNC43NDAyMyAyLjQyNzczIDUuMDU2NjQgMi41MjM0NCA1LjMzNzg5IDIuNjY3OTdDNS42MTkxNCAyLjgxMjUgNS44NTc0MiAzLjAwMTk1IDYuMDUyNzMgMy4yMzYzM0M2LjI1MTk1IDMuNDY2OCA2LjQwNDMgMy43NDAyMyA2LjUwOTc3IDQuMDU2NjRDNi42MTkxNCA0LjM2OTE0IDYuNjczODMgNC43MjA3IDYuNjczODMgNS4xMTEzM0g1LjA0NDkyQzUuMDQ0OTIgNC42Mzg2NyA0LjkzNzUgNC4yODEyNSA0LjcyMjY2IDQuMDM5MDZDNC41MDc4MSAzLjc5Mjk3IDQuMjE2OCAzLjY2OTkyIDMuODQ5NjEgMy42Njk5MkMzLjY1MDM5IDMuNjY5OTIgMy40NzY1NiAzLjY5NzI3IDMuMzI4MTIgMy43NTE5NUMzLjE4MzU5IDMuODAyNzMgMy4wNjQ0NSAzLjg3Njk1IDIuOTcwNyAzLjk3NDYxQzIuODc2OTUgNC4wNjgzNiAyLjgwNjY0IDQuMTc5NjkgMi43NTk3NyA0LjMwODU5QzIuNzE2OCA0LjQzNzUgMi42OTUzMSA0LjU3ODEyIDIuNjk1MzEgNC43MzA0N0MyLjY5NTMxIDQuODgyODEgMi43MTY4IDUuMDE5NTMgMi43NTk3NyA1LjE0MDYyQzIuODA2NjQgNS4yNTc4MSAyLjg4MjgxIDUuMzY3MTkgMi45ODgyOCA1LjQ2ODc1QzMuMDk3NjYgNS41NzAzMSAzLjI0MDIzIDUuNjY3OTcgMy40MTYwMiA1Ljc2MTcyQzMuNTkxOCA1Ljg1MTU2IDMuODEwNTUgNS45NDMzNiA0LjA3MjI3IDYuMDM3MTFDNC40NjY4IDYuMTg1NTUgNC44MjQyMiA2LjMzOTg0IDUuMTQ0NTMgNi41QzUuNDY0ODQgNi42NTYyNSA1LjczODI4IDYuODM5ODQgNS45NjQ4NCA3LjA1MDc4QzYuMTk1MzEgNy4yNTc4MSA2LjM3MTA5IDcuNSA2LjQ5MjE5IDcuNzc3MzRDNi42MTcxOSA4LjA1MDc4IDYuNjc5NjkgOC4zNzUgNi42Nzk2OSA4Ljc1QzYuNjc5NjkgOS4wOTM3NSA2LjYyMzA1IDkuNDA0MyA2LjUwOTc3IDkuNjgxNjRDNi4zOTY0OCA5Ljk1NTA4IDYuMjM0MzggMTAuMTkxNCA2LjAyMzQ0IDEwLjM5MDZDNS44MTI1IDEwLjU4OTggNS41NTg1OSAxMC43NSA1LjI2MTcyIDEwLjg3MTFDNC45NjQ4NCAxMC45ODgzIDQuNjMyODEgMTEuMDY0NSA0LjI2NTYyIDExLjA5OTZWMTIuMjQ4SDMuMzMzOThWMTEuMDk5NkMzLjAwMTk1IDExLjA2ODQgMi42Nzk2OSAxMC45OTYxIDIuMzY3MTkgMTAuODgyOEMyLjA1NDY5IDEwLjc2NTYgMS43NzczNCAxMC41OTc3IDEuNTM1MTYgMTAuMzc4OUMxLjI5Njg4IDEwLjE2MDIgMS4xMDU0NyA5Ljg4NDc3IDAuOTYwOTM4IDkuNTUyNzNDMC44MTY0MDYgOS4yMTY4IDAuNzQ0MTQxIDguODE0NDUgMC43NDQxNDEgOC4zNDU3SDIuMzc4OTFDMi4zNzg5MSA4LjYyNjk1IDIuNDE5OTIgOC44NjMyOCAyLjUwMTk1IDkuMDU0NjlDMi41ODM5OCA5LjI0MjE5IDIuNjg5NDUgOS4zOTI1OCAyLjgxODM2IDkuNTA1ODZDMi45NTExNyA5LjYxNTIzIDMuMTAxNTYgOS42OTMzNiAzLjI2OTUzIDkuNzQwMjNDMy40Mzc1IDkuNzg3MTEgMy42MDkzOCA5LjgxMDU1IDMuNzg1MTYgOS44MTA1NUM0LjIwMzEyIDkuODEwNTUgNC41MTk1MyA5LjcxMjg5IDQuNzM0MzggOS41MTc1OEM0Ljk0OTIyIDkuMzIyMjcgNS4wNTY2NCA5LjA3MDMxIDUuMDU2NjQgOC43NjE3MlpNMTMuNDE4IDEyLjI3MTVIOC4wNzQyMlYxMUgxMy40MThWMTIuMjcxNVoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDMuOTUyNjQgNikiIGZpbGw9IndoaXRlIi8+Cjwvc3ZnPgo=);
  --jp-icon-text-editor: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8cGF0aCBjbGFzcz0ianAtdGV4dC1lZGl0b3ItaWNvbi1jb2xvciBqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiM2MTYxNjEiIGQ9Ik0xNSAxNUgzdjJoMTJ2LTJ6bTAtOEgzdjJoMTJWN3pNMyAxM2gxOHYtMkgzdjJ6bTAgOGgxOHYtMkgzdjJ6TTMgM3YyaDE4VjNIM3oiLz4KPC9zdmc+Cg==);
  --jp-icon-toc: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIj4KICAgIDxwYXRoIGQ9Ik03LDVIMjFWN0g3VjVNNywxM1YxMUgyMVYxM0g3TTQsNC41QTEuNSwxLjUgMCAwLDEgNS41LDZBMS41LDEuNSAwIDAsMSA0LDcuNUExLjUsMS41IDAgMCwxIDIuNSw2QTEuNSwxLjUgMCAwLDEgNCw0LjVNNCwxMC41QTEuNSwxLjUgMCAwLDEgNS41LDEyQTEuNSwxLjUgMCAwLDEgNCwxMy41QTEuNSwxLjUgMCAwLDEgMi41LDEyQTEuNSwxLjUgMCAwLDEgNCwxMC41TTcsMTlWMTdIMjFWMTlIN000LDE2LjVBMS41LDEuNSAwIDAsMSA1LjUsMThBMS41LDEuNSAwIDAsMSA0LDE5LjVBMS41LDEuNSAwIDAsMSAyLjUsMThBMS41LDEuNSAwIDAsMSA0LDE2LjVaIiAvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-tree-view: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTAgMGgyNHYyNEgweiIgZmlsbD0ibm9uZSIvPgogICAgICAgIDxwYXRoIGQ9Ik0yMiAxMVYzaC03djNIOVYzSDJ2OGg3VjhoMnYxMGg0djNoN3YtOGgtN3YzaC0yVjhoMnYzeiIvPgogICAgPC9nPgo8L3N2Zz4K);
  --jp-icon-trusted: url(data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI1Ij4KICAgIDxwYXRoIGNsYXNzPSJqcC1pY29uMiIgc3Ryb2tlPSIjMzMzMzMzIiBzdHJva2Utd2lkdGg9IjIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIgMykiIGQ9Ik0xLjg2MDk0IDExLjQ0MDlDMC44MjY0NDggOC43NzAyNyAwLjg2Mzc3OSA2LjA1NzY0IDEuMjQ5MDcgNC4xOTkzMkMyLjQ4MjA2IDMuOTMzNDcgNC4wODA2OCAzLjQwMzQ3IDUuNjAxMDIgMi44NDQ5QzcuMjM1NDkgMi4yNDQ0IDguODU2NjYgMS41ODE1IDkuOTg3NiAxLjA5NTM5QzExLjA1OTcgMS41ODM0MSAxMi42MDk0IDIuMjQ0NCAxNC4yMTggMi44NDMzOUMxNS43NTAzIDMuNDEzOTQgMTcuMzk5NSAzLjk1MjU4IDE4Ljc1MzkgNC4yMTM4NUMxOS4xMzY0IDYuMDcxNzcgMTkuMTcwOSA4Ljc3NzIyIDE4LjEzOSAxMS40NDA5QzE3LjAzMDMgMTQuMzAzMiAxNC42NjY4IDE3LjE4NDQgOS45OTk5OSAxOC45MzU0QzUuMzMzMiAxNy4xODQ0IDIuOTY5NjggMTQuMzAzMiAxLjg2MDk0IDExLjQ0MDlaIi8+CiAgICA8cGF0aCBjbGFzcz0ianAtaWNvbjIiIGZpbGw9IiMzMzMzMzMiIHN0cm9rZT0iIzMzMzMzMyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoOCA5Ljg2NzE5KSIgZD0iTTIuODYwMTUgNC44NjUzNUwwLjcyNjU0OSAyLjk5OTU5TDAgMy42MzA0NUwyLjg2MDE1IDYuMTMxNTdMOCAwLjYzMDg3Mkw3LjI3ODU3IDBMMi44NjAxNSA0Ljg2NTM1WiIvPgo8L3N2Zz4K);
  --jp-icon-undo: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTEyLjUgOGMtMi42NSAwLTUuMDUuOTktNi45IDIuNkwyIDd2OWg5bC0zLjYyLTMuNjJjMS4zOS0xLjE2IDMuMTYtMS44OCA1LjEyLTEuODggMy41NCAwIDYuNTUgMi4zMSA3LjYgNS41bDIuMzctLjc4QzIxLjA4IDExLjAzIDE3LjE1IDggMTIuNSA4eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-user: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIHZpZXdCb3g9IjAgMCAyNCAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTE2IDdhNCA0IDAgMTEtOCAwIDQgNCAwIDAxOCAwek0xMiAxNGE3IDcgMCAwMC03IDdoMTRhNyA3IDAgMDAtNy03eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-users: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDM2IDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogPGcgY2xhc3M9ImpwLWljb24zIiB0cmFuc2Zvcm09Im1hdHJpeCgxLjczMjcgMCAwIDEuNzMyNyAtMy42MjgyIC4wOTk1NzcpIiBmaWxsPSIjNjE2MTYxIj4KICA8cGF0aCB0cmFuc2Zvcm09Im1hdHJpeCgxLjUsMCwwLDEuNSwwLC02KSIgZD0ibTEyLjE4NiA3LjUwOThjLTEuMDUzNSAwLTEuOTc1NyAwLjU2NjUtMi40Nzg1IDEuNDEwMiAwLjc1MDYxIDAuMzEyNzcgMS4zOTc0IDAuODI2NDggMS44NzMgMS40NzI3aDMuNDg2M2MwLTEuNTkyLTEuMjg4OS0yLjg4MjgtMi44ODA5LTIuODgyOHoiLz4KICA8cGF0aCBkPSJtMjAuNDY1IDIuMzg5NWEyLjE4ODUgMi4xODg1IDAgMCAxLTIuMTg4NCAyLjE4ODUgMi4xODg1IDIuMTg4NSAwIDAgMS0yLjE4ODUtMi4xODg1IDIuMTg4NSAyLjE4ODUgMCAwIDEgMi4xODg1LTIuMTg4NSAyLjE4ODUgMi4xODg1IDAgMCAxIDIuMTg4NCAyLjE4ODV6Ii8+CiAgPHBhdGggdHJhbnNmb3JtPSJtYXRyaXgoMS41LDAsMCwxLjUsMCwtNikiIGQ9Im0zLjU4OTggOC40MjE5Yy0xLjExMjYgMC0yLjAxMzcgMC45MDExMS0yLjAxMzcgMi4wMTM3aDIuODE0NWMwLjI2Nzk3LTAuMzczMDkgMC41OTA3LTAuNzA0MzUgMC45NTg5OC0wLjk3ODUyLTAuMzQ0MzMtMC42MTY4OC0xLjAwMzEtMS4wMzUyLTEuNzU5OC0xLjAzNTJ6Ii8+CiAgPHBhdGggZD0ibTYuOTE1NCA0LjYyM2ExLjUyOTQgMS41Mjk0IDAgMCAxLTEuNTI5NCAxLjUyOTQgMS41Mjk0IDEuNTI5NCAwIDAgMS0xLjUyOTQtMS41Mjk0IDEuNTI5NCAxLjUyOTQgMCAwIDEgMS41Mjk0LTEuNTI5NCAxLjUyOTQgMS41Mjk0IDAgMCAxIDEuNTI5NCAxLjUyOTR6Ii8+CiAgPHBhdGggZD0ibTYuMTM1IDEzLjUzNWMwLTMuMjM5MiAyLjYyNTktNS44NjUgNS44NjUtNS44NjUgMy4yMzkyIDAgNS44NjUgMi42MjU5IDUuODY1IDUuODY1eiIvPgogIDxjaXJjbGUgY3g9IjEyIiBjeT0iMy43Njg1IiByPSIyLjk2ODUiLz4KIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-vega: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8ZyBjbGFzcz0ianAtaWNvbjEganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjMjEyMTIxIj4KICAgIDxwYXRoIGQ9Ik0xMC42IDUuNGwyLjItMy4ySDIuMnY3LjNsNC02LjZ6Ii8+CiAgICA8cGF0aCBkPSJNMTUuOCAyLjJsLTQuNCA2LjZMNyA2LjNsLTQuOCA4djUuNWgxNy42VjIuMmgtNHptLTcgMTUuNEg1LjV2LTQuNGgzLjN2NC40em00LjQgMEg5LjhWOS44aDMuNHY3Ljh6bTQuNCAwaC0zLjRWNi41aDMuNHYxMS4xeiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-word: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIwIDIwIj4KIDxnIGNsYXNzPSJqcC1pY29uMiIgZmlsbD0iIzQxNDE0MSI+CiAgPHJlY3QgeD0iMiIgeT0iMiIgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2Ii8+CiA8L2c+CiA8ZyBjbGFzcz0ianAtaWNvbi1hY2NlbnQyIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSguNDMgLjA0MDEpIiBmaWxsPSIjZmZmIj4KICA8cGF0aCBkPSJtNC4xNCA4Ljc2cTAuMDY4Mi0xLjg5IDIuNDItMS44OSAxLjE2IDAgMS42OCAwLjQyIDAuNTY3IDAuNDEgMC41NjcgMS4xNnYzLjQ3cTAgMC40NjIgMC41MTQgMC40NjIgMC4xMDMgMCAwLjItMC4wMjMxdjAuNzE0cS0wLjM5OSAwLjEwMy0wLjY1MSAwLjEwMy0wLjQ1MiAwLTAuNjkzLTAuMjItMC4yMzEtMC4yLTAuMjg0LTAuNjYyLTAuOTU2IDAuODcyLTIgMC44NzItMC45MDMgMC0xLjQ3LTAuNDcyLTAuNTI1LTAuNDcyLTAuNTI1LTEuMjYgMC0wLjI2MiAwLjA0NTItMC40NzIgMC4wNTY3LTAuMjIgMC4xMTYtMC4zNzggMC4wNjgyLTAuMTY4IDAuMjMxLTAuMzA0IDAuMTU4LTAuMTQ3IDAuMjYyLTAuMjQyIDAuMTE2LTAuMDkxNCAwLjM2OC0wLjE2OCAwLjI2Mi0wLjA5MTQgMC4zOTktMC4xMjYgMC4xMzYtMC4wNDUyIDAuNDcyLTAuMTAzIDAuMzM2LTAuMDU3OCAwLjUwNC0wLjA3OTggMC4xNTgtMC4wMjMxIDAuNTY3LTAuMDc5OCAwLjU1Ni0wLjA2ODIgMC43NzctMC4yMjEgMC4yMi0wLjE1MiAwLjIyLTAuNDQxdi0wLjI1MnEwLTAuNDMtMC4zNTctMC42NjItMC4zMzYtMC4yMzEtMC45NzYtMC4yMzEtMC42NjIgMC0wLjk5OCAwLjI2Mi0wLjMzNiAwLjI1Mi0wLjM5OSAwLjc5OHptMS44OSAzLjY4cTAuNzg4IDAgMS4yNi0wLjQxIDAuNTA0LTAuNDIgMC41MDQtMC45MDN2LTEuMDVxLTAuMjg0IDAuMTM2LTAuODYxIDAuMjMxLTAuNTY3IDAuMDkxNC0wLjk4NyAwLjE1OC0wLjQyIDAuMDY4Mi0wLjc2NiAwLjMyNi0wLjMzNiAwLjI1Mi0wLjMzNiAwLjcwNHQwLjMwNCAwLjcwNCAwLjg2MSAwLjI1MnoiIHN0cm9rZS13aWR0aD0iMS4wNSIvPgogIDxwYXRoIGQ9Im0xMCA0LjU2aDAuOTQ1djMuMTVxMC42NTEtMC45NzYgMS44OS0wLjk3NiAxLjE2IDAgMS44OSAwLjg0IDAuNjgyIDAuODQgMC42ODIgMi4zMSAwIDEuNDctMC43MDQgMi40Mi0wLjcwNCAwLjg4Mi0xLjg5IDAuODgyLTEuMjYgMC0xLjg5LTEuMDJ2MC43NjZoLTAuODV6bTIuNjIgMy4wNHEtMC43NDYgMC0xLjE2IDAuNjQtMC40NTIgMC42My0wLjQ1MiAxLjY4IDAgMS4wNSAwLjQ1MiAxLjY4dDEuMTYgMC42M3EwLjc3NyAwIDEuMjYtMC42MyAwLjQ5NC0wLjY0IDAuNDk0LTEuNjggMC0xLjA1LTAuNDcyLTEuNjgtMC40NjItMC42NC0xLjI2LTAuNjR6IiBzdHJva2Utd2lkdGg9IjEuMDUiLz4KICA8cGF0aCBkPSJtMi43MyAxNS44IDEzLjYgMC4wMDgxYzAuMDA2OSAwIDAtMi42IDAtMi42IDAtMC4wMDc4LTEuMTUgMC0xLjE1IDAtMC4wMDY5IDAtMC4wMDgzIDEuNS0wLjAwODMgMS41LTJlLTMgLTAuMDAxNC0xMS4zLTAuMDAxNC0xMS4zLTAuMDAxNGwtMC4wMDU5Mi0xLjVjMC0wLjAwNzgtMS4xNyAwLjAwMTMtMS4xNyAwLjAwMTN6IiBzdHJva2Utd2lkdGg9Ii45NzUiLz4KIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-yaml: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8ZyBjbGFzcz0ianAtaWNvbi1jb250cmFzdDIganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjRDgxQjYwIj4KICAgIDxwYXRoIGQ9Ik03LjIgMTguNnYtNS40TDMgNS42aDMuM2wxLjQgMy4xYy4zLjkuNiAxLjYgMSAyLjUuMy0uOC42LTEuNiAxLTIuNWwxLjQtMy4xaDMuNGwtNC40IDcuNnY1LjVsLTIuOS0uMXoiLz4KICAgIDxjaXJjbGUgY2xhc3M9InN0MCIgY3g9IjE3LjYiIGN5PSIxNi41IiByPSIyLjEiLz4KICAgIDxjaXJjbGUgY2xhc3M9InN0MCIgY3g9IjE3LjYiIGN5PSIxMSIgcj0iMi4xIi8+CiAgPC9nPgo8L3N2Zz4K);
}

/* Icon CSS class declarations */

.jp-AddAboveIcon {
  background-image: var(--jp-icon-add-above);
}

.jp-AddBelowIcon {
  background-image: var(--jp-icon-add-below);
}

.jp-AddIcon {
  background-image: var(--jp-icon-add);
}

.jp-BellIcon {
  background-image: var(--jp-icon-bell);
}

.jp-BugDotIcon {
  background-image: var(--jp-icon-bug-dot);
}

.jp-BugIcon {
  background-image: var(--jp-icon-bug);
}

.jp-BuildIcon {
  background-image: var(--jp-icon-build);
}

.jp-CaretDownEmptyIcon {
  background-image: var(--jp-icon-caret-down-empty);
}

.jp-CaretDownEmptyThinIcon {
  background-image: var(--jp-icon-caret-down-empty-thin);
}

.jp-CaretDownIcon {
  background-image: var(--jp-icon-caret-down);
}

.jp-CaretLeftIcon {
  background-image: var(--jp-icon-caret-left);
}

.jp-CaretRightIcon {
  background-image: var(--jp-icon-caret-right);
}

.jp-CaretUpEmptyThinIcon {
  background-image: var(--jp-icon-caret-up-empty-thin);
}

.jp-CaretUpIcon {
  background-image: var(--jp-icon-caret-up);
}

.jp-CaseSensitiveIcon {
  background-image: var(--jp-icon-case-sensitive);
}

.jp-CheckIcon {
  background-image: var(--jp-icon-check);
}

.jp-CircleEmptyIcon {
  background-image: var(--jp-icon-circle-empty);
}

.jp-CircleIcon {
  background-image: var(--jp-icon-circle);
}

.jp-ClearIcon {
  background-image: var(--jp-icon-clear);
}

.jp-CloseIcon {
  background-image: var(--jp-icon-close);
}

.jp-CodeCheckIcon {
  background-image: var(--jp-icon-code-check);
}

.jp-CodeIcon {
  background-image: var(--jp-icon-code);
}

.jp-CollapseAllIcon {
  background-image: var(--jp-icon-collapse-all);
}

.jp-ConsoleIcon {
  background-image: var(--jp-icon-console);
}

.jp-CopyIcon {
  background-image: var(--jp-icon-copy);
}

.jp-CopyrightIcon {
  background-image: var(--jp-icon-copyright);
}

.jp-CutIcon {
  background-image: var(--jp-icon-cut);
}

.jp-DeleteIcon {
  background-image: var(--jp-icon-delete);
}

.jp-DownloadIcon {
  background-image: var(--jp-icon-download);
}

.jp-DuplicateIcon {
  background-image: var(--jp-icon-duplicate);
}

.jp-EditIcon {
  background-image: var(--jp-icon-edit);
}

.jp-EllipsesIcon {
  background-image: var(--jp-icon-ellipses);
}

.jp-ErrorIcon {
  background-image: var(--jp-icon-error);
}

.jp-ExpandAllIcon {
  background-image: var(--jp-icon-expand-all);
}

.jp-ExtensionIcon {
  background-image: var(--jp-icon-extension);
}

.jp-FastForwardIcon {
  background-image: var(--jp-icon-fast-forward);
}

.jp-FileIcon {
  background-image: var(--jp-icon-file);
}

.jp-FileUploadIcon {
  background-image: var(--jp-icon-file-upload);
}

.jp-FilterDotIcon {
  background-image: var(--jp-icon-filter-dot);
}

.jp-FilterIcon {
  background-image: var(--jp-icon-filter);
}

.jp-FilterListIcon {
  background-image: var(--jp-icon-filter-list);
}

.jp-FolderFavoriteIcon {
  background-image: var(--jp-icon-folder-favorite);
}

.jp-FolderIcon {
  background-image: var(--jp-icon-folder);
}

.jp-HomeIcon {
  background-image: var(--jp-icon-home);
}

.jp-Html5Icon {
  background-image: var(--jp-icon-html5);
}

.jp-ImageIcon {
  background-image: var(--jp-icon-image);
}

.jp-InfoIcon {
  background-image: var(--jp-icon-info);
}

.jp-InspectorIcon {
  background-image: var(--jp-icon-inspector);
}

.jp-JsonIcon {
  background-image: var(--jp-icon-json);
}

.jp-JuliaIcon {
  background-image: var(--jp-icon-julia);
}

.jp-JupyterFaviconIcon {
  background-image: var(--jp-icon-jupyter-favicon);
}

.jp-JupyterIcon {
  background-image: var(--jp-icon-jupyter);
}

.jp-JupyterlabWordmarkIcon {
  background-image: var(--jp-icon-jupyterlab-wordmark);
}

.jp-KernelIcon {
  background-image: var(--jp-icon-kernel);
}

.jp-KeyboardIcon {
  background-image: var(--jp-icon-keyboard);
}

.jp-LaunchIcon {
  background-image: var(--jp-icon-launch);
}

.jp-LauncherIcon {
  background-image: var(--jp-icon-launcher);
}

.jp-LineFormIcon {
  background-image: var(--jp-icon-line-form);
}

.jp-LinkIcon {
  background-image: var(--jp-icon-link);
}

.jp-ListIcon {
  background-image: var(--jp-icon-list);
}

.jp-MarkdownIcon {
  background-image: var(--jp-icon-markdown);
}

.jp-MoveDownIcon {
  background-image: var(--jp-icon-move-down);
}

.jp-MoveUpIcon {
  background-image: var(--jp-icon-move-up);
}

.jp-NewFolderIcon {
  background-image: var(--jp-icon-new-folder);
}

.jp-NotTrustedIcon {
  background-image: var(--jp-icon-not-trusted);
}

.jp-NotebookIcon {
  background-image: var(--jp-icon-notebook);
}

.jp-NumberingIcon {
  background-image: var(--jp-icon-numbering);
}

.jp-OfflineBoltIcon {
  background-image: var(--jp-icon-offline-bolt);
}

.jp-PaletteIcon {
  background-image: var(--jp-icon-palette);
}

.jp-PasteIcon {
  background-image: var(--jp-icon-paste);
}

.jp-PdfIcon {
  background-image: var(--jp-icon-pdf);
}

.jp-PythonIcon {
  background-image: var(--jp-icon-python);
}

.jp-RKernelIcon {
  background-image: var(--jp-icon-r-kernel);
}

.jp-ReactIcon {
  background-image: var(--jp-icon-react);
}

.jp-RedoIcon {
  background-image: var(--jp-icon-redo);
}

.jp-RefreshIcon {
  background-image: var(--jp-icon-refresh);
}

.jp-RegexIcon {
  background-image: var(--jp-icon-regex);
}

.jp-RunIcon {
  background-image: var(--jp-icon-run);
}

.jp-RunningIcon {
  background-image: var(--jp-icon-running);
}

.jp-SaveIcon {
  background-image: var(--jp-icon-save);
}

.jp-SearchIcon {
  background-image: var(--jp-icon-search);
}

.jp-SettingsIcon {
  background-image: var(--jp-icon-settings);
}

.jp-ShareIcon {
  background-image: var(--jp-icon-share);
}

.jp-SpreadsheetIcon {
  background-image: var(--jp-icon-spreadsheet);
}

.jp-StopIcon {
  background-image: var(--jp-icon-stop);
}

.jp-TabIcon {
  background-image: var(--jp-icon-tab);
}

.jp-TableRowsIcon {
  background-image: var(--jp-icon-table-rows);
}

.jp-TagIcon {
  background-image: var(--jp-icon-tag);
}

.jp-TerminalIcon {
  background-image: var(--jp-icon-terminal);
}

.jp-TextEditorIcon {
  background-image: var(--jp-icon-text-editor);
}

.jp-TocIcon {
  background-image: var(--jp-icon-toc);
}

.jp-TreeViewIcon {
  background-image: var(--jp-icon-tree-view);
}

.jp-TrustedIcon {
  background-image: var(--jp-icon-trusted);
}

.jp-UndoIcon {
  background-image: var(--jp-icon-undo);
}

.jp-UserIcon {
  background-image: var(--jp-icon-user);
}

.jp-UsersIcon {
  background-image: var(--jp-icon-users);
}

.jp-VegaIcon {
  background-image: var(--jp-icon-vega);
}

.jp-WordIcon {
  background-image: var(--jp-icon-word);
}

.jp-YamlIcon {
  background-image: var(--jp-icon-yaml);
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/**
 * (DEPRECATED) Support for consuming icons as CSS background images
 */

.jp-Icon,
.jp-MaterialIcon {
  background-position: center;
  background-repeat: no-repeat;
  background-size: 16px;
  min-width: 16px;
  min-height: 16px;
}

.jp-Icon-cover {
  background-position: center;
  background-repeat: no-repeat;
  background-size: cover;
}

/**
 * (DEPRECATED) Support for specific CSS icon sizes
 */

.jp-Icon-16 {
  background-size: 16px;
  min-width: 16px;
  min-height: 16px;
}

.jp-Icon-18 {
  background-size: 18px;
  min-width: 18px;
  min-height: 18px;
}

.jp-Icon-20 {
  background-size: 20px;
  min-width: 20px;
  min-height: 20px;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.lm-TabBar .lm-TabBar-addButton {
  align-items: center;
  display: flex;
  padding: 4px;
  padding-bottom: 5px;
  margin-right: 1px;
  background-color: var(--jp-layout-color2);
}

.lm-TabBar .lm-TabBar-addButton:hover {
  background-color: var(--jp-layout-color1);
}

.lm-DockPanel-tabBar .lm-TabBar-tab {
  width: var(--jp-private-horizontal-tab-width);
}

.lm-DockPanel-tabBar .lm-TabBar-content {
  flex: unset;
}

.lm-DockPanel-tabBar[data-orientation='horizontal'] {
  flex: 1 1 auto;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/**
 * Support for icons as inline SVG HTMLElements
 */

/* recolor the primary elements of an icon */
.jp-icon0[fill] {
  fill: var(--jp-inverse-layout-color0);
}

.jp-icon1[fill] {
  fill: var(--jp-inverse-layout-color1);
}

.jp-icon2[fill] {
  fill: var(--jp-inverse-layout-color2);
}

.jp-icon3[fill] {
  fill: var(--jp-inverse-layout-color3);
}

.jp-icon4[fill] {
  fill: var(--jp-inverse-layout-color4);
}

.jp-icon0[stroke] {
  stroke: var(--jp-inverse-layout-color0);
}

.jp-icon1[stroke] {
  stroke: var(--jp-inverse-layout-color1);
}

.jp-icon2[stroke] {
  stroke: var(--jp-inverse-layout-color2);
}

.jp-icon3[stroke] {
  stroke: var(--jp-inverse-layout-color3);
}

.jp-icon4[stroke] {
  stroke: var(--jp-inverse-layout-color4);
}

/* recolor the accent elements of an icon */
.jp-icon-accent0[fill] {
  fill: var(--jp-layout-color0);
}

.jp-icon-accent1[fill] {
  fill: var(--jp-layout-color1);
}

.jp-icon-accent2[fill] {
  fill: var(--jp-layout-color2);
}

.jp-icon-accent3[fill] {
  fill: var(--jp-layout-color3);
}

.jp-icon-accent4[fill] {
  fill: var(--jp-layout-color4);
}

.jp-icon-accent0[stroke] {
  stroke: var(--jp-layout-color0);
}

.jp-icon-accent1[stroke] {
  stroke: var(--jp-layout-color1);
}

.jp-icon-accent2[stroke] {
  stroke: var(--jp-layout-color2);
}

.jp-icon-accent3[stroke] {
  stroke: var(--jp-layout-color3);
}

.jp-icon-accent4[stroke] {
  stroke: var(--jp-layout-color4);
}

/* set the color of an icon to transparent */
.jp-icon-none[fill] {
  fill: none;
}

.jp-icon-none[stroke] {
  stroke: none;
}

/* brand icon colors. Same for light and dark */
.jp-icon-brand0[fill] {
  fill: var(--jp-brand-color0);
}

.jp-icon-brand1[fill] {
  fill: var(--jp-brand-color1);
}

.jp-icon-brand2[fill] {
  fill: var(--jp-brand-color2);
}

.jp-icon-brand3[fill] {
  fill: var(--jp-brand-color3);
}

.jp-icon-brand4[fill] {
  fill: var(--jp-brand-color4);
}

.jp-icon-brand0[stroke] {
  stroke: var(--jp-brand-color0);
}

.jp-icon-brand1[stroke] {
  stroke: var(--jp-brand-color1);
}

.jp-icon-brand2[stroke] {
  stroke: var(--jp-brand-color2);
}

.jp-icon-brand3[stroke] {
  stroke: var(--jp-brand-color3);
}

.jp-icon-brand4[stroke] {
  stroke: var(--jp-brand-color4);
}

/* warn icon colors. Same for light and dark */
.jp-icon-warn0[fill] {
  fill: var(--jp-warn-color0);
}

.jp-icon-warn1[fill] {
  fill: var(--jp-warn-color1);
}

.jp-icon-warn2[fill] {
  fill: var(--jp-warn-color2);
}

.jp-icon-warn3[fill] {
  fill: var(--jp-warn-color3);
}

.jp-icon-warn0[stroke] {
  stroke: var(--jp-warn-color0);
}

.jp-icon-warn1[stroke] {
  stroke: var(--jp-warn-color1);
}

.jp-icon-warn2[stroke] {
  stroke: var(--jp-warn-color2);
}

.jp-icon-warn3[stroke] {
  stroke: var(--jp-warn-color3);
}

/* icon colors that contrast well with each other and most backgrounds */
.jp-icon-contrast0[fill] {
  fill: var(--jp-icon-contrast-color0);
}

.jp-icon-contrast1[fill] {
  fill: var(--jp-icon-contrast-color1);
}

.jp-icon-contrast2[fill] {
  fill: var(--jp-icon-contrast-color2);
}

.jp-icon-contrast3[fill] {
  fill: var(--jp-icon-contrast-color3);
}

.jp-icon-contrast0[stroke] {
  stroke: var(--jp-icon-contrast-color0);
}

.jp-icon-contrast1[stroke] {
  stroke: var(--jp-icon-contrast-color1);
}

.jp-icon-contrast2[stroke] {
  stroke: var(--jp-icon-contrast-color2);
}

.jp-icon-contrast3[stroke] {
  stroke: var(--jp-icon-contrast-color3);
}

.jp-icon-dot[fill] {
  fill: var(--jp-warn-color0);
}

.jp-jupyter-icon-color[fill] {
  fill: var(--jp-jupyter-icon-color, var(--jp-warn-color0));
}

.jp-notebook-icon-color[fill] {
  fill: var(--jp-notebook-icon-color, var(--jp-warn-color0));
}

.jp-json-icon-color[fill] {
  fill: var(--jp-json-icon-color, var(--jp-warn-color1));
}

.jp-console-icon-color[fill] {
  fill: var(--jp-console-icon-color, white);
}

.jp-console-icon-background-color[fill] {
  fill: var(--jp-console-icon-background-color, var(--jp-brand-color1));
}

.jp-terminal-icon-color[fill] {
  fill: var(--jp-terminal-icon-color, var(--jp-layout-color2));
}

.jp-terminal-icon-background-color[fill] {
  fill: var(
    --jp-terminal-icon-background-color,
    var(--jp-inverse-layout-color2)
  );
}

.jp-text-editor-icon-color[fill] {
  fill: var(--jp-text-editor-icon-color, var(--jp-inverse-layout-color3));
}

.jp-inspector-icon-color[fill] {
  fill: var(--jp-inspector-icon-color, var(--jp-inverse-layout-color3));
}

/* CSS for icons in selected filebrowser listing items */
.jp-DirListing-item.jp-mod-selected .jp-icon-selectable[fill] {
  fill: #fff;
}

.jp-DirListing-item.jp-mod-selected .jp-icon-selectable-inverse[fill] {
  fill: var(--jp-brand-color1);
}

/* stylelint-disable selector-max-class, selector-max-compound-selectors */

/**
* TODO: come up with non css-hack solution for showing the busy icon on top
*  of the close icon
* CSS for complex behavior of close icon of tabs in the main area tabbar
*/
.lm-DockPanel-tabBar
  .lm-TabBar-tab.lm-mod-closable.jp-mod-dirty
  > .lm-TabBar-tabCloseIcon
  > :not(:hover)
  > .jp-icon3[fill] {
  fill: none;
}

.lm-DockPanel-tabBar
  .lm-TabBar-tab.lm-mod-closable.jp-mod-dirty
  > .lm-TabBar-tabCloseIcon
  > :not(:hover)
  > .jp-icon-busy[fill] {
  fill: var(--jp-inverse-layout-color3);
}

/* stylelint-enable selector-max-class, selector-max-compound-selectors */

/* CSS for icons in status bar */
#jp-main-statusbar .jp-mod-selected .jp-icon-selectable[fill] {
  fill: #fff;
}

#jp-main-statusbar .jp-mod-selected .jp-icon-selectable-inverse[fill] {
  fill: var(--jp-brand-color1);
}

/* special handling for splash icon CSS. While the theme CSS reloads during
   splash, the splash icon can loose theming. To prevent that, we set a
   default for its color variable */
:root {
  --jp-warn-color0: var(--md-orange-700);
}

/* not sure what to do with this one, used in filebrowser listing */
.jp-DragIcon {
  margin-right: 4px;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/**
 * Support for alt colors for icons as inline SVG HTMLElements
 */

/* alt recolor the primary elements of an icon */
.jp-icon-alt .jp-icon0[fill] {
  fill: var(--jp-layout-color0);
}

.jp-icon-alt .jp-icon1[fill] {
  fill: var(--jp-layout-color1);
}

.jp-icon-alt .jp-icon2[fill] {
  fill: var(--jp-layout-color2);
}

.jp-icon-alt .jp-icon3[fill] {
  fill: var(--jp-layout-color3);
}

.jp-icon-alt .jp-icon4[fill] {
  fill: var(--jp-layout-color4);
}

.jp-icon-alt .jp-icon0[stroke] {
  stroke: var(--jp-layout-color0);
}

.jp-icon-alt .jp-icon1[stroke] {
  stroke: var(--jp-layout-color1);
}

.jp-icon-alt .jp-icon2[stroke] {
  stroke: var(--jp-layout-color2);
}

.jp-icon-alt .jp-icon3[stroke] {
  stroke: var(--jp-layout-color3);
}

.jp-icon-alt .jp-icon4[stroke] {
  stroke: var(--jp-layout-color4);
}

/* alt recolor the accent elements of an icon */
.jp-icon-alt .jp-icon-accent0[fill] {
  fill: var(--jp-inverse-layout-color0);
}

.jp-icon-alt .jp-icon-accent1[fill] {
  fill: var(--jp-inverse-layout-color1);
}

.jp-icon-alt .jp-icon-accent2[fill] {
  fill: var(--jp-inverse-layout-color2);
}

.jp-icon-alt .jp-icon-accent3[fill] {
  fill: var(--jp-inverse-layout-color3);
}

.jp-icon-alt .jp-icon-accent4[fill] {
  fill: var(--jp-inverse-layout-color4);
}

.jp-icon-alt .jp-icon-accent0[stroke] {
  stroke: var(--jp-inverse-layout-color0);
}

.jp-icon-alt .jp-icon-accent1[stroke] {
  stroke: var(--jp-inverse-layout-color1);
}

.jp-icon-alt .jp-icon-accent2[stroke] {
  stroke: var(--jp-inverse-layout-color2);
}

.jp-icon-alt .jp-icon-accent3[stroke] {
  stroke: var(--jp-inverse-layout-color3);
}

.jp-icon-alt .jp-icon-accent4[stroke] {
  stroke: var(--jp-inverse-layout-color4);
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-icon-hoverShow:not(:hover) .jp-icon-hoverShow-content {
  display: none !important;
}

/**
 * Support for hover colors for icons as inline SVG HTMLElements
 */

/**
 * regular colors
 */

/* recolor the primary elements of an icon */
.jp-icon-hover :hover .jp-icon0-hover[fill] {
  fill: var(--jp-inverse-layout-color0);
}

.jp-icon-hover :hover .jp-icon1-hover[fill] {
  fill: var(--jp-inverse-layout-color1);
}

.jp-icon-hover :hover .jp-icon2-hover[fill] {
  fill: var(--jp-inverse-layout-color2);
}

.jp-icon-hover :hover .jp-icon3-hover[fill] {
  fill: var(--jp-inverse-layout-color3);
}

.jp-icon-hover :hover .jp-icon4-hover[fill] {
  fill: var(--jp-inverse-layout-color4);
}

.jp-icon-hover :hover .jp-icon0-hover[stroke] {
  stroke: var(--jp-inverse-layout-color0);
}

.jp-icon-hover :hover .jp-icon1-hover[stroke] {
  stroke: var(--jp-inverse-layout-color1);
}

.jp-icon-hover :hover .jp-icon2-hover[stroke] {
  stroke: var(--jp-inverse-layout-color2);
}

.jp-icon-hover :hover .jp-icon3-hover[stroke] {
  stroke: var(--jp-inverse-layout-color3);
}

.jp-icon-hover :hover .jp-icon4-hover[stroke] {
  stroke: var(--jp-inverse-layout-color4);
}

/* recolor the accent elements of an icon */
.jp-icon-hover :hover .jp-icon-accent0-hover[fill] {
  fill: var(--jp-layout-color0);
}

.jp-icon-hover :hover .jp-icon-accent1-hover[fill] {
  fill: var(--jp-layout-color1);
}

.jp-icon-hover :hover .jp-icon-accent2-hover[fill] {
  fill: var(--jp-layout-color2);
}

.jp-icon-hover :hover .jp-icon-accent3-hover[fill] {
  fill: var(--jp-layout-color3);
}

.jp-icon-hover :hover .jp-icon-accent4-hover[fill] {
  fill: var(--jp-layout-color4);
}

.jp-icon-hover :hover .jp-icon-accent0-hover[stroke] {
  stroke: var(--jp-layout-color0);
}

.jp-icon-hover :hover .jp-icon-accent1-hover[stroke] {
  stroke: var(--jp-layout-color1);
}

.jp-icon-hover :hover .jp-icon-accent2-hover[stroke] {
  stroke: var(--jp-layout-color2);
}

.jp-icon-hover :hover .jp-icon-accent3-hover[stroke] {
  stroke: var(--jp-layout-color3);
}

.jp-icon-hover :hover .jp-icon-accent4-hover[stroke] {
  stroke: var(--jp-layout-color4);
}

/* set the color of an icon to transparent */
.jp-icon-hover :hover .jp-icon-none-hover[fill] {
  fill: none;
}

.jp-icon-hover :hover .jp-icon-none-hover[stroke] {
  stroke: none;
}

/**
 * inverse colors
 */

/* inverse recolor the primary elements of an icon */
.jp-icon-hover.jp-icon-alt :hover .jp-icon0-hover[fill] {
  fill: var(--jp-layout-color0);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon1-hover[fill] {
  fill: var(--jp-layout-color1);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon2-hover[fill] {
  fill: var(--jp-layout-color2);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon3-hover[fill] {
  fill: var(--jp-layout-color3);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon4-hover[fill] {
  fill: var(--jp-layout-color4);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon0-hover[stroke] {
  stroke: var(--jp-layout-color0);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon1-hover[stroke] {
  stroke: var(--jp-layout-color1);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon2-hover[stroke] {
  stroke: var(--jp-layout-color2);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon3-hover[stroke] {
  stroke: var(--jp-layout-color3);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon4-hover[stroke] {
  stroke: var(--jp-layout-color4);
}

/* inverse recolor the accent elements of an icon */
.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent0-hover[fill] {
  fill: var(--jp-inverse-layout-color0);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent1-hover[fill] {
  fill: var(--jp-inverse-layout-color1);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent2-hover[fill] {
  fill: var(--jp-inverse-layout-color2);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent3-hover[fill] {
  fill: var(--jp-inverse-layout-color3);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent4-hover[fill] {
  fill: var(--jp-inverse-layout-color4);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent0-hover[stroke] {
  stroke: var(--jp-inverse-layout-color0);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent1-hover[stroke] {
  stroke: var(--jp-inverse-layout-color1);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent2-hover[stroke] {
  stroke: var(--jp-inverse-layout-color2);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent3-hover[stroke] {
  stroke: var(--jp-inverse-layout-color3);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent4-hover[stroke] {
  stroke: var(--jp-inverse-layout-color4);
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-IFrame {
  width: 100%;
  height: 100%;
}

.jp-IFrame > iframe {
  border: none;
}

/*
When drag events occur, `lm-mod-override-cursor` is added to the body.
Because iframes steal all cursor events, the following two rules are necessary
to suppress pointer events while resize drags are occurring. There may be a
better solution to this problem.
*/
body.lm-mod-override-cursor .jp-IFrame {
  position: relative;
}

body.lm-mod-override-cursor .jp-IFrame::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: transparent;
}

/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2016, Jupyter Development Team.
|
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-HoverBox {
  position: fixed;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-FormGroup-content fieldset {
  border: none;
  padding: 0;
  min-width: 0;
  width: 100%;
}

/* stylelint-disable selector-max-type */

.jp-FormGroup-content fieldset .jp-inputFieldWrapper input,
.jp-FormGroup-content fieldset .jp-inputFieldWrapper select,
.jp-FormGroup-content fieldset .jp-inputFieldWrapper textarea {
  font-size: var(--jp-content-font-size2);
  border-color: var(--jp-input-border-color);
  border-style: solid;
  border-radius: var(--jp-border-radius);
  border-width: 1px;
  padding: 6px 8px;
  background: none;
  color: var(--jp-ui-font-color0);
  height: inherit;
}

.jp-FormGroup-content fieldset input[type='checkbox'] {
  position: relative;
  top: 2px;
  margin-left: 0;
}

.jp-FormGroup-content button.jp-mod-styled {
  cursor: pointer;
}

.jp-FormGroup-content .checkbox label {
  cursor: pointer;
  font-size: var(--jp-content-font-size1);
}

.jp-FormGroup-content .jp-root > fieldset > legend {
  display: none;
}

.jp-FormGroup-content .jp-root > fieldset > p {
  display: none;
}

/** copy of `input.jp-mod-styled:focus` style */
.jp-FormGroup-content fieldset input:focus,
.jp-FormGroup-content fieldset select:focus {
  -moz-outline-radius: unset;
  outline: var(--jp-border-width) solid var(--md-blue-500);
  outline-offset: -1px;
  box-shadow: inset 0 0 4px var(--md-blue-300);
}

.jp-FormGroup-content fieldset input:hover:not(:focus),
.jp-FormGroup-content fieldset select:hover:not(:focus) {
  background-color: var(--jp-border-color2);
}

/* stylelint-enable selector-max-type */

.jp-FormGroup-content .checkbox .field-description {
  /* Disable default description field for checkbox:
   because other widgets do not have description fields,
   we add descriptions to each widget on the field level.
  */
  display: none;
}

.jp-FormGroup-content #root__description {
  display: none;
}

.jp-FormGroup-content .jp-modifiedIndicator {
  width: 5px;
  background-color: var(--jp-brand-color2);
  margin-top: 0;
  margin-left: calc(var(--jp-private-settingeditor-modifier-indent) * -1);
  flex-shrink: 0;
}

.jp-FormGroup-content .jp-modifiedIndicator.jp-errorIndicator {
  background-color: var(--jp-error-color0);
  margin-right: 0.5em;
}

/* RJSF ARRAY style */

.jp-arrayFieldWrapper legend {
  font-size: var(--jp-content-font-size2);
  color: var(--jp-ui-font-color0);
  flex-basis: 100%;
  padding: 4px 0;
  font-weight: var(--jp-content-heading-font-weight);
  border-bottom: 1px solid var(--jp-border-color2);
}

.jp-arrayFieldWrapper .field-description {
  padding: 4px 0;
  white-space: pre-wrap;
}

.jp-arrayFieldWrapper .array-item {
  width: 100%;
  border: 1px solid var(--jp-border-color2);
  border-radius: 4px;
  margin: 4px;
}

.jp-ArrayOperations {
  display: flex;
  margin-left: 8px;
}

.jp-ArrayOperationsButton {
  margin: 2px;
}

.jp-ArrayOperationsButton .jp-icon3[fill] {
  fill: var(--jp-ui-font-color0);
}

button.jp-ArrayOperationsButton.jp-mod-styled:disabled {
  cursor: not-allowed;
  opacity: 0.5;
}

/* RJSF form validation error */

.jp-FormGroup-content .validationErrors {
  color: var(--jp-error-color0);
}

/* Hide panel level error as duplicated the field level error */
.jp-FormGroup-content .panel.errors {
  display: none;
}

/* RJSF normal content (settings-editor) */

.jp-FormGroup-contentNormal {
  display: flex;
  align-items: center;
  flex-wrap: wrap;
}

.jp-FormGroup-contentNormal .jp-FormGroup-contentItem {
  margin-left: 7px;
  color: var(--jp-ui-font-color0);
}

.jp-FormGroup-contentNormal .jp-FormGroup-description {
  flex-basis: 100%;
  padding: 4px 7px;
}

.jp-FormGroup-contentNormal .jp-FormGroup-default {
  flex-basis: 100%;
  padding: 4px 7px;
}

.jp-FormGroup-contentNormal .jp-FormGroup-fieldLabel {
  font-size: var(--jp-content-font-size1);
  font-weight: normal;
  min-width: 120px;
}

.jp-FormGroup-contentNormal fieldset:not(:first-child) {
  margin-left: 7px;
}

.jp-FormGroup-contentNormal .field-array-of-string .array-item {
  /* Display `jp-ArrayOperations` buttons side-by-side with content except
    for small screens where flex-wrap will place them one below the other.
  */
  display: flex;
  align-items: center;
  flex-wrap: wrap;
}

.jp-FormGroup-contentNormal .jp-objectFieldWrapper .form-group {
  padding: 2px 8px 2px var(--jp-private-settingeditor-modifier-indent);
  margin-top: 2px;
}

/* RJSF compact content (metadata-form) */

.jp-FormGroup-content.jp-FormGroup-contentCompact {
  width: 100%;
}

.jp-FormGroup-contentCompact .form-group {
  display: flex;
  padding: 0.5em 0.2em 0.5em 0;
}

.jp-FormGroup-contentCompact
  .jp-FormGroup-compactTitle
  .jp-FormGroup-description {
  font-size: var(--jp-ui-font-size1);
  color: var(--jp-ui-font-color2);
}

.jp-FormGroup-contentCompact .jp-FormGroup-fieldLabel {
  padding-bottom: 0.3em;
}

.jp-FormGroup-contentCompact .jp-inputFieldWrapper .form-control {
  width: 100%;
  box-sizing: border-box;
}

.jp-FormGroup-contentCompact .jp-arrayFieldWrapper .jp-FormGroup-compactTitle {
  padding-bottom: 7px;
}

.jp-FormGroup-contentCompact
  .jp-objectFieldWrapper
  .jp-objectFieldWrapper
  .form-group {
  padding: 2px 8px 2px var(--jp-private-settingeditor-modifier-indent);
  margin-top: 2px;
}

.jp-FormGroup-contentCompact ul.error-detail {
  margin-block-start: 0.5em;
  margin-block-end: 0.5em;
  padding-inline-start: 1em;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

.jp-SidePanel {
  display: flex;
  flex-direction: column;
  min-width: var(--jp-sidebar-min-width);
  overflow-y: auto;
  color: var(--jp-ui-font-color1);
  background: var(--jp-layout-color1);
  font-size: var(--jp-ui-font-size1);
}

.jp-SidePanel-header {
  flex: 0 0 auto;
  display: flex;
  border-bottom: var(--jp-border-width) solid var(--jp-border-color2);
  font-size: var(--jp-ui-font-size0);
  font-weight: 600;
  letter-spacing: 1px;
  margin: 0;
  padding: 2px;
  text-transform: uppercase;
}

.jp-SidePanel-toolbar {
  flex: 0 0 auto;
}

.jp-SidePanel-content {
  flex: 1 1 auto;
}

.jp-SidePanel-toolbar,
.jp-AccordionPanel-toolbar {
  height: var(--jp-private-toolbar-height);
}

.jp-SidePanel-toolbar.jp-Toolbar-micro {
  display: none;
}

.lm-AccordionPanel .jp-AccordionPanel-title {
  box-sizing: border-box;
  line-height: 25px;
  margin: 0;
  display: flex;
  align-items: center;
  background: var(--jp-layout-color1);
  color: var(--jp-ui-font-color1);
  border-bottom: var(--jp-border-width) solid var(--jp-toolbar-border-color);
  box-shadow: var(--jp-toolbar-box-shadow);
  font-size: var(--jp-ui-font-size0);
}

.jp-AccordionPanel-title {
  cursor: pointer;
  user-select: none;
  -moz-user-select: none;
  -webkit-user-select: none;
  text-transform: uppercase;
}

.lm-AccordionPanel[data-orientation='horizontal'] > .jp-AccordionPanel-title {
  /* Title is rotated for horizontal accordion panel using CSS */
  display: block;
  transform-origin: top left;
  transform: rotate(-90deg) translate(-100%);
}

.jp-AccordionPanel-title .lm-AccordionPanel-titleLabel {
  user-select: none;
  text-overflow: ellipsis;
  white-space: nowrap;
  overflow: hidden;
}

.jp-AccordionPanel-title .lm-AccordionPanel-titleCollapser {
  transform: rotate(-90deg);
  margin: auto 0;
  height: 16px;
}

.jp-AccordionPanel-title.lm-mod-expanded .lm-AccordionPanel-titleCollapser {
  transform: rotate(0deg);
}

.lm-AccordionPanel .jp-AccordionPanel-toolbar {
  background: none;
  box-shadow: none;
  border: none;
  margin-left: auto;
}

.lm-AccordionPanel .lm-SplitPanel-handle:hover {
  background: var(--jp-layout-color3);
}

.jp-text-truncated {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/*-----------------------------------------------------------------------------
| Copyright (c) 2017, Jupyter Development Team.
|
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-Spinner {
  position: absolute;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 10;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background: var(--jp-layout-color0);
  outline: none;
}

.jp-SpinnerContent {
  font-size: 10px;
  margin: 50px auto;
  text-indent: -9999em;
  width: 3em;
  height: 3em;
  border-radius: 50%;
  background: var(--jp-brand-color3);
  background: linear-gradient(
    to right,
    #f37626 10%,
    rgba(255, 255, 255, 0) 42%
  );
  position: relative;
  animation: load3 1s infinite linear, fadeIn 1s;
}

.jp-SpinnerContent::before {
  width: 50%;
  height: 50%;
  background: #f37626;
  border-radius: 100% 0 0;
  position: absolute;
  top: 0;
  left: 0;
  content: '';
}

.jp-SpinnerContent::after {
  background: var(--jp-layout-color0);
  width: 75%;
  height: 75%;
  border-radius: 50%;
  content: '';
  margin: auto;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
}

@keyframes fadeIn {
  0% {
    opacity: 0;
  }

  100% {
    opacity: 1;
  }
}

@keyframes load3 {
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
}

/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2017, Jupyter Development Team.
|
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

button.jp-mod-styled {
  font-size: var(--jp-ui-font-size1);
  color: var(--jp-ui-font-color0);
  border: none;
  box-sizing: border-box;
  text-align: center;
  line-height: 32px;
  height: 32px;
  padding: 0 12px;
  letter-spacing: 0.8px;
  outline: none;
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
}

input.jp-mod-styled {
  background: var(--jp-input-background);
  height: 28px;
  box-sizing: border-box;
  border: var(--jp-border-width) solid var(--jp-border-color1);
  padding-left: 7px;
  padding-right: 7px;
  font-size: var(--jp-ui-font-size2);
  color: var(--jp-ui-font-color0);
  outline: none;
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
}

input[type='checkbox'].jp-mod-styled {
  appearance: checkbox;
  -webkit-appearance: checkbox;
  -moz-appearance: checkbox;
  height: auto;
}

input.jp-mod-styled:focus {
  border: var(--jp-border-width) solid var(--md-blue-500);
  box-shadow: inset 0 0 4px var(--md-blue-300);
}

.jp-select-wrapper {
  display: flex;
  position: relative;
  flex-direction: column;
  padding: 1px;
  background-color: var(--jp-layout-color1);
  box-sizing: border-box;
  margin-bottom: 12px;
}

.jp-select-wrapper:not(.multiple) {
  height: 28px;
}

.jp-select-wrapper.jp-mod-focused select.jp-mod-styled {
  border: var(--jp-border-width) solid var(--jp-input-active-border-color);
  box-shadow: var(--jp-input-box-shadow);
  background-color: var(--jp-input-active-background);
}

select.jp-mod-styled:hover {
  cursor: pointer;
  color: var(--jp-ui-font-color0);
  background-color: var(--jp-input-hover-background);
  box-shadow: inset 0 0 1px rgba(0, 0, 0, 0.5);
}

select.jp-mod-styled {
  flex: 1 1 auto;
  width: 100%;
  font-size: var(--jp-ui-font-size2);
  background: var(--jp-input-background);
  color: var(--jp-ui-font-color0);
  padding: 0 25px 0 8px;
  border: var(--jp-border-width) solid var(--jp-input-border-color);
  border-radius: 0;
  outline: none;
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
}

select.jp-mod-styled:not([multiple]) {
  height: 32px;
}

select.jp-mod-styled[multiple] {
  max-height: 200px;
  overflow-y: auto;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-switch {
  display: flex;
  align-items: center;
  padding-left: 4px;
  padding-right: 4px;
  font-size: var(--jp-ui-font-size1);
  background-color: transparent;
  color: var(--jp-ui-font-color1);
  border: none;
  height: 20px;
}

.jp-switch:hover {
  background-color: var(--jp-layout-color2);
}

.jp-switch-label {
  margin-right: 5px;
  font-family: var(--jp-ui-font-family);
}

.jp-switch-track {
  cursor: pointer;
  background-color: var(--jp-switch-color, var(--jp-border-color1));
  -webkit-transition: 0.4s;
  transition: 0.4s;
  border-radius: 34px;
  height: 16px;
  width: 35px;
  position: relative;
}

.jp-switch-track::before {
  content: '';
  position: absolute;
  height: 10px;
  width: 10px;
  margin: 3px;
  left: 0;
  background-color: var(--jp-ui-inverse-font-color1);
  -webkit-transition: 0.4s;
  transition: 0.4s;
  border-radius: 50%;
}

.jp-switch[aria-checked='true'] .jp-switch-track {
  background-color: var(--jp-switch-true-position-color, var(--jp-warn-color0));
}

.jp-switch[aria-checked='true'] .jp-switch-track::before {
  /* track width (35) - margins (3 + 3) - thumb width (10) */
  left: 19px;
}

/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2016, Jupyter Development Team.
|
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

:root {
  --jp-private-toolbar-height: calc(
    28px + var(--jp-border-width)
  ); /* leave 28px for content */
}

.jp-Toolbar {
  color: var(--jp-ui-font-color1);
  flex: 0 0 auto;
  display: flex;
  flex-direction: row;
  border-bottom: var(--jp-border-width) solid var(--jp-toolbar-border-color);
  box-shadow: var(--jp-toolbar-box-shadow);
  background: var(--jp-toolbar-background);
  min-height: var(--jp-toolbar-micro-height);
  padding: 2px;
  z-index: 8;
  overflow-x: hidden;
}

/* Toolbar items */

.jp-Toolbar > .jp-Toolbar-item.jp-Toolbar-spacer {
  flex-grow: 1;
  flex-shrink: 1;
}

.jp-Toolbar-item.jp-Toolbar-kernelStatus {
  display: inline-block;
  width: 32px;
  background-repeat: no-repeat;
  background-position: center;
  background-size: 16px;
}

.jp-Toolbar > .jp-Toolbar-item {
  flex: 0 0 auto;
  display: flex;
  padding-left: 1px;
  padding-right: 1px;
  font-size: var(--jp-ui-font-size1);
  line-height: var(--jp-private-toolbar-height);
  height: 100%;
}

/* Toolbar buttons */

/* This is the div we use to wrap the react component into a Widget */
div.jp-ToolbarButton {
  color: transparent;
  border: none;
  box-sizing: border-box;
  outline: none;
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  padding: 0;
  margin: 0;
}

button.jp-ToolbarButtonComponent {
  background: var(--jp-layout-color1);
  border: none;
  box-sizing: border-box;
  outline: none;
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  padding: 0 6px;
  margin: 0;
  height: 24px;
  border-radius: var(--jp-border-radius);
  display: flex;
  align-items: center;
  text-align: center;
  font-size: 14px;
  min-width: unset;
  min-height: unset;
}

button.jp-ToolbarButtonComponent:disabled {
  opacity: 0.4;
}

button.jp-ToolbarButtonComponent > span {
  padding: 0;
  flex: 0 0 auto;
}

button.jp-ToolbarButtonComponent .jp-ToolbarButtonComponent-label {
  font-size: var(--jp-ui-font-size1);
  line-height: 100%;
  padding-left: 2px;
  color: var(--jp-ui-font-color1);
  font-family: var(--jp-ui-font-family);
}

#jp-main-dock-panel[data-mode='single-document']
  .jp-MainAreaWidget
  > .jp-Toolbar.jp-Toolbar-micro {
  padding: 0;
  min-height: 0;
}

#jp-main-dock-panel[data-mode='single-document']
  .jp-MainAreaWidget
  > .jp-Toolbar {
  border: none;
  box-shadow: none;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

.jp-WindowedPanel-outer {
  position: relative;
  overflow-y: auto;
}

.jp-WindowedPanel-inner {
  position: relative;
}

.jp-WindowedPanel-window {
  position: absolute;
  left: 0;
  right: 0;
  overflow: visible;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/* Sibling imports */

body {
  color: var(--jp-ui-font-color1);
  font-size: var(--jp-ui-font-size1);
}

/* Disable native link decoration styles everywhere outside of dialog boxes */
a {
  text-decoration: unset;
  color: unset;
}

a:hover {
  text-decoration: unset;
  color: unset;
}

/* Accessibility for links inside dialog box text */
.jp-Dialog-content a {
  text-decoration: revert;
  color: var(--jp-content-link-color);
}

.jp-Dialog-content a:hover {
  text-decoration: revert;
}

/* Styles for ui-components */
.jp-Button {
  color: var(--jp-ui-font-color2);
  border-radius: var(--jp-border-radius);
  padding: 0 12px;
  font-size: var(--jp-ui-font-size1);

  /* Copy from blueprint 3 */
  display: inline-flex;
  flex-direction: row;
  border: none;
  cursor: pointer;
  align-items: center;
  justify-content: center;
  text-align: left;
  vertical-align: middle;
  min-height: 30px;
  min-width: 30px;
}

.jp-Button:disabled {
  cursor: not-allowed;
}

.jp-Button:empty {
  padding: 0 !important;
}

.jp-Button.jp-mod-small {
  min-height: 24px;
  min-width: 24px;
  font-size: 12px;
  padding: 0 7px;
}

/* Use our own theme for hover styles */
.jp-Button.jp-mod-minimal:hover {
  background-color: var(--jp-layout-color2);
}

.jp-Button.jp-mod-minimal {
  background: none;
}

.jp-InputGroup {
  display: block;
  position: relative;
}

.jp-InputGroup input {
  box-sizing: border-box;
  border: none;
  border-radius: 0;
  background-color: transparent;
  color: var(--jp-ui-font-color0);
  box-shadow: inset 0 0 0 var(--jp-border-width) var(--jp-input-border-color);
  padding-bottom: 0;
  padding-top: 0;
  padding-left: 10px;
  padding-right: 28px;
  position: relative;
  width: 100%;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  font-size: 14px;
  font-weight: 400;
  height: 30px;
  line-height: 30px;
  outline: none;
  vertical-align: middle;
}

.jp-InputGroup input:focus {
  box-shadow: inset 0 0 0 var(--jp-border-width)
      var(--jp-input-active-box-shadow-color),
    inset 0 0 0 3px var(--jp-input-active-box-shadow-color);
}

.jp-InputGroup input:disabled {
  cursor: not-allowed;
  resize: block;
  background-color: var(--jp-layout-color2);
  color: var(--jp-ui-font-color2);
}

.jp-InputGroup input:disabled ~ span {
  cursor: not-allowed;
  color: var(--jp-ui-font-color2);
}

.jp-InputGroup input::placeholder,
input::placeholder {
  color: var(--jp-ui-font-color2);
}

.jp-InputGroupAction {
  position: absolute;
  bottom: 1px;
  right: 0;
  padding: 6px;
}

.jp-HTMLSelect.jp-DefaultStyle select {
  background-color: initial;
  border: none;
  border-radius: 0;
  box-shadow: none;
  color: var(--jp-ui-font-color0);
  display: block;
  font-size: var(--jp-ui-font-size1);
  font-family: var(--jp-ui-font-family);
  height: 24px;
  line-height: 14px;
  padding: 0 25px 0 10px;
  text-align: left;
  -moz-appearance: none;
  -webkit-appearance: none;
}

.jp-HTMLSelect.jp-DefaultStyle select:disabled {
  background-color: var(--jp-layout-color2);
  color: var(--jp-ui-font-color2);
  cursor: not-allowed;
  resize: block;
}

.jp-HTMLSelect.jp-DefaultStyle select:disabled ~ span {
  cursor: not-allowed;
}

/* Use our own theme for hover and option styles */
/* stylelint-disable-next-line selector-max-type */
.jp-HTMLSelect.jp-DefaultStyle select:hover,
.jp-HTMLSelect.jp-DefaultStyle select > option {
  background-color: var(--jp-layout-color2);
  color: var(--jp-ui-font-color0);
}

select {
  box-sizing: border-box;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Styles
|----------------------------------------------------------------------------*/

.jp-StatusBar-Widget {
  display: flex;
  align-items: center;
  background: var(--jp-layout-color2);
  min-height: var(--jp-statusbar-height);
  justify-content: space-between;
  padding: 0 10px;
}

.jp-StatusBar-Left {
  display: flex;
  align-items: center;
  flex-direction: row;
}

.jp-StatusBar-Middle {
  display: flex;
  align-items: center;
}

.jp-StatusBar-Right {
  display: flex;
  align-items: center;
  flex-direction: row-reverse;
}

.jp-StatusBar-Item {
  max-height: var(--jp-statusbar-height);
  margin: 0 2px;
  height: var(--jp-statusbar-height);
  white-space: nowrap;
  text-overflow: ellipsis;
  color: var(--jp-ui-font-color1);
  padding: 0 6px;
}

.jp-mod-highlighted:hover {
  background-color: var(--jp-layout-color3);
}

.jp-mod-clicked {
  background-color: var(--jp-brand-color1);
}

.jp-mod-clicked:hover {
  background-color: var(--jp-brand-color0);
}

.jp-mod-clicked .jp-StatusBar-TextItem {
  color: var(--jp-ui-inverse-font-color1);
}

.jp-StatusBar-HoverItem {
  box-shadow: '0px 4px 4px rgba(0, 0, 0, 0.25)';
}

.jp-StatusBar-TextItem {
  font-size: var(--jp-ui-font-size1);
  font-family: var(--jp-ui-font-family);
  line-height: 24px;
  color: var(--jp-ui-font-color1);
}

.jp-StatusBar-GroupItem {
  display: flex;
  align-items: center;
  flex-direction: row;
}

.jp-Statusbar-ProgressCircle svg {
  display: block;
  margin: 0 auto;
  width: 16px;
  height: 24px;
  align-self: normal;
}

.jp-Statusbar-ProgressCircle path {
  fill: var(--jp-inverse-layout-color3);
}

.jp-Statusbar-ProgressBar-progress-bar {
  height: 10px;
  width: 100px;
  border: solid 0.25px var(--jp-brand-color2);
  border-radius: 3px;
  overflow: hidden;
  align-self: center;
}

.jp-Statusbar-ProgressBar-progress-bar > div {
  background-color: var(--jp-brand-color2);
  background-image: linear-gradient(
    -45deg,
    rgba(255, 255, 255, 0.2) 25%,
    transparent 25%,
    transparent 50%,
    rgba(255, 255, 255, 0.2) 50%,
    rgba(255, 255, 255, 0.2) 75%,
    transparent 75%,
    transparent
  );
  background-size: 40px 40px;
  float: left;
  width: 0%;
  height: 100%;
  font-size: 12px;
  line-height: 14px;
  color: #fff;
  text-align: center;
  animation: jp-Statusbar-ExecutionTime-progress-bar 2s linear infinite;
}

.jp-Statusbar-ProgressBar-progress-bar p {
  color: var(--jp-ui-font-color1);
  font-family: var(--jp-ui-font-family);
  font-size: var(--jp-ui-font-size1);
  line-height: 10px;
  width: 100px;
}

@keyframes jp-Statusbar-ExecutionTime-progress-bar {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 40px 40px;
  }
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Variables
|----------------------------------------------------------------------------*/

:root {
  --jp-private-commandpalette-search-height: 28px;
}

/*-----------------------------------------------------------------------------
| Overall styles
|----------------------------------------------------------------------------*/

.lm-CommandPalette {
  padding-bottom: 0;
  color: var(--jp-ui-font-color1);
  background: var(--jp-layout-color1);

  /* This is needed so that all font sizing of children done in ems is
   * relative to this base size */
  font-size: var(--jp-ui-font-size1);
}

/*-----------------------------------------------------------------------------
| Modal variant
|----------------------------------------------------------------------------*/

.jp-ModalCommandPalette {
  position: absolute;
  z-index: 10000;
  top: 38px;
  left: 30%;
  margin: 0;
  padding: 4px;
  width: 40%;
  box-shadow: var(--jp-elevation-z4);
  border-radius: 4px;
  background: var(--jp-layout-color0);
}

.jp-ModalCommandPalette .lm-CommandPalette {
  max-height: 40vh;
}

.jp-ModalCommandPalette .lm-CommandPalette .lm-close-icon::after {
  display: none;
}

.jp-ModalCommandPalette .lm-CommandPalette .lm-CommandPalette-header {
  display: none;
}

.jp-ModalCommandPalette .lm-CommandPalette .lm-CommandPalette-item {
  margin-left: 4px;
  margin-right: 4px;
}

.jp-ModalCommandPalette
  .lm-CommandPalette
  .lm-CommandPalette-item.lm-mod-disabled {
  display: none;
}

/*-----------------------------------------------------------------------------
| Search
|----------------------------------------------------------------------------*/

.lm-CommandPalette-search {
  padding: 4px;
  background-color: var(--jp-layout-color1);
  z-index: 2;
}

.lm-CommandPalette-wrapper {
  overflow: overlay;
  padding: 0 9px;
  background-color: var(--jp-input-active-background);
  height: 30px;
  box-shadow: inset 0 0 0 var(--jp-border-width) var(--jp-input-border-color);
}

.lm-CommandPalette.lm-mod-focused .lm-CommandPalette-wrapper {
  box-shadow: inset 0 0 0 1px var(--jp-input-active-box-shadow-color),
    inset 0 0 0 3px var(--jp-input-active-box-shadow-color);
}

.jp-SearchIconGroup {
  color: white;
  background-color: var(--jp-brand-color1);
  position: absolute;
  top: 4px;
  right: 4px;
  padding: 5px 5px 1px;
}

.jp-SearchIconGroup svg {
  height: 20px;
  width: 20px;
}

.jp-SearchIconGroup .jp-icon3[fill] {
  fill: var(--jp-layout-color0);
}

.lm-CommandPalette-input {
  background: transparent;
  width: calc(100% - 18px);
  float: left;
  border: none;
  outline: none;
  font-size: var(--jp-ui-font-size1);
  color: var(--jp-ui-font-color0);
  line-height: var(--jp-private-commandpalette-search-height);
}

.lm-CommandPalette-input::-webkit-input-placeholder,
.lm-CommandPalette-input::-moz-placeholder,
.lm-CommandPalette-input:-ms-input-placeholder {
  color: var(--jp-ui-font-color2);
  font-size: var(--jp-ui-font-size1);
}

/*-----------------------------------------------------------------------------
| Results
|----------------------------------------------------------------------------*/

.lm-CommandPalette-header:first-child {
  margin-top: 0;
}

.lm-CommandPalette-header {
  border-bottom: solid var(--jp-border-width) var(--jp-border-color2);
  color: var(--jp-ui-font-color1);
  cursor: pointer;
  display: flex;
  font-size: var(--jp-ui-font-size0);
  font-weight: 600;
  letter-spacing: 1px;
  margin-top: 8px;
  padding: 8px 0 8px 12px;
  text-transform: uppercase;
}

.lm-CommandPalette-header.lm-mod-active {
  background: var(--jp-layout-color2);
}

.lm-CommandPalette-header > mark {
  background-color: transparent;
  font-weight: bold;
  color: var(--jp-ui-font-color1);
}

.lm-CommandPalette-item {
  padding: 4px 12px 4px 4px;
  color: var(--jp-ui-font-color1);
  font-size: var(--jp-ui-font-size1);
  font-weight: 400;
  display: flex;
}

.lm-CommandPalette-item.lm-mod-disabled {
  color: var(--jp-ui-font-color2);
}

.lm-CommandPalette-item.lm-mod-active {
  color: var(--jp-ui-inverse-font-color1);
  background: var(--jp-brand-color1);
}

.lm-CommandPalette-item.lm-mod-active .lm-CommandPalette-itemLabel > mark {
  color: var(--jp-ui-inverse-font-color0);
}

.lm-CommandPalette-item.lm-mod-active .jp-icon-selectable[fill] {
  fill: var(--jp-layout-color0);
}

.lm-CommandPalette-item.lm-mod-active:hover:not(.lm-mod-disabled) {
  color: var(--jp-ui-inverse-font-color1);
  background: var(--jp-brand-color1);
}

.lm-CommandPalette-item:hover:not(.lm-mod-active):not(.lm-mod-disabled) {
  background: var(--jp-layout-color2);
}

.lm-CommandPalette-itemContent {
  overflow: hidden;
}

.lm-CommandPalette-itemLabel > mark {
  color: var(--jp-ui-font-color0);
  background-color: transparent;
  font-weight: bold;
}

.lm-CommandPalette-item.lm-mod-disabled mark {
  color: var(--jp-ui-font-color2);
}

.lm-CommandPalette-item .lm-CommandPalette-itemIcon {
  margin: 0 4px 0 0;
  position: relative;
  width: 16px;
  top: 2px;
  flex: 0 0 auto;
}

.lm-CommandPalette-item.lm-mod-disabled .lm-CommandPalette-itemIcon {
  opacity: 0.6;
}

.lm-CommandPalette-item .lm-CommandPalette-itemShortcut {
  flex: 0 0 auto;
}

.lm-CommandPalette-itemCaption {
  display: none;
}

.lm-CommandPalette-content {
  background-color: var(--jp-layout-color1);
}

.lm-CommandPalette-content:empty::after {
  content: 'No results';
  margin: auto;
  margin-top: 20px;
  width: 100px;
  display: block;
  font-size: var(--jp-ui-font-size2);
  font-family: var(--jp-ui-font-family);
  font-weight: lighter;
}

.lm-CommandPalette-emptyMessage {
  text-align: center;
  margin-top: 24px;
  line-height: 1.32;
  padding: 0 8px;
  color: var(--jp-content-font-color3);
}

/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2017, Jupyter Development Team.
|
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-Dialog {
  position: absolute;
  z-index: 10000;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  top: 0;
  left: 0;
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  background: var(--jp-dialog-background);
}

.jp-Dialog-content {
  display: flex;
  flex-direction: column;
  margin-left: auto;
  margin-right: auto;
  background: var(--jp-layout-color1);
  padding: 24px 24px 12px;
  min-width: 300px;
  min-height: 150px;
  max-width: 1000px;
  max-height: 500px;
  box-sizing: border-box;
  box-shadow: var(--jp-elevation-z20);
  word-wrap: break-word;
  border-radius: var(--jp-border-radius);

  /* This is needed so that all font sizing of children done in ems is
   * relative to this base size */
  font-size: var(--jp-ui-font-size1);
  color: var(--jp-ui-font-color1);
  resize: both;
}

.jp-Dialog-content.jp-Dialog-content-small {
  max-width: 500px;
}

.jp-Dialog-button {
  overflow: visible;
}

button.jp-Dialog-button:focus {
  outline: 1px solid var(--jp-brand-color1);
  outline-offset: 4px;
  -moz-outline-radius: 0;
}

button.jp-Dialog-button:focus::-moz-focus-inner {
  border: 0;
}

button.jp-Dialog-button.jp-mod-styled.jp-mod-accept:focus,
button.jp-Dialog-button.jp-mod-styled.jp-mod-warn:focus,
button.jp-Dialog-button.jp-mod-styled.jp-mod-reject:focus {
  outline-offset: 4px;
  -moz-outline-radius: 0;
}

button.jp-Dialog-button.jp-mod-styled.jp-mod-accept:focus {
  outline: 1px solid var(--jp-accept-color-normal, var(--jp-brand-color1));
}

button.jp-Dialog-button.jp-mod-styled.jp-mod-warn:focus {
  outline: 1px solid var(--jp-warn-color-normal, var(--jp-error-color1));
}

button.jp-Dialog-button.jp-mod-styled.jp-mod-reject:focus {
  outline: 1px solid var(--jp-reject-color-normal, var(--md-grey-600));
}

button.jp-Dialog-close-button {
  padding: 0;
  height: 100%;
  min-width: unset;
  min-height: unset;
}

.jp-Dialog-header {
  display: flex;
  justify-content: space-between;
  flex: 0 0 auto;
  padding-bottom: 12px;
  font-size: var(--jp-ui-font-size3);
  font-weight: 400;
  color: var(--jp-ui-font-color1);
}

.jp-Dialog-body {
  display: flex;
  flex-direction: column;
  flex: 1 1 auto;
  font-size: var(--jp-ui-font-size1);
  background: var(--jp-layout-color1);
  color: var(--jp-ui-font-color1);
  overflow: auto;
}

.jp-Dialog-footer {
  display: flex;
  flex-direction: row;
  justify-content: flex-end;
  align-items: center;
  flex: 0 0 auto;
  margin-left: -12px;
  margin-right: -12px;
  padding: 12px;
}

.jp-Dialog-checkbox {
  padding-right: 5px;
}

.jp-Dialog-checkbox > input:focus-visible {
  outline: 1px solid var(--jp-input-active-border-color);
  outline-offset: 1px;
}

.jp-Dialog-spacer {
  flex: 1 1 auto;
}

.jp-Dialog-title {
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.jp-Dialog-body > .jp-select-wrapper {
  width: 100%;
}

.jp-Dialog-body > button {
  padding: 0 16px;
}

.jp-Dialog-body > label {
  line-height: 1.4;
  color: var(--jp-ui-font-color0);
}

.jp-Dialog-button.jp-mod-styled:not(:last-child) {
  margin-right: 12px;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

.jp-Input-Boolean-Dialog {
  flex-direction: row-reverse;
  align-items: end;
  width: 100%;
}

.jp-Input-Boolean-Dialog > label {
  flex: 1 1 auto;
}

/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2016, Jupyter Development Team.
|
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-MainAreaWidget > :focus {
  outline: none;
}

.jp-MainAreaWidget .jp-MainAreaWidget-error {
  padding: 6px;
}

.jp-MainAreaWidget .jp-MainAreaWidget-error > pre {
  width: auto;
  padding: 10px;
  background: var(--jp-error-color3);
  border: var(--jp-border-width) solid var(--jp-error-color1);
  border-radius: var(--jp-border-radius);
  color: var(--jp-ui-font-color1);
  font-size: var(--jp-ui-font-size1);
  white-space: pre-wrap;
  word-wrap: break-word;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/**
 * google-material-color v1.2.6
 * https://github.com/danlevan/google-material-color
 */
:root {
  --md-red-50: #ffebee;
  --md-red-100: #ffcdd2;
  --md-red-200: #ef9a9a;
  --md-red-300: #e57373;
  --md-red-400: #ef5350;
  --md-red-500: #f44336;
  --md-red-600: #e53935;
  --md-red-700: #d32f2f;
  --md-red-800: #c62828;
  --md-red-900: #b71c1c;
  --md-red-A100: #ff8a80;
  --md-red-A200: #ff5252;
  --md-red-A400: #ff1744;
  --md-red-A700: #d50000;
  --md-pink-50: #fce4ec;
  --md-pink-100: #f8bbd0;
  --md-pink-200: #f48fb1;
  --md-pink-300: #f06292;
  --md-pink-400: #ec407a;
  --md-pink-500: #e91e63;
  --md-pink-600: #d81b60;
  --md-pink-700: #c2185b;
  --md-pink-800: #ad1457;
  --md-pink-900: #880e4f;
  --md-pink-A100: #ff80ab;
  --md-pink-A200: #ff4081;
  --md-pink-A400: #f50057;
  --md-pink-A700: #c51162;
  --md-purple-50: #f3e5f5;
  --md-purple-100: #e1bee7;
  --md-purple-200: #ce93d8;
  --md-purple-300: #ba68c8;
  --md-purple-400: #ab47bc;
  --md-purple-500: #9c27b0;
  --md-purple-600: #8e24aa;
  --md-purple-700: #7b1fa2;
  --md-purple-800: #6a1b9a;
  --md-purple-900: #4a148c;
  --md-purple-A100: #ea80fc;
  --md-purple-A200: #e040fb;
  --md-purple-A400: #d500f9;
  --md-purple-A700: #a0f;
  --md-deep-purple-50: #ede7f6;
  --md-deep-purple-100: #d1c4e9;
  --md-deep-purple-200: #b39ddb;
  --md-deep-purple-300: #9575cd;
  --md-deep-purple-400: #7e57c2;
  --md-deep-purple-500: #673ab7;
  --md-deep-purple-600: #5e35b1;
  --md-deep-purple-700: #512da8;
  --md-deep-purple-800: #4527a0;
  --md-deep-purple-900: #311b92;
  --md-deep-purple-A100: #b388ff;
  --md-deep-purple-A200: #7c4dff;
  --md-deep-purple-A400: #651fff;
  --md-deep-purple-A700: #6200ea;
  --md-indigo-50: #e8eaf6;
  --md-indigo-100: #c5cae9;
  --md-indigo-200: #9fa8da;
  --md-indigo-300: #7986cb;
  --md-indigo-400: #5c6bc0;
  --md-indigo-500: #3f51b5;
  --md-indigo-600: #3949ab;
  --md-indigo-700: #303f9f;
  --md-indigo-800: #283593;
  --md-indigo-900: #1a237e;
  --md-indigo-A100: #8c9eff;
  --md-indigo-A200: #536dfe;
  --md-indigo-A400: #3d5afe;
  --md-indigo-A700: #304ffe;
  --md-blue-50: #e3f2fd;
  --md-blue-100: #bbdefb;
  --md-blue-200: #90caf9;
  --md-blue-300: #64b5f6;
  --md-blue-400: #42a5f5;
  --md-blue-500: #2196f3;
  --md-blue-600: #1e88e5;
  --md-blue-700: #1976d2;
  --md-blue-800: #1565c0;
  --md-blue-900: #0d47a1;
  --md-blue-A100: #82b1ff;
  --md-blue-A200: #448aff;
  --md-blue-A400: #2979ff;
  --md-blue-A700: #2962ff;
  --md-light-blue-50: #e1f5fe;
  --md-light-blue-100: #b3e5fc;
  --md-light-blue-200: #81d4fa;
  --md-light-blue-300: #4fc3f7;
  --md-light-blue-400: #29b6f6;
  --md-light-blue-500: #03a9f4;
  --md-light-blue-600: #039be5;
  --md-light-blue-700: #0288d1;
  --md-light-blue-800: #0277bd;
  --md-light-blue-900: #01579b;
  --md-light-blue-A100: #80d8ff;
  --md-light-blue-A200: #40c4ff;
  --md-light-blue-A400: #00b0ff;
  --md-light-blue-A700: #0091ea;
  --md-cyan-50: #e0f7fa;
  --md-cyan-100: #b2ebf2;
  --md-cyan-200: #80deea;
  --md-cyan-300: #4dd0e1;
  --md-cyan-400: #26c6da;
  --md-cyan-500: #00bcd4;
  --md-cyan-600: #00acc1;
  --md-cyan-700: #0097a7;
  --md-cyan-800: #00838f;
  --md-cyan-900: #006064;
  --md-cyan-A100: #84ffff;
  --md-cyan-A200: #18ffff;
  --md-cyan-A400: #00e5ff;
  --md-cyan-A700: #00b8d4;
  --md-teal-50: #e0f2f1;
  --md-teal-100: #b2dfdb;
  --md-teal-200: #80cbc4;
  --md-teal-300: #4db6ac;
  --md-teal-400: #26a69a;
  --md-teal-500: #009688;
  --md-teal-600: #00897b;
  --md-teal-700: #00796b;
  --md-teal-800: #00695c;
  --md-teal-900: #004d40;
  --md-teal-A100: #a7ffeb;
  --md-teal-A200: #64ffda;
  --md-teal-A400: #1de9b6;
  --md-teal-A700: #00bfa5;
  --md-green-50: #e8f5e9;
  --md-green-100: #c8e6c9;
  --md-green-200: #a5d6a7;
  --md-green-300: #81c784;
  --md-green-400: #66bb6a;
  --md-green-500: #4caf50;
  --md-green-600: #43a047;
  --md-green-700: #388e3c;
  --md-green-800: #2e7d32;
  --md-green-900: #1b5e20;
  --md-green-A100: #b9f6ca;
  --md-green-A200: #69f0ae;
  --md-green-A400: #00e676;
  --md-green-A700: #00c853;
  --md-light-green-50: #f1f8e9;
  --md-light-green-100: #dcedc8;
  --md-light-green-200: #c5e1a5;
  --md-light-green-300: #aed581;
  --md-light-green-400: #9ccc65;
  --md-light-green-500: #8bc34a;
  --md-light-green-600: #7cb342;
  --md-light-green-700: #689f38;
  --md-light-green-800: #558b2f;
  --md-light-green-900: #33691e;
  --md-light-green-A100: #ccff90;
  --md-light-green-A200: #b2ff59;
  --md-light-green-A400: #76ff03;
  --md-light-green-A700: #64dd17;
  --md-lime-50: #f9fbe7;
  --md-lime-100: #f0f4c3;
  --md-lime-200: #e6ee9c;
  --md-lime-300: #dce775;
  --md-lime-400: #d4e157;
  --md-lime-500: #cddc39;
  --md-lime-600: #c0ca33;
  --md-lime-700: #afb42b;
  --md-lime-800: #9e9d24;
  --md-lime-900: #827717;
  --md-lime-A100: #f4ff81;
  --md-lime-A200: #eeff41;
  --md-lime-A400: #c6ff00;
  --md-lime-A700: #aeea00;
  --md-yellow-50: #fffde7;
  --md-yellow-100: #fff9c4;
  --md-yellow-200: #fff59d;
  --md-yellow-300: #fff176;
  --md-yellow-400: #ffee58;
  --md-yellow-500: #ffeb3b;
  --md-yellow-600: #fdd835;
  --md-yellow-700: #fbc02d;
  --md-yellow-800: #f9a825;
  --md-yellow-900: #f57f17;
  --md-yellow-A100: #ffff8d;
  --md-yellow-A200: #ff0;
  --md-yellow-A400: #ffea00;
  --md-yellow-A700: #ffd600;
  --md-amber-50: #fff8e1;
  --md-amber-100: #ffecb3;
  --md-amber-200: #ffe082;
  --md-amber-300: #ffd54f;
  --md-amber-400: #ffca28;
  --md-amber-500: #ffc107;
  --md-amber-600: #ffb300;
  --md-amber-700: #ffa000;
  --md-amber-800: #ff8f00;
  --md-amber-900: #ff6f00;
  --md-amber-A100: #ffe57f;
  --md-amber-A200: #ffd740;
  --md-amber-A400: #ffc400;
  --md-amber-A700: #ffab00;
  --md-orange-50: #fff3e0;
  --md-orange-100: #ffe0b2;
  --md-orange-200: #ffcc80;
  --md-orange-300: #ffb74d;
  --md-orange-400: #ffa726;
  --md-orange-500: #ff9800;
  --md-orange-600: #fb8c00;
  --md-orange-700: #f57c00;
  --md-orange-800: #ef6c00;
  --md-orange-900: #e65100;
  --md-orange-A100: #ffd180;
  --md-orange-A200: #ffab40;
  --md-orange-A400: #ff9100;
  --md-orange-A700: #ff6d00;
  --md-deep-orange-50: #fbe9e7;
  --md-deep-orange-100: #ffccbc;
  --md-deep-orange-200: #ffab91;
  --md-deep-orange-300: #ff8a65;
  --md-deep-orange-400: #ff7043;
  --md-deep-orange-500: #ff5722;
  --md-deep-orange-600: #f4511e;
  --md-deep-orange-700: #e64a19;
  --md-deep-orange-800: #d84315;
  --md-deep-orange-900: #bf360c;
  --md-deep-orange-A100: #ff9e80;
  --md-deep-orange-A200: #ff6e40;
  --md-deep-orange-A400: #ff3d00;
  --md-deep-orange-A700: #dd2c00;
  --md-brown-50: #efebe9;
  --md-brown-100: #d7ccc8;
  --md-brown-200: #bcaaa4;
  --md-brown-300: #a1887f;
  --md-brown-400: #8d6e63;
  --md-brown-500: #795548;
  --md-brown-600: #6d4c41;
  --md-brown-700: #5d4037;
  --md-brown-800: #4e342e;
  --md-brown-900: #3e2723;
  --md-grey-50: #fafafa;
  --md-grey-100: #f5f5f5;
  --md-grey-200: #eee;
  --md-grey-300: #e0e0e0;
  --md-grey-400: #bdbdbd;
  --md-grey-500: #9e9e9e;
  --md-grey-600: #757575;
  --md-grey-700: #616161;
  --md-grey-800: #424242;
  --md-grey-900: #212121;
  --md-blue-grey-50: #eceff1;
  --md-blue-grey-100: #cfd8dc;
  --md-blue-grey-200: #b0bec5;
  --md-blue-grey-300: #90a4ae;
  --md-blue-grey-400: #78909c;
  --md-blue-grey-500: #607d8b;
  --md-blue-grey-600: #546e7a;
  --md-blue-grey-700: #455a64;
  --md-blue-grey-800: #37474f;
  --md-blue-grey-900: #263238;
}

/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2017, Jupyter Development Team.
|
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| RenderedText
|----------------------------------------------------------------------------*/

:root {
  /* This is the padding value to fill the gaps between lines containing spans with background color. */
  --jp-private-code-span-padding: calc(
    (var(--jp-code-line-height) - 1) * var(--jp-code-font-size) / 2
  );
}

.jp-RenderedText {
  text-align: left;
  padding-left: var(--jp-code-padding);
  line-height: var(--jp-code-line-height);
  font-family: var(--jp-code-font-family);
}

.jp-RenderedText pre,
.jp-RenderedJavaScript pre,
.jp-RenderedHTMLCommon pre {
  color: var(--jp-content-font-color1);
  font-size: var(--jp-code-font-size);
  border: none;
  margin: 0;
  padding: 0;
}

.jp-RenderedText pre a:link {
  text-decoration: none;
  color: var(--jp-content-link-color);
}

.jp-RenderedText pre a:hover {
  text-decoration: underline;
  color: var(--jp-content-link-color);
}

.jp-RenderedText pre a:visited {
  text-decoration: none;
  color: var(--jp-content-link-color);
}

/* console foregrounds and backgrounds */
.jp-RenderedText pre .ansi-black-fg {
  color: #3e424d;
}

.jp-RenderedText pre .ansi-red-fg {
  color: #e75c58;
}

.jp-RenderedText pre .ansi-green-fg {
  color: #00a250;
}

.jp-RenderedText pre .ansi-yellow-fg {
  color: #ddb62b;
}

.jp-RenderedText pre .ansi-blue-fg {
  color: #208ffb;
}

.jp-RenderedText pre .ansi-magenta-fg {
  color: #d160c4;
}

.jp-RenderedText pre .ansi-cyan-fg {
  color: #60c6c8;
}

.jp-RenderedText pre .ansi-white-fg {
  color: #c5c1b4;
}

.jp-RenderedText pre .ansi-black-bg {
  background-color: #3e424d;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-red-bg {
  background-color: #e75c58;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-green-bg {
  background-color: #00a250;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-yellow-bg {
  background-color: #ddb62b;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-blue-bg {
  background-color: #208ffb;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-magenta-bg {
  background-color: #d160c4;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-cyan-bg {
  background-color: #60c6c8;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-white-bg {
  background-color: #c5c1b4;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-black-intense-fg {
  color: #282c36;
}

.jp-RenderedText pre .ansi-red-intense-fg {
  color: #b22b31;
}

.jp-RenderedText pre .ansi-green-intense-fg {
  color: #007427;
}

.jp-RenderedText pre .ansi-yellow-intense-fg {
  color: #b27d12;
}

.jp-RenderedText pre .ansi-blue-intense-fg {
  color: #0065ca;
}

.jp-RenderedText pre .ansi-magenta-intense-fg {
  color: #a03196;
}

.jp-RenderedText pre .ansi-cyan-intense-fg {
  color: #258f8f;
}

.jp-RenderedText pre .ansi-white-intense-fg {
  color: #a1a6b2;
}

.jp-RenderedText pre .ansi-black-intense-bg {
  background-color: #282c36;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-red-intense-bg {
  background-color: #b22b31;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-green-intense-bg {
  background-color: #007427;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-yellow-intense-bg {
  background-color: #b27d12;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-blue-intense-bg {
  background-color: #0065ca;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-magenta-intense-bg {
  background-color: #a03196;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-cyan-intense-bg {
  background-color: #258f8f;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-white-intense-bg {
  background-color: #a1a6b2;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-default-inverse-fg {
  color: var(--jp-ui-inverse-font-color0);
}

.jp-RenderedText pre .ansi-default-inverse-bg {
  background-color: var(--jp-inverse-layout-color0);
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-bold {
  font-weight: bold;
}

.jp-RenderedText pre .ansi-underline {
  text-decoration: underline;
}

.jp-RenderedText[data-mime-type='application/vnd.jupyter.stderr'] {
  background: var(--jp-rendermime-error-background);
  padding-top: var(--jp-code-padding);
}

/*-----------------------------------------------------------------------------
| RenderedLatex
|----------------------------------------------------------------------------*/

.jp-RenderedLatex {
  color: var(--jp-content-font-color1);
  font-size: var(--jp-content-font-size1);
  line-height: var(--jp-content-line-height);
}

/* Left-justify outputs.*/
.jp-OutputArea-output.jp-RenderedLatex {
  padding: var(--jp-code-padding);
  text-align: left;
}

/*-----------------------------------------------------------------------------
| RenderedHTML
|----------------------------------------------------------------------------*/

.jp-RenderedHTMLCommon {
  color: var(--jp-content-font-color1);
  font-family: var(--jp-content-font-family);
  font-size: var(--jp-content-font-size1);
  line-height: var(--jp-content-line-height);

  /* Give a bit more R padding on Markdown text to keep line lengths reasonable */
  padding-right: 20px;
}

.jp-RenderedHTMLCommon em {
  font-style: italic;
}

.jp-RenderedHTMLCommon strong {
  font-weight: bold;
}

.jp-RenderedHTMLCommon u {
  text-decoration: underline;
}

.jp-RenderedHTMLCommon a:link {
  text-decoration: none;
  color: var(--jp-content-link-color);
}

.jp-RenderedHTMLCommon a:hover {
  text-decoration: underline;
  color: var(--jp-content-link-color);
}

.jp-RenderedHTMLCommon a:visited {
  text-decoration: none;
  color: var(--jp-content-link-color);
}

/* Headings */

.jp-RenderedHTMLCommon h1,
.jp-RenderedHTMLCommon h2,
.jp-RenderedHTMLCommon h3,
.jp-RenderedHTMLCommon h4,
.jp-RenderedHTMLCommon h5,
.jp-RenderedHTMLCommon h6 {
  line-height: var(--jp-content-heading-line-height);
  font-weight: var(--jp-content-heading-font-weight);
  font-style: normal;
  margin: var(--jp-content-heading-margin-top) 0
    var(--jp-content-heading-margin-bottom) 0;
}

.jp-RenderedHTMLCommon h1:first-child,
.jp-RenderedHTMLCommon h2:first-child,
.jp-RenderedHTMLCommon h3:first-child,
.jp-RenderedHTMLCommon h4:first-child,
.jp-RenderedHTMLCommon h5:first-child,
.jp-RenderedHTMLCommon h6:first-child {
  margin-top: calc(0.5 * var(--jp-content-heading-margin-top));
}

.jp-RenderedHTMLCommon h1:last-child,
.jp-RenderedHTMLCommon h2:last-child,
.jp-RenderedHTMLCommon h3:last-child,
.jp-RenderedHTMLCommon h4:last-child,
.jp-RenderedHTMLCommon h5:last-child,
.jp-RenderedHTMLCommon h6:last-child {
  margin-bottom: calc(0.5 * var(--jp-content-heading-margin-bottom));
}

.jp-RenderedHTMLCommon h1 {
  font-size: var(--jp-content-font-size5);
}

.jp-RenderedHTMLCommon h2 {
  font-size: var(--jp-content-font-size4);
}

.jp-RenderedHTMLCommon h3 {
  font-size: var(--jp-content-font-size3);
}

.jp-RenderedHTMLCommon h4 {
  font-size: var(--jp-content-font-size2);
}

.jp-RenderedHTMLCommon h5 {
  font-size: var(--jp-content-font-size1);
}

.jp-RenderedHTMLCommon h6 {
  font-size: var(--jp-content-font-size0);
}

/* Lists */

/* stylelint-disable selector-max-type, selector-max-compound-selectors */

.jp-RenderedHTMLCommon ul:not(.list-inline),
.jp-RenderedHTMLCommon ol:not(.list-inline) {
  padding-left: 2em;
}

.jp-RenderedHTMLCommon ul {
  list-style: disc;
}

.jp-RenderedHTMLCommon ul ul {
  list-style: square;
}

.jp-RenderedHTMLCommon ul ul ul {
  list-style: circle;
}

.jp-RenderedHTMLCommon ol {
  list-style: decimal;
}

.jp-RenderedHTMLCommon ol ol {
  list-style: upper-alpha;
}

.jp-RenderedHTMLCommon ol ol ol {
  list-style: lower-alpha;
}

.jp-RenderedHTMLCommon ol ol ol ol {
  list-style: lower-roman;
}

.jp-RenderedHTMLCommon ol ol ol ol ol {
  list-style: decimal;
}

.jp-RenderedHTMLCommon ol,
.jp-RenderedHTMLCommon ul {
  margin-bottom: 1em;
}

.jp-RenderedHTMLCommon ul ul,
.jp-RenderedHTMLCommon ul ol,
.jp-RenderedHTMLCommon ol ul,
.jp-RenderedHTMLCommon ol ol {
  margin-bottom: 0;
}

/* stylelint-enable selector-max-type, selector-max-compound-selectors */

.jp-RenderedHTMLCommon hr {
  color: var(--jp-border-color2);
  background-color: var(--jp-border-color1);
  margin-top: 1em;
  margin-bottom: 1em;
}

.jp-RenderedHTMLCommon > pre {
  margin: 1.5em 2em;
}

.jp-RenderedHTMLCommon pre,
.jp-RenderedHTMLCommon code {
  border: 0;
  background-color: var(--jp-layout-color0);
  color: var(--jp-content-font-color1);
  font-family: var(--jp-code-font-family);
  font-size: inherit;
  line-height: var(--jp-code-line-height);
  padding: 0;
  white-space: pre-wrap;
}

.jp-RenderedHTMLCommon :not(pre) > code {
  background-color: var(--jp-layout-color2);
  padding: 1px 5px;
}

/* Tables */

.jp-RenderedHTMLCommon table {
  border-collapse: collapse;
  border-spacing: 0;
  border: none;
  color: var(--jp-ui-font-color1);
  font-size: var(--jp-ui-font-size1);
  table-layout: fixed;
  margin-left: auto;
  margin-bottom: 1em;
  margin-right: auto;
}

.jp-RenderedHTMLCommon thead {
  border-bottom: var(--jp-border-width) solid var(--jp-border-color1);
  vertical-align: bottom;
}

.jp-RenderedHTMLCommon td,
.jp-RenderedHTMLCommon th,
.jp-RenderedHTMLCommon tr {
  vertical-align: middle;
  padding: 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}

.jp-RenderedMarkdown.jp-RenderedHTMLCommon td,
.jp-RenderedMarkdown.jp-RenderedHTMLCommon th {
  max-width: none;
}

:not(.jp-RenderedMarkdown).jp-RenderedHTMLCommon td,
:not(.jp-RenderedMarkdown).jp-RenderedHTMLCommon th,
:not(.jp-RenderedMarkdown).jp-RenderedHTMLCommon tr {
  text-align: right;
}

.jp-RenderedHTMLCommon th {
  font-weight: bold;
}

.jp-RenderedHTMLCommon tbody tr:nth-child(odd) {
  background: var(--jp-layout-color0);
}

.jp-RenderedHTMLCommon tbody tr:nth-child(even) {
  background: var(--jp-rendermime-table-row-background);
}

.jp-RenderedHTMLCommon tbody tr:hover {
  background: var(--jp-rendermime-table-row-hover-background);
}

.jp-RenderedHTMLCommon p {
  text-align: left;
  margin: 0;
  margin-bottom: 1em;
}

.jp-RenderedHTMLCommon img {
  -moz-force-broken-image-icon: 1;
}

/* Restrict to direct children as other images could be nested in other content. */
.jp-RenderedHTMLCommon > img {
  display: block;
  margin-left: 0;
  margin-right: 0;
  margin-bottom: 1em;
}

/* Change color behind transparent images if they need it... */
[data-jp-theme-light='false'] .jp-RenderedImage img.jp-needs-light-background {
  background-color: var(--jp-inverse-layout-color1);
}

[data-jp-theme-light='true'] .jp-RenderedImage img.jp-needs-dark-background {
  background-color: var(--jp-inverse-layout-color1);
}

.jp-RenderedHTMLCommon img,
.jp-RenderedImage img,
.jp-RenderedHTMLCommon svg,
.jp-RenderedSVG svg {
  max-width: 100%;
  height: auto;
}

.jp-RenderedHTMLCommon img.jp-mod-unconfined,
.jp-RenderedImage img.jp-mod-unconfined,
.jp-RenderedHTMLCommon svg.jp-mod-unconfined,
.jp-RenderedSVG svg.jp-mod-unconfined {
  max-width: none;
}

.jp-RenderedHTMLCommon .alert {
  padding: var(--jp-notebook-padding);
  border: var(--jp-border-width) solid transparent;
  border-radius: var(--jp-border-radius);
  margin-bottom: 1em;
}

.jp-RenderedHTMLCommon .alert-info {
  color: var(--jp-info-color0);
  background-color: var(--jp-info-color3);
  border-color: var(--jp-info-color2);
}

.jp-RenderedHTMLCommon .alert-info hr {
  border-color: var(--jp-info-color3);
}

.jp-RenderedHTMLCommon .alert-info > p:last-child,
.jp-RenderedHTMLCommon .alert-info > ul:last-child {
  margin-bottom: 0;
}

.jp-RenderedHTMLCommon .alert-warning {
  color: var(--jp-warn-color0);
  background-color: var(--jp-warn-color3);
  border-color: var(--jp-warn-color2);
}

.jp-RenderedHTMLCommon .alert-warning hr {
  border-color: var(--jp-warn-color3);
}

.jp-RenderedHTMLCommon .alert-warning > p:last-child,
.jp-RenderedHTMLCommon .alert-warning > ul:last-child {
  margin-bottom: 0;
}

.jp-RenderedHTMLCommon .alert-success {
  color: var(--jp-success-color0);
  background-color: var(--jp-success-color3);
  border-color: var(--jp-success-color2);
}

.jp-RenderedHTMLCommon .alert-success hr {
  border-color: var(--jp-success-color3);
}

.jp-RenderedHTMLCommon .alert-success > p:last-child,
.jp-RenderedHTMLCommon .alert-success > ul:last-child {
  margin-bottom: 0;
}

.jp-RenderedHTMLCommon .alert-danger {
  color: var(--jp-error-color0);
  background-color: var(--jp-error-color3);
  border-color: var(--jp-error-color2);
}

.jp-RenderedHTMLCommon .alert-danger hr {
  border-color: var(--jp-error-color3);
}

.jp-RenderedHTMLCommon .alert-danger > p:last-child,
.jp-RenderedHTMLCommon .alert-danger > ul:last-child {
  margin-bottom: 0;
}

.jp-RenderedHTMLCommon blockquote {
  margin: 1em 2em;
  padding: 0 1em;
  border-left: 5px solid var(--jp-border-color2);
}

a.jp-InternalAnchorLink {
  visibility: hidden;
  margin-left: 8px;
  color: var(--md-blue-800);
}

h1:hover .jp-InternalAnchorLink,
h2:hover .jp-InternalAnchorLink,
h3:hover .jp-InternalAnchorLink,
h4:hover .jp-InternalAnchorLink,
h5:hover .jp-InternalAnchorLink,
h6:hover .jp-InternalAnchorLink {
  visibility: visible;
}

.jp-RenderedHTMLCommon kbd {
  background-color: var(--jp-rendermime-table-row-background);
  border: 1px solid var(--jp-border-color0);
  border-bottom-color: var(--jp-border-color2);
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 rgba(0, 0, 0, 0.25);
  display: inline-block;
  font-size: var(--jp-ui-font-size0);
  line-height: 1em;
  padding: 0.2em 0.5em;
}

/* Most direct children of .jp-RenderedHTMLCommon have a margin-bottom of 1.0.
 * At the bottom of cells this is a bit too much as there is also spacing
 * between cells. Going all the way to 0 gets too tight between markdown and
 * code cells.
 */
.jp-RenderedHTMLCommon > *:last-child {
  margin-bottom: 0.5em;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-cursor-backdrop {
  position: fixed;
  width: 200px;
  height: 200px;
  margin-top: -100px;
  margin-left: -100px;
  will-change: transform;
  z-index: 100;
}

.lm-mod-drag-image {
  will-change: transform;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

.jp-lineFormSearch {
  padding: 4px 12px;
  background-color: var(--jp-layout-color2);
  box-shadow: var(--jp-toolbar-box-shadow);
  z-index: 2;
  font-size: var(--jp-ui-font-size1);
}

.jp-lineFormCaption {
  font-size: var(--jp-ui-font-size0);
  line-height: var(--jp-ui-font-size1);
  margin-top: 4px;
  color: var(--jp-ui-font-color0);
}

.jp-baseLineForm {
  border: none;
  border-radius: 0;
  position: absolute;
  background-size: 16px;
  background-repeat: no-repeat;
  background-position: center;
  outline: none;
}

.jp-lineFormButtonContainer {
  top: 4px;
  right: 8px;
  height: 24px;
  padding: 0 12px;
  width: 12px;
}

.jp-lineFormButtonIcon {
  top: 0;
  right: 0;
  background-color: var(--jp-brand-color1);
  height: 100%;
  width: 100%;
  box-sizing: border-box;
  padding: 4px 6px;
}

.jp-lineFormButton {
  top: 0;
  right: 0;
  background-color: transparent;
  height: 100%;
  width: 100%;
  box-sizing: border-box;
}

.jp-lineFormWrapper {
  overflow: hidden;
  padding: 0 8px;
  border: 1px solid var(--jp-border-color0);
  background-color: var(--jp-input-active-background);
  height: 22px;
}

.jp-lineFormWrapperFocusWithin {
  border: var(--jp-border-width) solid var(--md-blue-500);
  box-shadow: inset 0 0 4px var(--md-blue-300);
}

.jp-lineFormInput {
  background: transparent;
  width: 200px;
  height: 100%;
  border: none;
  outline: none;
  color: var(--jp-ui-font-color0);
  line-height: 28px;
}

/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2016, Jupyter Development Team.
|
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-JSONEditor {
  display: flex;
  flex-direction: column;
  width: 100%;
}

.jp-JSONEditor-host {
  flex: 1 1 auto;
  border: var(--jp-border-width) solid var(--jp-input-border-color);
  border-radius: 0;
  background: var(--jp-layout-color0);
  min-height: 50px;
  padding: 1px;
}

.jp-JSONEditor.jp-mod-error .jp-JSONEditor-host {
  border-color: red;
  outline-color: red;
}

.jp-JSONEditor-header {
  display: flex;
  flex: 1 0 auto;
  padding: 0 0 0 12px;
}

.jp-JSONEditor-header label {
  flex: 0 0 auto;
}

.jp-JSONEditor-commitButton {
  height: 16px;
  width: 16px;
  background-size: 18px;
  background-repeat: no-repeat;
  background-position: center;
}

.jp-JSONEditor-host.jp-mod-focused {
  background-color: var(--jp-input-active-background);
  border: 1px solid var(--jp-input-active-border-color);
  box-shadow: var(--jp-input-box-shadow);
}

.jp-Editor.jp-mod-dropTarget {
  border: var(--jp-border-width) solid var(--jp-input-active-border-color);
  box-shadow: var(--jp-input-box-shadow);
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/
.jp-DocumentSearch-input {
  border: none;
  outline: none;
  color: var(--jp-ui-font-color0);
  font-size: var(--jp-ui-font-size1);
  background-color: var(--jp-layout-color0);
  font-family: var(--jp-ui-font-family);
  padding: 2px 1px;
  resize: none;
}

.jp-DocumentSearch-overlay {
  position: absolute;
  background-color: var(--jp-toolbar-background);
  border-bottom: var(--jp-border-width) solid var(--jp-toolbar-border-color);
  border-left: var(--jp-border-width) solid var(--jp-toolbar-border-color);
  top: 0;
  right: 0;
  z-index: 7;
  min-width: 405px;
  padding: 2px;
  font-size: var(--jp-ui-font-size1);

  --jp-private-document-search-button-height: 20px;
}

.jp-DocumentSearch-overlay button {
  background-color: var(--jp-toolbar-background);
  outline: 0;
}

.jp-DocumentSearch-overlay button:hover {
  background-color: var(--jp-layout-color2);
}

.jp-DocumentSearch-overlay button:active {
  background-color: var(--jp-layout-color3);
}

.jp-DocumentSearch-overlay-row {
  display: flex;
  align-items: center;
  margin-bottom: 2px;
}

.jp-DocumentSearch-button-content {
  display: inline-block;
  cursor: pointer;
  box-sizing: border-box;
  width: 100%;
  height: 100%;
}

.jp-DocumentSearch-button-content svg {
  width: 100%;
  height: 100%;
}

.jp-DocumentSearch-input-wrapper {
  border: var(--jp-border-width) solid var(--jp-border-color0);
  display: flex;
  background-color: var(--jp-layout-color0);
  margin: 2px;
}

.jp-DocumentSearch-input-wrapper:focus-within {
  border-color: var(--jp-cell-editor-active-border-color);
}

.jp-DocumentSearch-toggle-wrapper,
.jp-DocumentSearch-button-wrapper {
  all: initial;
  overflow: hidden;
  display: inline-block;
  border: none;
  box-sizing: border-box;
}

.jp-DocumentSearch-toggle-wrapper {
  width: 14px;
  height: 14px;
}

.jp-DocumentSearch-button-wrapper {
  width: var(--jp-private-document-search-button-height);
  height: var(--jp-private-document-search-button-height);
}

.jp-DocumentSearch-toggle-wrapper:focus,
.jp-DocumentSearch-button-wrapper:focus {
  outline: var(--jp-border-width) solid
    var(--jp-cell-editor-active-border-color);
  outline-offset: -1px;
}

.jp-DocumentSearch-toggle-wrapper,
.jp-DocumentSearch-button-wrapper,
.jp-DocumentSearch-button-content:focus {
  outline: none;
}

.jp-DocumentSearch-toggle-placeholder {
  width: 5px;
}

.jp-DocumentSearch-input-button::before {
  display: block;
  padding-top: 100%;
}

.jp-DocumentSearch-input-button-off {
  opacity: var(--jp-search-toggle-off-opacity);
}

.jp-DocumentSearch-input-button-off:hover {
  opacity: var(--jp-search-toggle-hover-opacity);
}

.jp-DocumentSearch-input-button-on {
  opacity: var(--jp-search-toggle-on-opacity);
}

.jp-DocumentSearch-index-counter {
  padding-left: 10px;
  padding-right: 10px;
  user-select: none;
  min-width: 35px;
  display: inline-block;
}

.jp-DocumentSearch-up-down-wrapper {
  display: inline-block;
  padding-right: 2px;
  margin-left: auto;
  white-space: nowrap;
}

.jp-DocumentSearch-spacer {
  margin-left: auto;
}

.jp-DocumentSearch-up-down-wrapper button {
  outline: 0;
  border: none;
  width: var(--jp-private-document-search-button-height);
  height: var(--jp-private-document-search-button-height);
  vertical-align: middle;
  margin: 1px 5px 2px;
}

.jp-DocumentSearch-up-down-button:hover {
  background-color: var(--jp-layout-color2);
}

.jp-DocumentSearch-up-down-button:active {
  background-color: var(--jp-layout-color3);
}

.jp-DocumentSearch-filter-button {
  border-radius: var(--jp-border-radius);
}

.jp-DocumentSearch-filter-button:hover {
  background-color: var(--jp-layout-color2);
}

.jp-DocumentSearch-filter-button-enabled {
  background-color: var(--jp-layout-color2);
}

.jp-DocumentSearch-filter-button-enabled:hover {
  background-color: var(--jp-layout-color3);
}

.jp-DocumentSearch-search-options {
  padding: 0 8px;
  margin-left: 3px;
  width: 100%;
  display: grid;
  justify-content: start;
  grid-template-columns: 1fr 1fr;
  align-items: center;
  justify-items: stretch;
}

.jp-DocumentSearch-search-filter-disabled {
  color: var(--jp-ui-font-color2);
}

.jp-DocumentSearch-search-filter {
  display: flex;
  align-items: center;
  user-select: none;
}

.jp-DocumentSearch-regex-error {
  color: var(--jp-error-color0);
}

.jp-DocumentSearch-replace-button-wrapper {
  overflow: hidden;
  display: inline-block;
  box-sizing: border-box;
  border: var(--jp-border-width) solid var(--jp-border-color0);
  margin: auto 2px;
  padding: 1px 4px;
  height: calc(var(--jp-private-document-search-button-height) + 2px);
}

.jp-DocumentSearch-replace-button-wrapper:focus {
  border: var(--jp-border-width) solid var(--jp-cell-editor-active-border-color);
}

.jp-DocumentSearch-replace-button {
  display: inline-block;
  text-align: center;
  cursor: pointer;
  box-sizing: border-box;
  color: var(--jp-ui-font-color1);

  /* height - 2 * (padding of wrapper) */
  line-height: calc(var(--jp-private-document-search-button-height) - 2px);
  width: 100%;
  height: 100%;
}

.jp-DocumentSearch-replace-button:focus {
  outline: none;
}

.jp-DocumentSearch-replace-wrapper-class {
  margin-left: 14px;
  display: flex;
}

.jp-DocumentSearch-replace-toggle {
  border: none;
  background-color: var(--jp-toolbar-background);
  border-radius: var(--jp-border-radius);
}

.jp-DocumentSearch-replace-toggle:hover {
  background-color: var(--jp-layout-color2);
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.cm-editor {
  line-height: var(--jp-code-line-height);
  font-size: var(--jp-code-font-size);
  font-family: var(--jp-code-font-family);
  border: 0;
  border-radius: 0;
  height: auto;

  /* Changed to auto to autogrow */
}

.cm-editor pre {
  padding: 0 var(--jp-code-padding);
}

.jp-CodeMirrorEditor[data-type='inline'] .cm-dialog {
  background-color: var(--jp-layout-color0);
  color: var(--jp-content-font-color1);
}

.jp-CodeMirrorEditor {
  cursor: text;
}

/* When zoomed out 67% and 33% on a screen of 1440 width x 900 height */
@media screen and (min-width: 2138px) and (max-width: 4319px) {
  .jp-CodeMirrorEditor[data-type='inline'] .cm-cursor {
    border-left: var(--jp-code-cursor-width1) solid
      var(--jp-editor-cursor-color);
  }
}

/* When zoomed out less than 33% */
@media screen and (min-width: 4320px) {
  .jp-CodeMirrorEditor[data-type='inline'] .cm-cursor {
    border-left: var(--jp-code-cursor-width2) solid
      var(--jp-editor-cursor-color);
  }
}

.cm-editor.jp-mod-readOnly .cm-cursor {
  display: none;
}

.jp-CollaboratorCursor {
  border-left: 5px solid transparent;
  border-right: 5px solid transparent;
  border-top: none;
  border-bottom: 3px solid;
  background-clip: content-box;
  margin-left: -5px;
  margin-right: -5px;
}

.cm-searching,
.cm-searching span {
  /* `.cm-searching span`: we need to override syntax highlighting */
  background-color: var(--jp-search-unselected-match-background-color);
  color: var(--jp-search-unselected-match-color);
}

.cm-searching::selection,
.cm-searching span::selection {
  background-color: var(--jp-search-unselected-match-background-color);
  color: var(--jp-search-unselected-match-color);
}

.jp-current-match > .cm-searching,
.jp-current-match > .cm-searching span,
.cm-searching > .jp-current-match,
.cm-searching > .jp-current-match span {
  background-color: var(--jp-search-selected-match-background-color);
  color: var(--jp-search-selected-match-color);
}

.jp-current-match > .cm-searching::selection,
.cm-searching > .jp-current-match::selection,
.jp-current-match > .cm-searching span::selection {
  background-color: var(--jp-search-selected-match-background-color);
  color: var(--jp-search-selected-match-color);
}

.cm-trailingspace {
  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAYAAAB4ka1VAAAAsElEQVQIHQGlAFr/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA7+r3zKmT0/+pk9P/7+r3zAAAAAAAAAAABAAAAAAAAAAA6OPzM+/q9wAAAAAA6OPzMwAAAAAAAAAAAgAAAAAAAAAAGR8NiRQaCgAZIA0AGR8NiQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQyoYJ/SY80UAAAAASUVORK5CYII=);
  background-position: center left;
  background-repeat: repeat-x;
}

.jp-CollaboratorCursor-hover {
  position: absolute;
  z-index: 1;
  transform: translateX(-50%);
  color: white;
  border-radius: 3px;
  padding-left: 4px;
  padding-right: 4px;
  padding-top: 1px;
  padding-bottom: 1px;
  text-align: center;
  font-size: var(--jp-ui-font-size1);
  white-space: nowrap;
}

.jp-CodeMirror-ruler {
  border-left: 1px dashed var(--jp-border-color2);
}

/* Styles for shared cursors (remote cursor locations and selected ranges) */
.jp-CodeMirrorEditor .cm-ySelectionCaret {
  position: relative;
  border-left: 1px solid black;
  margin-left: -1px;
  margin-right: -1px;
  box-sizing: border-box;
}

.jp-CodeMirrorEditor .cm-ySelectionCaret > .cm-ySelectionInfo {
  white-space: nowrap;
  position: absolute;
  top: -1.15em;
  padding-bottom: 0.05em;
  left: -1px;
  font-size: 0.95em;
  font-family: var(--jp-ui-font-family);
  font-weight: bold;
  line-height: normal;
  user-select: none;
  color: white;
  padding-left: 2px;
  padding-right: 2px;
  z-index: 101;
  transition: opacity 0.3s ease-in-out;
}

.jp-CodeMirrorEditor .cm-ySelectionInfo {
  transition-delay: 0.7s;
  opacity: 0;
}

.jp-CodeMirrorEditor .cm-ySelectionCaret:hover > .cm-ySelectionInfo {
  opacity: 1;
  transition-delay: 0s;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-MimeDocument {
  outline: none;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Variables
|----------------------------------------------------------------------------*/

:root {
  --jp-private-filebrowser-button-height: 28px;
  --jp-private-filebrowser-button-width: 48px;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-FileBrowser .jp-SidePanel-content {
  display: flex;
  flex-direction: column;
}

.jp-FileBrowser-toolbar.jp-Toolbar {
  flex-wrap: wrap;
  row-gap: 12px;
  border-bottom: none;
  height: auto;
  margin: 8px 12px 0;
  box-shadow: none;
  padding: 0;
  justify-content: flex-start;
}

.jp-FileBrowser-Panel {
  flex: 1 1 auto;
  display: flex;
  flex-direction: column;
}

.jp-BreadCrumbs {
  flex: 0 0 auto;
  margin: 8px 12px;
}

.jp-BreadCrumbs-item {
  margin: 0 2px;
  padding: 0 2px;
  border-radius: var(--jp-border-radius);
  cursor: pointer;
}

.jp-BreadCrumbs-item:hover {
  background-color: var(--jp-layout-color2);
}

.jp-BreadCrumbs-item:first-child {
  margin-left: 0;
}

.jp-BreadCrumbs-item.jp-mod-dropTarget {
  background-color: var(--jp-brand-color2);
  opacity: 0.7;
}

/*-----------------------------------------------------------------------------
| Buttons
|----------------------------------------------------------------------------*/

.jp-FileBrowser-toolbar > .jp-Toolbar-item {
  flex: 0 0 auto;
  padding-left: 0;
  padding-right: 2px;
  align-items: center;
  height: unset;
}

.jp-FileBrowser-toolbar > .jp-Toolbar-item .jp-ToolbarButtonComponent {
  width: 40px;
}

/*-----------------------------------------------------------------------------
| Other styles
|----------------------------------------------------------------------------*/

.jp-FileDialog.jp-mod-conflict input {
  color: var(--jp-error-color1);
}

.jp-FileDialog .jp-new-name-title {
  margin-top: 12px;
}

.jp-LastModified-hidden {
  display: none;
}

.jp-FileSize-hidden {
  display: none;
}

.jp-FileBrowser .lm-AccordionPanel > h3:first-child {
  display: none;
}

/*-----------------------------------------------------------------------------
| DirListing
|----------------------------------------------------------------------------*/

.jp-DirListing {
  flex: 1 1 auto;
  display: flex;
  flex-direction: column;
  outline: 0;
}

.jp-DirListing-header {
  flex: 0 0 auto;
  display: flex;
  flex-direction: row;
  align-items: center;
  overflow: hidden;
  border-top: var(--jp-border-width) solid var(--jp-border-color2);
  border-bottom: var(--jp-border-width) solid var(--jp-border-color1);
  box-shadow: var(--jp-toolbar-box-shadow);
  z-index: 2;
}

.jp-DirListing-headerItem {
  padding: 4px 12px 2px;
  font-weight: 500;
}

.jp-DirListing-headerItem:hover {
  background: var(--jp-layout-color2);
}

.jp-DirListing-headerItem.jp-id-name {
  flex: 1 0 84px;
}

.jp-DirListing-headerItem.jp-id-modified {
  flex: 0 0 112px;
  border-left: var(--jp-border-width) solid var(--jp-border-color2);
  text-align: right;
}

.jp-DirListing-headerItem.jp-id-filesize {
  flex: 0 0 75px;
  border-left: var(--jp-border-width) solid var(--jp-border-color2);
  text-align: right;
}

.jp-id-narrow {
  display: none;
  flex: 0 0 5px;
  padding: 4px;
  border-left: var(--jp-border-width) solid var(--jp-border-color2);
  text-align: right;
  color: var(--jp-border-color2);
}

.jp-DirListing-narrow .jp-id-narrow {
  display: block;
}

.jp-DirListing-narrow .jp-id-modified,
.jp-DirListing-narrow .jp-DirListing-itemModified {
  display: none;
}

.jp-DirListing-headerItem.jp-mod-selected {
  font-weight: 600;
}

/* increase specificity to override bundled default */
.jp-DirListing-content {
  flex: 1 1 auto;
  margin: 0;
  padding: 0;
  list-style-type: none;
  overflow: auto;
  background-color: var(--jp-layout-color1);
}

.jp-DirListing-content mark {
  color: var(--jp-ui-font-color0);
  background-color: transparent;
  font-weight: bold;
}

.jp-DirListing-content .jp-DirListing-item.jp-mod-selected mark {
  color: var(--jp-ui-inverse-font-color0);
}

/* Style the directory listing content when a user drops a file to upload */
.jp-DirListing.jp-mod-native-drop .jp-DirListing-content {
  outline: 5px dashed rgba(128, 128, 128, 0.5);
  outline-offset: -10px;
  cursor: copy;
}

.jp-DirListing-item {
  display: flex;
  flex-direction: row;
  align-items: center;
  padding: 4px 12px;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.jp-DirListing-checkboxWrapper {
  /* Increases hit area of checkbox. */
  padding: 4px;
}

.jp-DirListing-header
  .jp-DirListing-checkboxWrapper
  + .jp-DirListing-headerItem {
  padding-left: 4px;
}

.jp-DirListing-content .jp-DirListing-checkboxWrapper {
  position: relative;
  left: -4px;
  margin: -4px 0 -4px -8px;
}

.jp-DirListing-checkboxWrapper.jp-mod-visible {
  visibility: visible;
}

/* For devices that support hovering, hide checkboxes until hovered, selected...
*/
@media (hover: hover) {
  .jp-DirListing-checkboxWrapper {
    visibility: hidden;
  }

  .jp-DirListing-item:hover .jp-DirListing-checkboxWrapper,
  .jp-DirListing-item.jp-mod-selected .jp-DirListing-checkboxWrapper {
    visibility: visible;
  }
}

.jp-DirListing-item[data-is-dot] {
  opacity: 75%;
}

.jp-DirListing-item.jp-mod-selected {
  color: var(--jp-ui-inverse-font-color1);
  background: var(--jp-brand-color1);
}

.jp-DirListing-item.jp-mod-dropTarget {
  background: var(--jp-brand-color3);
}

.jp-DirListing-item:hover:not(.jp-mod-selected) {
  background: var(--jp-layout-color2);
}

.jp-DirListing-itemIcon {
  flex: 0 0 20px;
  margin-right: 4px;
}

.jp-DirListing-itemText {
  flex: 1 0 64px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  user-select: none;
}

.jp-DirListing-itemText:focus {
  outline-width: 2px;
  outline-color: var(--jp-inverse-layout-color1);
  outline-style: solid;
  outline-offset: 1px;
}

.jp-DirListing-item.jp-mod-selected .jp-DirListing-itemText:focus {
  outline-color: var(--jp-layout-color1);
}

.jp-DirListing-itemModified {
  flex: 0 0 125px;
  text-align: right;
}

.jp-DirListing-itemFileSize {
  flex: 0 0 90px;
  text-align: right;
}

.jp-DirListing-editor {
  flex: 1 0 64px;
  outline: none;
  border: none;
  color: var(--jp-ui-font-color1);
  background-color: var(--jp-layout-color1);
}

.jp-DirListing-item.jp-mod-running .jp-DirListing-itemIcon::before {
  color: var(--jp-success-color1);
  content: '\25CF';
  font-size: 8px;
  position: absolute;
  left: -8px;
}

.jp-DirListing-item.jp-mod-running.jp-mod-selected
  .jp-DirListing-itemIcon::before {
  color: var(--jp-ui-inverse-font-color1);
}

.jp-DirListing-item.lm-mod-drag-image,
.jp-DirListing-item.jp-mod-selected.lm-mod-drag-image {
  font-size: var(--jp-ui-font-size1);
  padding-left: 4px;
  margin-left: 4px;
  width: 160px;
  background-color: var(--jp-ui-inverse-font-color2);
  box-shadow: var(--jp-elevation-z2);
  border-radius: 0;
  color: var(--jp-ui-font-color1);
  transform: translateX(-40%) translateY(-58%);
}

.jp-Document {
  min-width: 120px;
  min-height: 120px;
  outline: none;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Main OutputArea
| OutputArea has a list of Outputs
|----------------------------------------------------------------------------*/

.jp-OutputArea {
  overflow-y: auto;
}

.jp-OutputArea-child {
  display: table;
  table-layout: fixed;
  width: 100%;
  overflow: hidden;
}

.jp-OutputPrompt {
  width: var(--jp-cell-prompt-width);
  color: var(--jp-cell-outprompt-font-color);
  font-family: var(--jp-cell-prompt-font-family);
  padding: var(--jp-code-padding);
  letter-spacing: var(--jp-cell-prompt-letter-spacing);
  line-height: var(--jp-code-line-height);
  font-size: var(--jp-code-font-size);
  border: var(--jp-border-width) solid transparent;
  opacity: var(--jp-cell-prompt-opacity);

  /* Right align prompt text, don't wrap to handle large prompt numbers */
  text-align: right;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;

  /* Disable text selection */
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.jp-OutputArea-prompt {
  display: table-cell;
  vertical-align: top;
}

.jp-OutputArea-output {
  display: table-cell;
  width: 100%;
  height: auto;
  overflow: auto;
  user-select: text;
  -moz-user-select: text;
  -webkit-user-select: text;
  -ms-user-select: text;
}

.jp-OutputArea .jp-RenderedText {
  padding-left: 1ch;
}

/**
 * Prompt overlay.
 */

.jp-OutputArea-promptOverlay {
  position: absolute;
  top: 0;
  width: var(--jp-cell-prompt-width);
  height: 100%;
  opacity: 0.5;
}

.jp-OutputArea-promptOverlay:hover {
  background: var(--jp-layout-color2);
  box-shadow: inset 0 0 1px var(--jp-inverse-layout-color0);
  cursor: zoom-out;
}

.jp-mod-outputsScrolled .jp-OutputArea-promptOverlay:hover {
  cursor: zoom-in;
}

/**
 * Isolated output.
 */
.jp-OutputArea-output.jp-mod-isolated {
  width: 100%;
  display: block;
}

/*
When drag events occur, `lm-mod-override-cursor` is added to the body.
Because iframes steal all cursor events, the following two rules are necessary
to suppress pointer events while resize drags are occurring. There may be a
better solution to this problem.
*/
body.lm-mod-override-cursor .jp-OutputArea-output.jp-mod-isolated {
  position: relative;
}

body.lm-mod-override-cursor .jp-OutputArea-output.jp-mod-isolated::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: transparent;
}

/* pre */

.jp-OutputArea-output pre {
  border: none;
  margin: 0;
  padding: 0;
  overflow-x: auto;
  overflow-y: auto;
  word-break: break-all;
  word-wrap: break-word;
  white-space: pre-wrap;
}

/* tables */

.jp-OutputArea-output.jp-RenderedHTMLCommon table {
  margin-left: 0;
  margin-right: 0;
}

/* description lists */

.jp-OutputArea-output dl,
.jp-OutputArea-output dt,
.jp-OutputArea-output dd {
  display: block;
}

.jp-OutputArea-output dl {
  width: 100%;
  overflow: hidden;
  padding: 0;
  margin: 0;
}

.jp-OutputArea-output dt {
  font-weight: bold;
  float: left;
  width: 20%;
  padding: 0;
  margin: 0;
}

.jp-OutputArea-output dd {
  float: left;
  width: 80%;
  padding: 0;
  margin: 0;
}

.jp-TrimmedOutputs pre {
  background: var(--jp-layout-color3);
  font-size: calc(var(--jp-code-font-size) * 1.4);
  text-align: center;
  text-transform: uppercase;
}

/* Hide the gutter in case of
 *  - nested output areas (e.g. in the case of output widgets)
 *  - mirrored output areas
 */
.jp-OutputArea .jp-OutputArea .jp-OutputArea-prompt {
  display: none;
}

/* Hide empty lines in the output area, for instance due to cleared widgets */
.jp-OutputArea-prompt:empty {
  padding: 0;
  border: 0;
}

/*-----------------------------------------------------------------------------
| executeResult is added to any Output-result for the display of the object
| returned by a cell
|----------------------------------------------------------------------------*/

.jp-OutputArea-output.jp-OutputArea-executeResult {
  margin-left: 0;
  width: 100%;
}

/* Text output with the Out[] prompt needs a top padding to match the
 * alignment of the Out[] prompt itself.
 */
.jp-OutputArea-executeResult .jp-RenderedText.jp-OutputArea-output {
  padding-top: var(--jp-code-padding);
  border-top: var(--jp-border-width) solid transparent;
}

/*-----------------------------------------------------------------------------
| The Stdin output
|----------------------------------------------------------------------------*/

.jp-Stdin-prompt {
  color: var(--jp-content-font-color0);
  padding-right: var(--jp-code-padding);
  vertical-align: baseline;
  flex: 0 0 auto;
}

.jp-Stdin-input {
  font-family: var(--jp-code-font-family);
  font-size: inherit;
  color: inherit;
  background-color: inherit;
  width: 42%;
  min-width: 200px;

  /* make sure input baseline aligns with prompt */
  vertical-align: baseline;

  /* padding + margin = 0.5em between prompt and cursor */
  padding: 0 0.25em;
  margin: 0 0.25em;
  flex: 0 0 70%;
}

.jp-Stdin-input::placeholder {
  opacity: 0;
}

.jp-Stdin-input:focus {
  box-shadow: none;
}

.jp-Stdin-input:focus::placeholder {
  opacity: 1;
}

/*-----------------------------------------------------------------------------
| Output Area View
|----------------------------------------------------------------------------*/

.jp-LinkedOutputView .jp-OutputArea {
  height: 100%;
  display: block;
}

.jp-LinkedOutputView .jp-OutputArea-output:only-child {
  height: 100%;
}

/*-----------------------------------------------------------------------------
| Printing
|----------------------------------------------------------------------------*/

@media print {
  .jp-OutputArea-child {
    break-inside: avoid-page;
  }
}

/*-----------------------------------------------------------------------------
| Mobile
|----------------------------------------------------------------------------*/
@media only screen and (max-width: 760px) {
  .jp-OutputPrompt {
    display: table-row;
    text-align: left;
  }

  .jp-OutputArea-child .jp-OutputArea-output {
    display: table-row;
    margin-left: var(--jp-notebook-padding);
  }
}

/* Trimmed outputs warning */
.jp-TrimmedOutputs > a {
  margin: 10px;
  text-decoration: none;
  cursor: pointer;
}

.jp-TrimmedOutputs > a:hover {
  text-decoration: none;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Table of Contents
|----------------------------------------------------------------------------*/

:root {
  --jp-private-toc-active-width: 4px;
}

.jp-TableOfContents {
  display: flex;
  flex-direction: column;
  background: var(--jp-layout-color1);
  color: var(--jp-ui-font-color1);
  font-size: var(--jp-ui-font-size1);
  height: 100%;
}

.jp-TableOfContents-placeholder {
  text-align: center;
}

.jp-TableOfContents-placeholderContent {
  color: var(--jp-content-font-color2);
  padding: 8px;
}

.jp-TableOfContents-placeholderContent > h3 {
  margin-bottom: var(--jp-content-heading-margin-bottom);
}

.jp-TableOfContents .jp-SidePanel-content {
  overflow-y: auto;
}

.jp-TableOfContents-tree {
  margin: 4px;
}

.jp-TableOfContents ol {
  list-style-type: none;
}

/* stylelint-disable-next-line selector-max-type */
.jp-TableOfContents li > ol {
  /* Align left border with triangle icon center */
  padding-left: 11px;
}

.jp-TableOfContents-content {
  /* left margin for the active heading indicator */
  margin: 0 0 0 var(--jp-private-toc-active-width);
  padding: 0;
  background-color: var(--jp-layout-color1);
}

.jp-tocItem {
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.jp-tocItem-heading {
  display: flex;
  cursor: pointer;
}

.jp-tocItem-heading:hover {
  background-color: var(--jp-layout-color2);
}

.jp-tocItem-content {
  display: block;
  padding: 4px 0;
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow-x: hidden;
}

.jp-tocItem-collapser {
  height: 20px;
  margin: 2px 2px 0;
  padding: 0;
  background: none;
  border: none;
  cursor: pointer;
}

.jp-tocItem-collapser:hover {
  background-color: var(--jp-layout-color3);
}

/* Active heading indicator */

.jp-tocItem-heading::before {
  content: ' ';
  background: transparent;
  width: var(--jp-private-toc-active-width);
  height: 24px;
  position: absolute;
  left: 0;
  border-radius: var(--jp-border-radius);
}

.jp-tocItem-heading.jp-tocItem-active::before {
  background-color: var(--jp-brand-color1);
}

.jp-tocItem-heading:hover.jp-tocItem-active::before {
  background: var(--jp-brand-color0);
  opacity: 1;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-Collapser {
  flex: 0 0 var(--jp-cell-collapser-width);
  padding: 0;
  margin: 0;
  border: none;
  outline: none;
  background: transparent;
  border-radius: var(--jp-border-radius);
  opacity: 1;
}

.jp-Collapser-child {
  display: block;
  width: 100%;
  box-sizing: border-box;

  /* height: 100% doesn't work because the height of its parent is computed from content */
  position: absolute;
  top: 0;
  bottom: 0;
}

/*-----------------------------------------------------------------------------
| Printing
|----------------------------------------------------------------------------*/

/*
Hiding collapsers in print mode.

Note: input and output wrappers have "display: block" propery in print mode.
*/

@media print {
  .jp-Collapser {
    display: none;
  }
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Header/Footer
|----------------------------------------------------------------------------*/

/* Hidden by zero height by default */
.jp-CellHeader,
.jp-CellFooter {
  height: 0;
  width: 100%;
  padding: 0;
  margin: 0;
  border: none;
  outline: none;
  background: transparent;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Input
|----------------------------------------------------------------------------*/

/* All input areas */
.jp-InputArea {
  display: table;
  table-layout: fixed;
  width: 100%;
  overflow: hidden;
}

.jp-InputArea-editor {
  display: table-cell;
  overflow: hidden;
  vertical-align: top;

  /* This is the non-active, default styling */
  border: var(--jp-border-width) solid var(--jp-cell-editor-border-color);
  border-radius: 0;
  background: var(--jp-cell-editor-background);
}

.jp-InputPrompt {
  display: table-cell;
  vertical-align: top;
  width: var(--jp-cell-prompt-width);
  color: var(--jp-cell-inprompt-font-color);
  font-family: var(--jp-cell-prompt-font-family);
  padding: var(--jp-code-padding);
  letter-spacing: var(--jp-cell-prompt-letter-spacing);
  opacity: var(--jp-cell-prompt-opacity);
  line-height: var(--jp-code-line-height);
  font-size: var(--jp-code-font-size);
  border: var(--jp-border-width) solid transparent;

  /* Right align prompt text, don't wrap to handle large prompt numbers */
  text-align: right;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;

  /* Disable text selection */
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

/*-----------------------------------------------------------------------------
| Mobile
|----------------------------------------------------------------------------*/
@media only screen and (max-width: 760px) {
  .jp-InputArea-editor {
    display: table-row;
    margin-left: var(--jp-notebook-padding);
  }

  .jp-InputPrompt {
    display: table-row;
    text-align: left;
  }
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Placeholder
|----------------------------------------------------------------------------*/

.jp-Placeholder {
  display: table;
  table-layout: fixed;
  width: 100%;
}

.jp-Placeholder-prompt {
  display: table-cell;
  box-sizing: border-box;
}

.jp-Placeholder-content {
  display: table-cell;
  padding: 4px 6px;
  border: 1px solid transparent;
  border-radius: 0;
  background: none;
  box-sizing: border-box;
  cursor: pointer;
}

.jp-Placeholder-contentContainer {
  display: flex;
}

.jp-Placeholder-content:hover,
.jp-InputPlaceholder > .jp-Placeholder-content:hover {
  border-color: var(--jp-layout-color3);
}

.jp-Placeholder-content .jp-MoreHorizIcon {
  width: 32px;
  height: 16px;
  border: 1px solid transparent;
  border-radius: var(--jp-border-radius);
}

.jp-Placeholder-content .jp-MoreHorizIcon:hover {
  border: 1px solid var(--jp-border-color1);
  box-shadow: 0 0 2px 0 rgba(0, 0, 0, 0.25);
  background-color: var(--jp-layout-color0);
}

.jp-PlaceholderText {
  white-space: nowrap;
  overflow-x: hidden;
  color: var(--jp-inverse-layout-color3);
  font-family: var(--jp-code-font-family);
}

.jp-InputPlaceholder > .jp-Placeholder-content {
  border-color: var(--jp-cell-editor-border-color);
  background: var(--jp-cell-editor-background);
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Private CSS variables
|----------------------------------------------------------------------------*/

:root {
  --jp-private-cell-scrolling-output-offset: 5px;
}

/*-----------------------------------------------------------------------------
| Cell
|----------------------------------------------------------------------------*/

.jp-Cell {
  padding: var(--jp-cell-padding);
  margin: 0;
  border: none;
  outline: none;
  background: transparent;
}

/*-----------------------------------------------------------------------------
| Common input/output
|----------------------------------------------------------------------------*/

.jp-Cell-inputWrapper,
.jp-Cell-outputWrapper {
  display: flex;
  flex-direction: row;
  padding: 0;
  margin: 0;

  /* Added to reveal the box-shadow on the input and output collapsers. */
  overflow: visible;
}

/* Only input/output areas inside cells */
.jp-Cell-inputArea,
.jp-Cell-outputArea {
  flex: 1 1 auto;
}

/*-----------------------------------------------------------------------------
| Collapser
|----------------------------------------------------------------------------*/

/* Make the output collapser disappear when there is not output, but do so
 * in a manner that leaves it in the layout and preserves its width.
 */
.jp-Cell.jp-mod-noOutputs .jp-Cell-outputCollapser {
  border: none !important;
  background: transparent !important;
}

.jp-Cell:not(.jp-mod-noOutputs) .jp-Cell-outputCollapser {
  min-height: var(--jp-cell-collapser-min-height);
}

/*-----------------------------------------------------------------------------
| Output
|----------------------------------------------------------------------------*/

/* Put a space between input and output when there IS output */
.jp-Cell:not(.jp-mod-noOutputs) .jp-Cell-outputWrapper {
  margin-top: 5px;
}

.jp-CodeCell.jp-mod-outputsScrolled .jp-Cell-outputArea {
  overflow-y: auto;
  max-height: 24em;
  margin-left: var(--jp-private-cell-scrolling-output-offset);
  resize: vertical;
}

.jp-CodeCell.jp-mod-outputsScrolled .jp-Cell-outputArea[style*='height'] {
  max-height: unset;
}

.jp-CodeCell.jp-mod-outputsScrolled .jp-Cell-outputArea::after {
  content: ' ';
  box-shadow: inset 0 0 6px 2px rgb(0 0 0 / 30%);
  width: 100%;
  height: 100%;
  position: sticky;
  bottom: 0;
  top: 0;
  margin-top: -50%;
  float: left;
  display: block;
  pointer-events: none;
}

.jp-CodeCell.jp-mod-outputsScrolled .jp-OutputArea-child {
  padding-top: 6px;
}

.jp-CodeCell.jp-mod-outputsScrolled .jp-OutputArea-prompt {
  width: calc(
    var(--jp-cell-prompt-width) - var(--jp-private-cell-scrolling-output-offset)
  );
}

.jp-CodeCell.jp-mod-outputsScrolled .jp-OutputArea-promptOverlay {
  left: calc(-1 * var(--jp-private-cell-scrolling-output-offset));
}

/*-----------------------------------------------------------------------------
| CodeCell
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| MarkdownCell
|----------------------------------------------------------------------------*/

.jp-MarkdownOutput {
  display: table-cell;
  width: 100%;
  margin-top: 0;
  margin-bottom: 0;
  padding-left: var(--jp-code-padding);
}

.jp-MarkdownOutput.jp-RenderedHTMLCommon {
  overflow: auto;
}

/* collapseHeadingButton (show always if hiddenCellsButton is _not_ shown) */
.jp-collapseHeadingButton {
  display: flex;
  min-height: var(--jp-cell-collapser-min-height);
  font-size: var(--jp-code-font-size);
  position: absolute;
  background-color: transparent;
  background-size: 25px;
  background-repeat: no-repeat;
  background-position-x: center;
  background-position-y: top;
  background-image: var(--jp-icon-caret-down);
  right: 0;
  top: 0;
  bottom: 0;
}

.jp-collapseHeadingButton.jp-mod-collapsed {
  background-image: var(--jp-icon-caret-right);
}

/*
 set the container font size to match that of content
 so that the nested collapse buttons have the right size
*/
.jp-MarkdownCell .jp-InputPrompt {
  font-size: var(--jp-content-font-size1);
}

/*
  Align collapseHeadingButton with cell top header
  The font sizes are identical to the ones in packages/rendermime/style/base.css
*/
.jp-mod-rendered .jp-collapseHeadingButton[data-heading-level='1'] {
  font-size: var(--jp-content-font-size5);
  background-position-y: calc(0.3 * var(--jp-content-font-size5));
}

.jp-mod-rendered .jp-collapseHeadingButton[data-heading-level='2'] {
  font-size: var(--jp-content-font-size4);
  background-position-y: calc(0.3 * var(--jp-content-font-size4));
}

.jp-mod-rendered .jp-collapseHeadingButton[data-heading-level='3'] {
  font-size: var(--jp-content-font-size3);
  background-position-y: calc(0.3 * var(--jp-content-font-size3));
}

.jp-mod-rendered .jp-collapseHeadingButton[data-heading-level='4'] {
  font-size: var(--jp-content-font-size2);
  background-position-y: calc(0.3 * var(--jp-content-font-size2));
}

.jp-mod-rendered .jp-collapseHeadingButton[data-heading-level='5'] {
  font-size: var(--jp-content-font-size1);
  background-position-y: top;
}

.jp-mod-rendered .jp-collapseHeadingButton[data-heading-level='6'] {
  font-size: var(--jp-content-font-size0);
  background-position-y: top;
}

/* collapseHeadingButton (show only on (hover,active) if hiddenCellsButton is shown) */
.jp-Notebook.jp-mod-showHiddenCellsButton .jp-collapseHeadingButton {
  display: none;
}

.jp-Notebook.jp-mod-showHiddenCellsButton
  :is(.jp-MarkdownCell:hover, .jp-mod-active)
  .jp-collapseHeadingButton {
  display: flex;
}

/* showHiddenCellsButton (only show if jp-mod-showHiddenCellsButton is set, which
is a consequence of the showHiddenCellsButton option in Notebook Settings)*/
.jp-Notebook.jp-mod-showHiddenCellsButton .jp-showHiddenCellsButton {
  margin-left: calc(var(--jp-cell-prompt-width) + 2 * var(--jp-code-padding));
  margin-top: var(--jp-code-padding);
  border: 1px solid var(--jp-border-color2);
  background-color: var(--jp-border-color3) !important;
  color: var(--jp-content-font-color0) !important;
  display: flex;
}

.jp-Notebook.jp-mod-showHiddenCellsButton .jp-showHiddenCellsButton:hover {
  background-color: var(--jp-border-color2) !important;
}

.jp-showHiddenCellsButton {
  display: none;
}

/*-----------------------------------------------------------------------------
| Printing
|----------------------------------------------------------------------------*/

/*
Using block instead of flex to allow the use of the break-inside CSS property for
cell outputs.
*/

@media print {
  .jp-Cell-inputWrapper,
  .jp-Cell-outputWrapper {
    display: block;
  }
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Variables
|----------------------------------------------------------------------------*/

:root {
  --jp-notebook-toolbar-padding: 2px 5px 2px 2px;
}

/*-----------------------------------------------------------------------------

/*-----------------------------------------------------------------------------
| Styles
|----------------------------------------------------------------------------*/

.jp-NotebookPanel-toolbar {
  padding: var(--jp-notebook-toolbar-padding);

  /* disable paint containment from lumino 2.0 default strict CSS containment */
  contain: style size !important;
}

.jp-Toolbar-item.jp-Notebook-toolbarCellType .jp-select-wrapper.jp-mod-focused {
  border: none;
  box-shadow: none;
}

.jp-Notebook-toolbarCellTypeDropdown select {
  height: 24px;
  font-size: var(--jp-ui-font-size1);
  line-height: 14px;
  border-radius: 0;
  display: block;
}

.jp-Notebook-toolbarCellTypeDropdown span {
  top: 5px !important;
}

.jp-Toolbar-responsive-popup {
  position: absolute;
  height: fit-content;
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  justify-content: flex-end;
  border-bottom: var(--jp-border-width) solid var(--jp-toolbar-border-color);
  box-shadow: var(--jp-toolbar-box-shadow);
  background: var(--jp-toolbar-background);
  min-height: var(--jp-toolbar-micro-height);
  padding: var(--jp-notebook-toolbar-padding);
  z-index: 1;
  right: 0;
  top: 0;
}

.jp-Toolbar > .jp-Toolbar-responsive-opener {
  margin-left: auto;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Variables
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------

/*-----------------------------------------------------------------------------
| Styles
|----------------------------------------------------------------------------*/

.jp-Notebook-ExecutionIndicator {
  position: relative;
  display: inline-block;
  height: 100%;
  z-index: 9997;
}

.jp-Notebook-ExecutionIndicator-tooltip {
  visibility: hidden;
  height: auto;
  width: max-content;
  width: -moz-max-content;
  background-color: var(--jp-layout-color2);
  color: var(--jp-ui-font-color1);
  text-align: justify;
  border-radius: 6px;
  padding: 0 5px;
  position: fixed;
  display: table;
}

.jp-Notebook-ExecutionIndicator-tooltip.up {
  transform: translateX(-50%) translateY(-100%) translateY(-32px);
}

.jp-Notebook-ExecutionIndicator-tooltip.down {
  transform: translateX(calc(-100% + 16px)) translateY(5px);
}

.jp-Notebook-ExecutionIndicator-tooltip.hidden {
  display: none;
}

.jp-Notebook-ExecutionIndicator:hover .jp-Notebook-ExecutionIndicator-tooltip {
  visibility: visible;
}

.jp-Notebook-ExecutionIndicator span {
  font-size: var(--jp-ui-font-size1);
  font-family: var(--jp-ui-font-family);
  color: var(--jp-ui-font-color1);
  line-height: 24px;
  display: block;
}

.jp-Notebook-ExecutionIndicator-progress-bar {
  display: flex;
  justify-content: center;
  height: 100%;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*
 * Execution indicator
 */
.jp-tocItem-content::after {
  content: '';

  /* Must be identical to form a circle */
  width: 12px;
  height: 12px;
  background: none;
  border: none;
  position: absolute;
  right: 0;
}

.jp-tocItem-content[data-running='0']::after {
  border-radius: 50%;
  border: var(--jp-border-width) solid var(--jp-inverse-layout-color3);
  background: none;
}

.jp-tocItem-content[data-running='1']::after {
  border-radius: 50%;
  border: var(--jp-border-width) solid var(--jp-inverse-layout-color3);
  background-color: var(--jp-inverse-layout-color3);
}

.jp-tocItem-content[data-running='0'],
.jp-tocItem-content[data-running='1'] {
  margin-right: 12px;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

.jp-Notebook-footer {
  height: 27px;
  margin-left: calc(
    var(--jp-cell-prompt-width) + var(--jp-cell-collapser-width) +
      var(--jp-cell-padding)
  );
  width: calc(
    100% -
      (
        var(--jp-cell-prompt-width) + var(--jp-cell-collapser-width) +
          var(--jp-cell-padding) + var(--jp-cell-padding)
      )
  );
  border: var(--jp-border-width) solid var(--jp-cell-editor-border-color);
  color: var(--jp-ui-font-color3);
  margin-top: 6px;
  background: none;
  cursor: pointer;
}

.jp-Notebook-footer:focus {
  border-color: var(--jp-cell-editor-active-border-color);
}

/* For devices that support hovering, hide footer until hover */
@media (hover: hover) {
  .jp-Notebook-footer {
    opacity: 0;
  }

  .jp-Notebook-footer:focus,
  .jp-Notebook-footer:hover {
    opacity: 1;
  }
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Imports
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| CSS variables
|----------------------------------------------------------------------------*/

:root {
  --jp-side-by-side-output-size: 1fr;
  --jp-side-by-side-resized-cell: var(--jp-side-by-side-output-size);
  --jp-private-notebook-dragImage-width: 304px;
  --jp-private-notebook-dragImage-height: 36px;
  --jp-private-notebook-selected-color: var(--md-blue-400);
  --jp-private-notebook-active-color: var(--md-green-400);
}

/*-----------------------------------------------------------------------------
| Notebook
|----------------------------------------------------------------------------*/

/* stylelint-disable selector-max-class */

.jp-NotebookPanel {
  display: block;
  height: 100%;
}

.jp-NotebookPanel.jp-Document {
  min-width: 240px;
  min-height: 120px;
}

.jp-Notebook {
  padding: var(--jp-notebook-padding);
  outline: none;
  overflow: auto;
  background: var(--jp-layout-color0);
}

.jp-Notebook.jp-mod-scrollPastEnd::after {
  display: block;
  content: '';
  min-height: var(--jp-notebook-scroll-padding);
}

.jp-MainAreaWidget-ContainStrict .jp-Notebook * {
  contain: strict;
}

.jp-Notebook .jp-Cell {
  overflow: visible;
}

.jp-Notebook .jp-Cell .jp-InputPrompt {
  cursor: move;
}

/*-----------------------------------------------------------------------------
| Notebook state related styling
|
| The notebook and cells each have states, here are the possibilities:
|
| - Notebook
|   - Command
|   - Edit
| - Cell
|   - None
|   - Active (only one can be active)
|   - Selected (the cells actions are applied to)
|   - Multiselected (when multiple selected, the cursor)
|   - No outputs
|----------------------------------------------------------------------------*/

/* Command or edit modes */

.jp-Notebook .jp-Cell:not(.jp-mod-active) .jp-InputPrompt {
  opacity: var(--jp-cell-prompt-not-active-opacity);
  color: var(--jp-cell-prompt-not-active-font-color);
}

.jp-Notebook .jp-Cell:not(.jp-mod-active) .jp-OutputPrompt {
  opacity: var(--jp-cell-prompt-not-active-opacity);
  color: var(--jp-cell-prompt-not-active-font-color);
}

/* cell is active */
.jp-Notebook .jp-Cell.jp-mod-active .jp-Collapser {
  background: var(--jp-brand-color1);
}

/* cell is dirty */
.jp-Notebook .jp-Cell.jp-mod-dirty .jp-InputPrompt {
  color: var(--jp-warn-color1);
}

.jp-Notebook .jp-Cell.jp-mod-dirty .jp-InputPrompt::before {
  color: var(--jp-warn-color1);
  content: '•';
}

.jp-Notebook .jp-Cell.jp-mod-active.jp-mod-dirty .jp-Collapser {
  background: var(--jp-warn-color1);
}

/* collapser is hovered */
.jp-Notebook .jp-Cell .jp-Collapser:hover {
  box-shadow: var(--jp-elevation-z2);
  background: var(--jp-brand-color1);
  opacity: var(--jp-cell-collapser-not-active-hover-opacity);
}

/* cell is active and collapser is hovered */
.jp-Notebook .jp-Cell.jp-mod-active .jp-Collapser:hover {
  background: var(--jp-brand-color0);
  opacity: 1;
}

/* Command mode */

.jp-Notebook.jp-mod-commandMode .jp-Cell.jp-mod-selected {
  background: var(--jp-notebook-multiselected-color);
}

.jp-Notebook.jp-mod-commandMode
  .jp-Cell.jp-mod-active.jp-mod-selected:not(.jp-mod-multiSelected) {
  background: transparent;
}

/* Edit mode */

.jp-Notebook.jp-mod-editMode .jp-Cell.jp-mod-active .jp-InputArea-editor {
  border: var(--jp-border-width) solid var(--jp-cell-editor-active-border-color);
  box-shadow: var(--jp-input-box-shadow);
  background-color: var(--jp-cell-editor-active-background);
}

/*-----------------------------------------------------------------------------
| Notebook drag and drop
|----------------------------------------------------------------------------*/

.jp-Notebook-cell.jp-mod-dropSource {
  opacity: 0.5;
}

.jp-Notebook-cell.jp-mod-dropTarget,
.jp-Notebook.jp-mod-commandMode
  .jp-Notebook-cell.jp-mod-active.jp-mod-selected.jp-mod-dropTarget {
  border-top-color: var(--jp-private-notebook-selected-color);
  border-top-style: solid;
  border-top-width: 2px;
}

.jp-dragImage {
  display: block;
  flex-direction: row;
  width: var(--jp-private-notebook-dragImage-width);
  height: var(--jp-private-notebook-dragImage-height);
  border: var(--jp-border-width) solid var(--jp-cell-editor-border-color);
  background: var(--jp-cell-editor-background);
  overflow: visible;
}

.jp-dragImage-singlePrompt {
  box-shadow: 2px 2px 4px 0 rgba(0, 0, 0, 0.12);
}

.jp-dragImage .jp-dragImage-content {
  flex: 1 1 auto;
  z-index: 2;
  font-size: var(--jp-code-font-size);
  font-family: var(--jp-code-font-family);
  line-height: var(--jp-code-line-height);
  padding: var(--jp-code-padding);
  border: var(--jp-border-width) solid var(--jp-cell-editor-border-color);
  background: var(--jp-cell-editor-background-color);
  color: var(--jp-content-font-color3);
  text-align: left;
  margin: 4px 4px 4px 0;
}

.jp-dragImage .jp-dragImage-prompt {
  flex: 0 0 auto;
  min-width: 36px;
  color: var(--jp-cell-inprompt-font-color);
  padding: var(--jp-code-padding);
  padding-left: 12px;
  font-family: var(--jp-cell-prompt-font-family);
  letter-spacing: var(--jp-cell-prompt-letter-spacing);
  line-height: 1.9;
  font-size: var(--jp-code-font-size);
  border: var(--jp-border-width) solid transparent;
}

.jp-dragImage-multipleBack {
  z-index: -1;
  position: absolute;
  height: 32px;
  width: 300px;
  top: 8px;
  left: 8px;
  background: var(--jp-layout-color2);
  border: var(--jp-border-width) solid var(--jp-input-border-color);
  box-shadow: 2px 2px 4px 0 rgba(0, 0, 0, 0.12);
}

/*-----------------------------------------------------------------------------
| Cell toolbar
|----------------------------------------------------------------------------*/

.jp-NotebookTools {
  display: block;
  min-width: var(--jp-sidebar-min-width);
  color: var(--jp-ui-font-color1);
  background: var(--jp-layout-color1);

  /* This is needed so that all font sizing of children done in ems is
    * relative to this base size */
  font-size: var(--jp-ui-font-size1);
  overflow: auto;
}

.jp-ActiveCellTool {
  padding: 12px 0;
  display: flex;
}

.jp-ActiveCellTool-Content {
  flex: 1 1 auto;
}

.jp-ActiveCellTool .jp-ActiveCellTool-CellContent {
  background: var(--jp-cell-editor-background);
  border: var(--jp-border-width) solid var(--jp-cell-editor-border-color);
  border-radius: 0;
  min-height: 29px;
}

.jp-ActiveCellTool .jp-InputPrompt {
  min-width: calc(var(--jp-cell-prompt-width) * 0.75);
}

.jp-ActiveCellTool-CellContent > pre {
  padding: 5px 4px;
  margin: 0;
  white-space: normal;
}

.jp-MetadataEditorTool {
  flex-direction: column;
  padding: 12px 0;
}

.jp-RankedPanel > :not(:first-child) {
  margin-top: 12px;
}

.jp-KeySelector select.jp-mod-styled {
  font-size: var(--jp-ui-font-size1);
  color: var(--jp-ui-font-color0);
  border: var(--jp-border-width) solid var(--jp-border-color1);
}

.jp-KeySelector label,
.jp-MetadataEditorTool label,
.jp-NumberSetter label {
  line-height: 1.4;
}

.jp-NotebookTools .jp-select-wrapper {
  margin-top: 4px;
  margin-bottom: 0;
}

.jp-NumberSetter input {
  width: 100%;
  margin-top: 4px;
}

.jp-NotebookTools .jp-Collapse {
  margin-top: 16px;
}

/*-----------------------------------------------------------------------------
| Presentation Mode (.jp-mod-presentationMode)
|----------------------------------------------------------------------------*/

.jp-mod-presentationMode .jp-Notebook {
  --jp-content-font-size1: var(--jp-content-presentation-font-size1);
  --jp-code-font-size: var(--jp-code-presentation-font-size);
}

.jp-mod-presentationMode .jp-Notebook .jp-Cell .jp-InputPrompt,
.jp-mod-presentationMode .jp-Notebook .jp-Cell .jp-OutputPrompt {
  flex: 0 0 110px;
}

/*-----------------------------------------------------------------------------
| Side-by-side Mode (.jp-mod-sideBySide)
|----------------------------------------------------------------------------*/
.jp-mod-sideBySide.jp-Notebook .jp-Notebook-cell {
  margin-top: 3em;
  margin-bottom: 3em;
  margin-left: 5%;
  margin-right: 5%;
}

.jp-mod-sideBySide.jp-Notebook .jp-CodeCell {
  display: grid;
  grid-template-columns: minmax(0, 1fr) min-content minmax(
      0,
      var(--jp-side-by-side-output-size)
    );
  grid-template-rows: auto minmax(0, 1fr) auto;
  grid-template-areas:
    'header header header'
    'input handle output'
    'footer footer footer';
}

.jp-mod-sideBySide.jp-Notebook .jp-CodeCell.jp-mod-resizedCell {
  grid-template-columns: minmax(0, 1fr) min-content minmax(
      0,
      var(--jp-side-by-side-resized-cell)
    );
}

.jp-mod-sideBySide.jp-Notebook .jp-CodeCell .jp-CellHeader {
  grid-area: header;
}

.jp-mod-sideBySide.jp-Notebook .jp-CodeCell .jp-Cell-inputWrapper {
  grid-area: input;
}

.jp-mod-sideBySide.jp-Notebook .jp-CodeCell .jp-Cell-outputWrapper {
  /* overwrite the default margin (no vertical separation needed in side by side move */
  margin-top: 0;
  grid-area: output;
}

.jp-mod-sideBySide.jp-Notebook .jp-CodeCell .jp-CellFooter {
  grid-area: footer;
}

.jp-mod-sideBySide.jp-Notebook .jp-CodeCell .jp-CellResizeHandle {
  grid-area: handle;
  user-select: none;
  display: block;
  height: 100%;
  cursor: ew-resize;
  padding: 0 var(--jp-cell-padding);
}

.jp-mod-sideBySide.jp-Notebook .jp-CodeCell .jp-CellResizeHandle::after {
  content: '';
  display: block;
  background: var(--jp-border-color2);
  height: 100%;
  width: 5px;
}

.jp-mod-sideBySide.jp-Notebook
  .jp-CodeCell.jp-mod-resizedCell
  .jp-CellResizeHandle::after {
  background: var(--jp-border-color0);
}

.jp-CellResizeHandle {
  display: none;
}

/*-----------------------------------------------------------------------------
| Placeholder
|----------------------------------------------------------------------------*/

.jp-Cell-Placeholder {
  padding-left: 55px;
}

.jp-Cell-Placeholder-wrapper {
  background: #fff;
  border: 1px solid;
  border-color: #e5e6e9 #dfe0e4 #d0d1d5;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  margin: 10px 15px;
}

.jp-Cell-Placeholder-wrapper-inner {
  padding: 15px;
  position: relative;
}

.jp-Cell-Placeholder-wrapper-body {
  background-repeat: repeat;
  background-size: 50% auto;
}

.jp-Cell-Placeholder-wrapper-body div {
  background: #f6f7f8;
  background-image: -webkit-linear-gradient(
    left,
    #f6f7f8 0%,
    #edeef1 20%,
    #f6f7f8 40%,
    #f6f7f8 100%
  );
  background-repeat: no-repeat;
  background-size: 800px 104px;
  height: 104px;
  position: absolute;
  right: 15px;
  left: 15px;
  top: 15px;
}

div.jp-Cell-Placeholder-h1 {
  top: 20px;
  height: 20px;
  left: 15px;
  width: 150px;
}

div.jp-Cell-Placeholder-h2 {
  left: 15px;
  top: 50px;
  height: 10px;
  width: 100px;
}

div.jp-Cell-Placeholder-content-1,
div.jp-Cell-Placeholder-content-2,
div.jp-Cell-Placeholder-content-3 {
  left: 15px;
  right: 15px;
  height: 10px;
}

div.jp-Cell-Placeholder-content-1 {
  top: 100px;
}

div.jp-Cell-Placeholder-content-2 {
  top: 120px;
}

div.jp-Cell-Placeholder-content-3 {
  top: 140px;
}

</style>
<style type="text/css">
/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*
The following CSS variables define the main, public API for styling JupyterLab.
These variables should be used by all plugins wherever possible. In other
words, plugins should not define custom colors, sizes, etc unless absolutely
necessary. This enables users to change the visual theme of JupyterLab
by changing these variables.

Many variables appear in an ordered sequence (0,1,2,3). These sequences
are designed to work well together, so for example, `--jp-border-color1` should
be used with `--jp-layout-color1`. The numbers have the following meanings:

* 0: super-primary, reserved for special emphasis
* 1: primary, most important under normal situations
* 2: secondary, next most important under normal situations
* 3: tertiary, next most important under normal situations

Throughout JupyterLab, we are mostly following principles from Google's
Material Design when selecting colors. We are not, however, following
all of MD as it is not optimized for dense, information rich UIs.
*/

:root {
  /* Elevation
   *
   * We style box-shadows using Material Design's idea of elevation. These particular numbers are taken from here:
   *
   * https://github.com/material-components/material-components-web
   * https://material-components-web.appspot.com/elevation.html
   */

  /* The dark theme shadows need a bit of work, but this will probably also require work on the core layout
   * colors used in the theme as well. */
  --jp-shadow-base-lightness: 32;
  --jp-shadow-umbra-color: rgba(
    var(--jp-shadow-base-lightness),
    var(--jp-shadow-base-lightness),
    var(--jp-shadow-base-lightness),
    0.2
  );
  --jp-shadow-penumbra-color: rgba(
    var(--jp-shadow-base-lightness),
    var(--jp-shadow-base-lightness),
    var(--jp-shadow-base-lightness),
    0.14
  );
  --jp-shadow-ambient-color: rgba(
    var(--jp-shadow-base-lightness),
    var(--jp-shadow-base-lightness),
    var(--jp-shadow-base-lightness),
    0.12
  );
  --jp-elevation-z0: none;
  --jp-elevation-z1: 0 2px 1px -1px var(--jp-shadow-umbra-color),
    0 1px 1px 0 var(--jp-shadow-penumbra-color),
    0 1px 3px 0 var(--jp-shadow-ambient-color);
  --jp-elevation-z2: 0 3px 1px -2px var(--jp-shadow-umbra-color),
    0 2px 2px 0 var(--jp-shadow-penumbra-color),
    0 1px 5px 0 var(--jp-shadow-ambient-color);
  --jp-elevation-z4: 0 2px 4px -1px var(--jp-shadow-umbra-color),
    0 4px 5px 0 var(--jp-shadow-penumbra-color),
    0 1px 10px 0 var(--jp-shadow-ambient-color);
  --jp-elevation-z6: 0 3px 5px -1px var(--jp-shadow-umbra-color),
    0 6px 10px 0 var(--jp-shadow-penumbra-color),
    0 1px 18px 0 var(--jp-shadow-ambient-color);
  --jp-elevation-z8: 0 5px 5px -3px var(--jp-shadow-umbra-color),
    0 8px 10px 1px var(--jp-shadow-penumbra-color),
    0 3px 14px 2px var(--jp-shadow-ambient-color);
  --jp-elevation-z12: 0 7px 8px -4px var(--jp-shadow-umbra-color),
    0 12px 17px 2px var(--jp-shadow-penumbra-color),
    0 5px 22px 4px var(--jp-shadow-ambient-color);
  --jp-elevation-z16: 0 8px 10px -5px var(--jp-shadow-umbra-color),
    0 16px 24px 2px var(--jp-shadow-penumbra-color),
    0 6px 30px 5px var(--jp-shadow-ambient-color);
  --jp-elevation-z20: 0 10px 13px -6px var(--jp-shadow-umbra-color),
    0 20px 31px 3px var(--jp-shadow-penumbra-color),
    0 8px 38px 7px var(--jp-shadow-ambient-color);
  --jp-elevation-z24: 0 11px 15px -7px var(--jp-shadow-umbra-color),
    0 24px 38px 3px var(--jp-shadow-penumbra-color),
    0 9px 46px 8px var(--jp-shadow-ambient-color);

  /* Borders
   *
   * The following variables, specify the visual styling of borders in JupyterLab.
   */

  --jp-border-width: 1px;
  --jp-border-color0: var(--md-grey-700);
  --jp-border-color1: var(--md-grey-700);
  --jp-border-color2: var(--md-grey-800);
  --jp-border-color3: var(--md-grey-900);
  --jp-inverse-border-color: var(--md-grey-600);
  --jp-border-radius: 2px;

  /* UI Fonts
   *
   * The UI font CSS variables are used for the typography all of the JupyterLab
   * user interface elements that are not directly user generated content.
   *
   * The font sizing here is done assuming that the body font size of --jp-ui-font-size1
   * is applied to a parent element. When children elements, such as headings, are sized
   * in em all things will be computed relative to that body size.
   */

  --jp-ui-font-scale-factor: 1.2;
  --jp-ui-font-size0: 0.83333em;
  --jp-ui-font-size1: 13px; /* Base font size */
  --jp-ui-font-size2: 1.2em;
  --jp-ui-font-size3: 1.44em;
  --jp-ui-font-family: system-ui, -apple-system, blinkmacsystemfont, 'Segoe UI',
    helvetica, arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji',
    'Segoe UI Symbol';

  /*
   * Use these font colors against the corresponding main layout colors.
   * In a light theme, these go from dark to light.
   */

  /* Defaults use Material Design specification */
  --jp-ui-font-color0: rgba(255, 255, 255, 1);
  --jp-ui-font-color1: rgba(255, 255, 255, 0.87);
  --jp-ui-font-color2: rgba(255, 255, 255, 0.54);
  --jp-ui-font-color3: rgba(255, 255, 255, 0.38);

  /*
   * Use these against the brand/accent/warn/error colors.
   * These will typically go from light to darker, in both a dark and light theme.
   */

  --jp-ui-inverse-font-color0: rgba(0, 0, 0, 1);
  --jp-ui-inverse-font-color1: rgba(0, 0, 0, 0.8);
  --jp-ui-inverse-font-color2: rgba(0, 0, 0, 0.5);
  --jp-ui-inverse-font-color3: rgba(0, 0, 0, 0.3);

  /* Content Fonts
   *
   * Content font variables are used for typography of user generated content.
   *
   * The font sizing here is done assuming that the body font size of --jp-content-font-size1
   * is applied to a parent element. When children elements, such as headings, are sized
   * in em all things will be computed relative to that body size.
   */

  --jp-content-line-height: 1.6;
  --jp-content-font-scale-factor: 1.2;
  --jp-content-font-size0: 0.83333em;
  --jp-content-font-size1: 14px; /* Base font size */
  --jp-content-font-size2: 1.2em;
  --jp-content-font-size3: 1.44em;
  --jp-content-font-size4: 1.728em;
  --jp-content-font-size5: 2.0736em;

  /* This gives a magnification of about 125% in presentation mode over normal. */
  --jp-content-presentation-font-size1: 17px;
  --jp-content-heading-line-height: 1;
  --jp-content-heading-margin-top: 1.2em;
  --jp-content-heading-margin-bottom: 0.8em;
  --jp-content-heading-font-weight: 500;

  /* Defaults use Material Design specification */
  --jp-content-font-color0: rgba(255, 255, 255, 1);
  --jp-content-font-color1: rgba(255, 255, 255, 1);
  --jp-content-font-color2: rgba(255, 255, 255, 0.7);
  --jp-content-font-color3: rgba(255, 255, 255, 0.5);
  --jp-content-link-color: var(--md-blue-300);
  --jp-content-font-family: system-ui, -apple-system, blinkmacsystemfont,
    'Segoe UI', helvetica, arial, sans-serif, 'Apple Color Emoji',
    'Segoe UI Emoji', 'Segoe UI Symbol';

  /*
   * Code Fonts
   *
   * Code font variables are used for typography of code and other monospaces content.
   */

  --jp-code-font-size: 13px;
  --jp-code-line-height: 1.3077; /* 17px for 13px base */
  --jp-code-padding: 5px; /* 5px for 13px base, codemirror highlighting needs integer px value */
  --jp-code-font-family-default: menlo, consolas, 'DejaVu Sans Mono', monospace;
  --jp-code-font-family: var(--jp-code-font-family-default);

  /* This gives a magnification of about 125% in presentation mode over normal. */
  --jp-code-presentation-font-size: 16px;

  /* may need to tweak cursor width if you change font size */
  --jp-code-cursor-width0: 1.4px;
  --jp-code-cursor-width1: 2px;
  --jp-code-cursor-width2: 4px;

  /* Layout
   *
   * The following are the main layout colors use in JupyterLab. In a light
   * theme these would go from light to dark.
   */

  --jp-layout-color0: #111;
  --jp-layout-color1: var(--md-grey-900);
  --jp-layout-color2: var(--md-grey-800);
  --jp-layout-color3: var(--md-grey-700);
  --jp-layout-color4: var(--md-grey-600);

  /* Inverse Layout
   *
   * The following are the inverse layout colors use in JupyterLab. In a light
   * theme these would go from dark to light.
   */

  --jp-inverse-layout-color0: white;
  --jp-inverse-layout-color1: white;
  --jp-inverse-layout-color2: var(--md-grey-200);
  --jp-inverse-layout-color3: var(--md-grey-400);
  --jp-inverse-layout-color4: var(--md-grey-600);

  /* Brand/accent */

  --jp-brand-color0: var(--md-blue-700);
  --jp-brand-color1: var(--md-blue-500);
  --jp-brand-color2: var(--md-blue-300);
  --jp-brand-color3: var(--md-blue-100);
  --jp-brand-color4: var(--md-blue-50);
  --jp-accent-color0: var(--md-green-700);
  --jp-accent-color1: var(--md-green-500);
  --jp-accent-color2: var(--md-green-300);
  --jp-accent-color3: var(--md-green-100);

  /* State colors (warn, error, success, info) */

  --jp-warn-color0: var(--md-orange-700);
  --jp-warn-color1: var(--md-orange-500);
  --jp-warn-color2: var(--md-orange-300);
  --jp-warn-color3: var(--md-orange-100);
  --jp-error-color0: var(--md-red-700);
  --jp-error-color1: var(--md-red-500);
  --jp-error-color2: var(--md-red-300);
  --jp-error-color3: var(--md-red-100);
  --jp-success-color0: var(--md-green-700);
  --jp-success-color1: var(--md-green-500);
  --jp-success-color2: var(--md-green-300);
  --jp-success-color3: var(--md-green-100);
  --jp-info-color0: var(--md-cyan-700);
  --jp-info-color1: var(--md-cyan-500);
  --jp-info-color2: var(--md-cyan-300);
  --jp-info-color3: var(--md-cyan-100);

  /* Cell specific styles */

  --jp-cell-padding: 5px;
  --jp-cell-collapser-width: 8px;
  --jp-cell-collapser-min-height: 20px;
  --jp-cell-collapser-not-active-hover-opacity: 0.6;
  --jp-cell-editor-background: var(--jp-layout-color1);
  --jp-cell-editor-border-color: var(--md-grey-700);
  --jp-cell-editor-box-shadow: inset 0 0 2px var(--md-blue-300);
  --jp-cell-editor-active-background: var(--jp-layout-color0);
  --jp-cell-editor-active-border-color: var(--jp-brand-color1);
  --jp-cell-prompt-width: 64px;
  --jp-cell-prompt-font-family: var(--jp-code-font-family-default);
  --jp-cell-prompt-letter-spacing: 0;
  --jp-cell-prompt-opacity: 1;
  --jp-cell-prompt-not-active-opacity: 1;
  --jp-cell-prompt-not-active-font-color: var(--md-grey-300);

  /* A custom blend of MD grey and blue 600
   * See https://meyerweb.com/eric/tools/color-blend/#546E7A:1E88E5:5:hex */
  --jp-cell-inprompt-font-color: #307fc1;

  /* A custom blend of MD grey and orange 600
   * https://meyerweb.com/eric/tools/color-blend/#546E7A:F4511E:5:hex */
  --jp-cell-outprompt-font-color: #bf5b3d;

  /* Notebook specific styles */

  --jp-notebook-padding: 10px;
  --jp-notebook-select-background: var(--jp-layout-color1);
  --jp-notebook-multiselected-color: rgba(33, 150, 243, 0.24);

  /* The scroll padding is calculated to fill enough space at the bottom of the
  notebook to show one single-line cell (with appropriate padding) at the top
  when the notebook is scrolled all the way to the bottom. We also subtract one
  pixel so that no scrollbar appears if we have just one single-line cell in the
  notebook. This padding is to enable a 'scroll past end' feature in a notebook.
  */
  --jp-notebook-scroll-padding: calc(
    100% - var(--jp-code-font-size) * var(--jp-code-line-height) -
      var(--jp-code-padding) - var(--jp-cell-padding) - 1px
  );

  /* Rendermime styles */

  --jp-rendermime-error-background: rgba(244, 67, 54, 0.28);
  --jp-rendermime-table-row-background: var(--md-grey-900);
  --jp-rendermime-table-row-hover-background: rgba(3, 169, 244, 0.2);

  /* Dialog specific styles */

  --jp-dialog-background: rgba(0, 0, 0, 0.6);

  /* Console specific styles */

  --jp-console-padding: 10px;

  /* Toolbar specific styles */

  --jp-toolbar-border-color: var(--jp-border-color2);
  --jp-toolbar-micro-height: 8px;
  --jp-toolbar-background: var(--jp-layout-color1);
  --jp-toolbar-box-shadow: 0 0 2px 0 rgba(0, 0, 0, 0.8);
  --jp-toolbar-header-margin: 4px 4px 0 4px;
  --jp-toolbar-active-background: var(--jp-layout-color0);

  /* Statusbar specific styles */

  --jp-statusbar-height: 24px;

  /* Input field styles */

  --jp-input-box-shadow: inset 0 0 2px var(--md-blue-300);
  --jp-input-active-background: var(--jp-layout-color0);
  --jp-input-hover-background: var(--jp-layout-color2);
  --jp-input-background: var(--md-grey-800);
  --jp-input-border-color: var(--jp-inverse-border-color);
  --jp-input-active-border-color: var(--jp-brand-color1);
  --jp-input-active-box-shadow-color: rgba(19, 124, 189, 0.3);

  /* General editor styles */

  --jp-editor-selected-background: var(--jp-layout-color2);
  --jp-editor-selected-focused-background: rgba(33, 150, 243, 0.24);
  --jp-editor-cursor-color: var(--jp-ui-font-color0);

  /* Code mirror specific styles */

  --jp-mirror-editor-keyword-color: var(--md-green-500);
  --jp-mirror-editor-atom-color: var(--md-blue-300);
  --jp-mirror-editor-number-color: var(--md-green-400);
  --jp-mirror-editor-def-color: var(--md-blue-600);
  --jp-mirror-editor-variable-color: var(--md-grey-300);
  --jp-mirror-editor-variable-2-color: var(--md-blue-500);
  --jp-mirror-editor-variable-3-color: var(--md-green-600);
  --jp-mirror-editor-punctuation-color: var(--md-blue-400);
  --jp-mirror-editor-property-color: var(--md-blue-400);
  --jp-mirror-editor-operator-color: #a2f;
  --jp-mirror-editor-comment-color: #408080;
  --jp-mirror-editor-string-color: #ff7070;
  --jp-mirror-editor-string-2-color: var(--md-purple-300);
  --jp-mirror-editor-meta-color: #a2f;
  --jp-mirror-editor-qualifier-color: #555;
  --jp-mirror-editor-builtin-color: var(--md-green-600);
  --jp-mirror-editor-bracket-color: #997;
  --jp-mirror-editor-tag-color: var(--md-green-700);
  --jp-mirror-editor-attribute-color: var(--md-blue-700);
  --jp-mirror-editor-header-color: var(--md-blue-500);
  --jp-mirror-editor-quote-color: var(--md-green-300);
  --jp-mirror-editor-link-color: var(--md-blue-700);
  --jp-mirror-editor-error-color: #f00;
  --jp-mirror-editor-hr-color: #999;

  /*
    RTC user specific colors.
    These colors are used for the cursor, username in the editor,
    and the icon of the user.
  */

  --jp-collaborator-color1: #ad4a00;
  --jp-collaborator-color2: #7b6a00;
  --jp-collaborator-color3: #007e00;
  --jp-collaborator-color4: #008772;
  --jp-collaborator-color5: #0079b9;
  --jp-collaborator-color6: #8b45c6;
  --jp-collaborator-color7: #be208b;

  /* Vega extension styles */

  --jp-vega-background: var(--md-grey-400);

  /* Sidebar-related styles */

  --jp-sidebar-min-width: 250px;

  /* Search-related styles */

  --jp-search-toggle-off-opacity: 0.6;
  --jp-search-toggle-hover-opacity: 0.8;
  --jp-search-toggle-on-opacity: 1;
  --jp-search-selected-match-background-color: rgb(255, 225, 0);
  --jp-search-selected-match-color: black;
  --jp-search-unselected-match-background-color: var(
    --jp-inverse-layout-color0
  );
  --jp-search-unselected-match-color: var(--jp-ui-inverse-font-color0);

  /* scrollbar related styles. Supports every browser except Edge. */

  /* colors based on JetBrain's Darcula theme */

  --jp-scrollbar-background-color: #3f4244;
  --jp-scrollbar-thumb-color: 88, 96, 97; /* need to specify thumb color as an RGB triplet */
  --jp-scrollbar-endpad: 3px; /* the minimum gap between the thumb and the ends of a scrollbar */

  /* hacks for setting the thumb shape. These do nothing in Firefox */

  --jp-scrollbar-thumb-margin: 3.5px; /* the space in between the sides of the thumb and the track */
  --jp-scrollbar-thumb-radius: 9px; /* set to a large-ish value for rounded endcaps on the thumb */

  /* Icon colors that work well with light or dark backgrounds */
  --jp-icon-contrast-color0: var(--md-purple-600);
  --jp-icon-contrast-color1: var(--md-green-600);
  --jp-icon-contrast-color2: var(--md-pink-600);
  --jp-icon-contrast-color3: var(--md-blue-600);

  /* Button colors */
  --jp-accept-color-normal: var(--md-blue-700);
  --jp-accept-color-hover: var(--md-blue-800);
  --jp-accept-color-active: var(--md-blue-900);
  --jp-warn-color-normal: var(--md-red-700);
  --jp-warn-color-hover: var(--md-red-800);
  --jp-warn-color-active: var(--md-red-900);
  --jp-reject-color-normal: var(--md-grey-600);
  --jp-reject-color-hover: var(--md-grey-700);
  --jp-reject-color-active: var(--md-grey-800);

  /* File or activity icons and switch semantic variables */
  --jp-jupyter-icon-color: #f37626;
  --jp-notebook-icon-color: #f37626;
  --jp-json-icon-color: var(--md-orange-500);
  --jp-console-icon-background-color: var(--md-blue-500);
  --jp-console-icon-color: white;
  --jp-terminal-icon-background-color: var(--md-grey-200);
  --jp-terminal-icon-color: var(--md-grey-800);
  --jp-text-editor-icon-color: var(--md-grey-200);
  --jp-inspector-icon-color: var(--md-grey-200);
  --jp-switch-color: var(--md-grey-400);
  --jp-switch-true-position-color: var(--md-orange-700);
}
</style>
<style type="text/css">
/* Force rendering true colors when outputing to pdf */
* {
  -webkit-print-color-adjust: exact;
}

/* Misc */
a.anchor-link {
  display: none;
}

/* Input area styling */
.jp-InputArea {
  overflow: hidden;
}

.jp-InputArea-editor {
  overflow: hidden;
}

.cm-editor.cm-s-jupyter .highlight pre {
/* weird, but --jp-code-padding defined to be 5px but 4px horizontal padding is hardcoded for pre.cm-line */
  padding: var(--jp-code-padding) 4px;
  margin: 0;

  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
  color: inherit;

}

.jp-OutputArea-output pre {
  line-height: inherit;
  font-family: inherit;
}

.jp-RenderedText pre {
  color: var(--jp-content-font-color1);
  font-size: var(--jp-code-font-size);
}

/* Hiding the collapser by default */
.jp-Collapser {
  display: none;
}

@page {
    margin: 0.5in; /* Margin for each printed piece of paper */
}

@media print {
  .jp-Cell-inputWrapper,
  .jp-Cell-outputWrapper {
    display: block;
  }
}
</style>
<!-- Load mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML-full,Safe"> </script>
<!-- MathJax configuration -->
<script type="text/x-mathjax-config">
    init_mathjax = function() {
        if (window.MathJax) {
        // MathJax loaded
            MathJax.Hub.Config({
                TeX: {
                    equationNumbers: {
                    autoNumber: "AMS",
                    useLabelIds: true
                    }
                },
                tex2jax: {
                    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
                    processEscapes: true,
                    processEnvironments: true
                },
                displayAlign: 'center',
                CommonHTML: {
                    linebreaks: {
                    automatic: true
                    }
                }
            });

            MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
        }
    }
    init_mathjax();
    </script>
<!-- End of mathjax configuration --><script type="module">
  document.addEventListener("DOMContentLoaded", async () => {
    const diagrams = document.querySelectorAll(".jp-Mermaid > pre.mermaid");
    // do not load mermaidjs if not needed
    if (!diagrams.length) {
      return;
    }
    const mermaid = (await import("https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.7.0/mermaid.esm.min.mjs")).default;
    const parser = new DOMParser();

    mermaid.initialize({
      maxTextSize: 100000,
      maxEdges: 100000,
      startOnLoad: false,
      fontFamily: window
        .getComputedStyle(document.body)
        .getPropertyValue("--jp-ui-font-family"),
      theme: document.querySelector("body[data-jp-theme-light='true']")
        ? "default"
        : "dark",
    });

    let _nextMermaidId = 0;

    function makeMermaidImage(svg) {
      const img = document.createElement("img");
      const doc = parser.parseFromString(svg, "image/svg+xml");
      const svgEl = doc.querySelector("svg");
      const { maxWidth } = svgEl?.style || {};
      const firstTitle = doc.querySelector("title");
      const firstDesc = doc.querySelector("desc");

      img.setAttribute("src", `data:image/svg+xml,${encodeURIComponent(svg)}`);
      if (maxWidth) {
        img.width = parseInt(maxWidth);
      }
      if (firstTitle) {
        img.setAttribute("alt", firstTitle.textContent);
      }
      if (firstDesc) {
        const caption = document.createElement("figcaption");
        caption.className = "sr-only";
        caption.textContent = firstDesc.textContent;
        return [img, caption];
      }
      return [img];
    }

    async function makeMermaidError(text) {
      let errorMessage = "";
      try {
        await mermaid.parse(text);
      } catch (err) {
        errorMessage = `${err}`;
      }

      const result = document.createElement("details");
      result.className = 'jp-RenderedMermaid-Details';
      const summary = document.createElement("summary");
      summary.className = 'jp-RenderedMermaid-Summary';
      const pre = document.createElement("pre");
      const code = document.createElement("code");
      code.innerText = text;
      pre.appendChild(code);
      summary.appendChild(pre);
      result.appendChild(summary);

      const warning = document.createElement("pre");
      warning.innerText = errorMessage;
      result.appendChild(warning);
      return [result];
    }

    async function renderOneMarmaid(src) {
      const id = `jp-mermaid-${_nextMermaidId++}`;
      const parent = src.parentNode;
      let raw = src.textContent.trim();
      const el = document.createElement("div");
      el.style.visibility = "hidden";
      document.body.appendChild(el);
      let results = null;
      let output = null;
      try {
        let { svg } = await mermaid.render(id, raw, el);
        svg = cleanMermaidSvg(svg);
        results = makeMermaidImage(svg);
        output = document.createElement("figure");
        results.map(output.appendChild, output);
      } catch (err) {
        parent.classList.add("jp-mod-warning");
        results = await makeMermaidError(raw);
        output = results[0];
      } finally {
        el.remove();
      }
      parent.classList.add("jp-RenderedMermaid");
      parent.appendChild(output);
    }


    /**
     * Post-process to ensure mermaid diagrams contain only valid SVG and XHTML.
     */
    function cleanMermaidSvg(svg) {
      return svg.replace(RE_VOID_ELEMENT, replaceVoidElement);
    }


    /**
     * A regular expression for all void elements, which may include attributes and
     * a slash.
     *
     * @see https://developer.mozilla.org/en-US/docs/Glossary/Void_element
     *
     * Of these, only `<br>` is generated by Mermaid in place of `\n`,
     * but _any_ "malformed" tag will break the SVG rendering entirely.
     */
    const RE_VOID_ELEMENT =
      /<\s*(area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr)\s*([^>]*?)\s*>/gi;

    /**
     * Ensure a void element is closed with a slash, preserving any attributes.
     */
    function replaceVoidElement(match, tag, rest) {
      rest = rest.trim();
      if (!rest.endsWith('/')) {
        rest = `${rest} /`;
      }
      return `<${tag} ${rest}>`;
    }

    void Promise.all([...diagrams].map(renderOneMarmaid));
  });
</script>
<style>
  .jp-Mermaid:not(.jp-RenderedMermaid) {
    display: none;
  }

  .jp-RenderedMermaid {
    overflow: auto;
    display: flex;
  }

  .jp-RenderedMermaid.jp-mod-warning {
    width: auto;
    padding: 0.5em;
    margin-top: 0.5em;
    border: var(--jp-border-width) solid var(--jp-warn-color2);
    border-radius: var(--jp-border-radius);
    color: var(--jp-ui-font-color1);
    font-size: var(--jp-ui-font-size1);
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .jp-RenderedMermaid figure {
    margin: 0;
    overflow: auto;
    max-width: 100%;
  }

  .jp-RenderedMermaid img {
    max-width: 100%;
  }

  .jp-RenderedMermaid-Details > pre {
    margin-top: 1em;
  }

  .jp-RenderedMermaid-Summary {
    color: var(--jp-warn-color2);
  }

  .jp-RenderedMermaid:not(.jp-mod-warning) pre {
    display: none;
  }

  .jp-RenderedMermaid-Summary > pre {
    display: inline-block;
    white-space: normal;
  }
</style>
<!-- End of mermaid configuration --></head>
<body class="jp-Notebook" data-jp-theme-light="false" data-jp-theme-name="JupyterLab Dark">
<main>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=1">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h1 id="documents">documents<a class="anchor-link" href="#documents">¶</a></h1>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=2">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [ ]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="nb">open</span> <span class="n">file_system_operators</span>
<span class="nb">open</span> <span class="n">sm</span><span class="s1">'_operators</span>
<span class="nb">open</span> <span class="n">rust_operators</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>()

</pre>
</div>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=3">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [ ]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="o">////</span> <span class="n">test</span>

<span class="nb">open</span> <span class="n">testing</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>()

</pre>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=4">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h2 id="types">types<a class="anchor-link" href="#types">¶</a></h2>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=5">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [ ]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">inl</span> <span class="n">types</span> <span class="p">()</span> <span class="o">=</span>
    <span class="n">am</span><span class="s1">'.types ()</span>
    <span class="k">async</span><span class="o">.</span><span class="n">types</span> <span class="p">()</span>
    <span class="n">crypto</span><span class="o">.</span><span class="n">types</span> <span class="p">()</span>
    <span class="n">file_system</span><span class="o">.</span><span class="n">types</span> <span class="p">()</span>
    <span class="n">runtime</span><span class="o">.</span><span class="n">types</span> <span class="p">()</span>
    <span class="n">rust</span><span class="o">.</span><span class="n">types</span> <span class="p">()</span>
    <span class="n">sm</span><span class="s1">'.types ()</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>()

</pre>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=6">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h2 id="args">args<a class="anchor-link" href="#args">¶</a></h2>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=7">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [ ]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">inl</span> <span class="n">get_args</span> <span class="p">()</span> <span class="o">=</span>
    <span class="p">{</span>
        <span class="n">source_dir</span> <span class="o">=</span> <span class="s2">"source-dir"</span>
        <span class="n">dist_dir</span> <span class="o">=</span> <span class="s2">"dist-dir"</span>
        <span class="n">cache_dir</span> <span class="o">=</span> <span class="s2">"cache-dir"</span>
        <span class="n">hangul_spec</span> <span class="o">=</span> <span class="s2">"hangul-spec"</span>
    <span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>()

</pre>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=8">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h2 id="get_command">get_command<a class="anchor-link" href="#get_command">¶</a></h2>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=9">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [ ]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">let</span> <span class="n">get_command</span> <span class="p">()</span> <span class="o">=</span>
    <span class="c1">##"command"</span>
    <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">new_command</span>
    <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">command_arg</span> <span class="p">(</span>
        <span class="n">runtime</span><span class="o">.</span><span class="n">new_arg</span> <span class="c1">##(get_args () .source_dir)</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">arg_short</span> <span class="s1">'s'</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">arg_long</span> <span class="c1">##(get_args () .source_dir)</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">arg_required</span> <span class="n">true</span>
    <span class="p">)</span>
    <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">command_arg</span> <span class="p">(</span>
        <span class="n">runtime</span><span class="o">.</span><span class="n">new_arg</span> <span class="c1">##(get_args () .dist_dir)</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">arg_short</span> <span class="s1">'d'</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">arg_long</span> <span class="c1">##(get_args () .dist_dir)</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">arg_required</span> <span class="n">true</span>
    <span class="p">)</span>
    <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">command_arg</span> <span class="p">(</span>
        <span class="n">runtime</span><span class="o">.</span><span class="n">new_arg</span> <span class="c1">##(get_args () .cache_dir)</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">arg_short</span> <span class="s1">'c'</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">arg_long</span> <span class="c1">##(get_args () .cache_dir)</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">arg_required</span> <span class="n">true</span>
    <span class="p">)</span>
    <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">command_arg</span> <span class="p">(</span>
        <span class="n">runtime</span><span class="o">.</span><span class="n">new_arg</span> <span class="c1">##(get_args () .hangul_spec)</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">arg_short</span> <span class="s1">'s'</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">arg_long</span> <span class="c1">##(get_args () .hangul_spec)</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">arg_required</span> <span class="n">true</span>
    <span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>()

</pre>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=10">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h2 id="crowbook">crowbook<a class="anchor-link" href="#crowbook">¶</a></h2>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=11">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [ ]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">let</span> <span class="n">crowbook</span> <span class="p">{</span> <span class="n">ext</span> <span class="n">dist_dir</span> <span class="n">dist_path</span> <span class="n">output_path</span> <span class="p">}</span> <span class="o">=</span>

    <span class="n">inl</span> <span class="n">exit_code</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span>
        <span class="n">runtime</span><span class="o">.</span><span class="n">execution_options</span> <span class="n">fun</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="n">x</span> <span class="k">with</span>
            <span class="n">command</span> <span class="o">=</span> <span class="err">$</span><span class="s1">'$"crowbook --single </span><span class="se">\\\"</span><span class="s1">{!dist_path}</span><span class="se">\\\"</span><span class="s1"> --output </span><span class="se">\\\"</span><span class="s1">{!output_path}</span><span class="se">\\\"</span><span class="s1"> --to {!ext} --set rendering.num_depth 6 html.css.add </span><span class="se">\\\\\\</span><span class="s1">"</span><span class="se">\'</span><span class="s1"> body {{ color: #e8e6e3; background-color: #202324; }} a {{ color: #989693; }} </span><span class="se">\'\\\\\\</span><span class="s1">""'</span>
            <span class="n">working_directory</span> <span class="o">=</span> <span class="n">dist_dir</span> <span class="o">|&gt;</span> <span class="n">Some</span> <span class="o">|&gt;</span> <span class="n">optionm</span><span class="s1">'.box</span>
        <span class="p">}</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">execute_with_options</span>

    <span class="k">if</span> <span class="n">result</span> <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.contains "ERROR" then</span>
        <span class="n">trace</span> <span class="ne">Warning</span>
            <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'"documents.crowbook / result contains ERROR"'</span>
            <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'$"exit_code: %A{!exit_code} / output_path: {!output_path} / result: {!result} / {!_locals ()}"'</span>
        <span class="p">(</span><span class="n">exit_code</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="n">Error</span>
    <span class="k">else</span> <span class="p">(</span><span class="n">exit_code</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="n">Ok</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>()

</pre>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=12">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h2 id="hangul">hangul<a class="anchor-link" href="#hangul">¶</a></h2>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=13">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [ ]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">let</span> <span class="n">hangul</span> <span class="n">workspace_root</span> <span class="n">hangul_spec</span> <span class="p">{</span> <span class="n">ext</span> <span class="n">dist_dir</span> <span class="n">dist_path</span> <span class="n">output_path</span> <span class="p">}</span> <span class="o">=</span>
    <span class="n">inl</span> <span class="n">lines</span> <span class="o">=</span>
        <span class="n">dist_path</span>
        <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">read_all_text</span>
        <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.split "</span><span class="se">\n</span><span class="s1">"</span>
        <span class="o">|&gt;</span> <span class="n">fun</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="n">x</span> <span class="p">:</span> <span class="n">_</span> <span class="n">i32</span> <span class="n">_</span>
        <span class="o">|&gt;</span> <span class="n">am</span><span class="o">.</span><span class="n">map</span> <span class="n">sm</span><span class="s1">'.trim</span>
    <span class="n">inl</span> <span class="n">text</span> <span class="o">=</span>
        <span class="n">lines</span>
        <span class="o">|&gt;</span> <span class="n">am</span><span class="o">.</span><span class="n">filter</span> <span class="p">((</span><span class="o">&lt;&gt;.</span><span class="p">)</span> <span class="s2">""</span><span class="p">)</span>
        <span class="o">|&gt;</span> <span class="n">seq</span><span class="o">.</span><span class="n">of_array</span><span class="s1">'</span>
        <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.concat "</span><span class="se">\n</span><span class="s1">"</span>
        <span class="o">|&gt;</span> <span class="n">fun</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'$"{!x}</span><span class="se">\n\n</span><span class="s1">"'</span>

    <span class="n">inl</span> <span class="n">exit_code</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span>
        <span class="n">runtime</span><span class="o">.</span><span class="n">execution_options</span> <span class="n">fun</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="n">x</span> <span class="k">with</span>
            <span class="n">command</span> <span class="o">=</span>
                <span class="n">inl</span> <span class="n">hangulize_path</span> <span class="o">=</span>
                    <span class="n">inl</span> <span class="n">_exe</span> <span class="o">=</span> <span class="n">runtime</span><span class="o">.</span><span class="n">get_executable_suffix</span> <span class="p">()</span>
                    <span class="n">workspace_root</span> <span class="o">&lt;/&gt;</span> <span class="err">$</span><span class="s1">'$"../vault/deps/hangulize/cmd/hangulize/hangulize{!_exe}"'</span>
                <span class="err">$</span><span class="s1">'$"{!hangulize_path} {!hangul_spec}"'</span>
            <span class="n">stdin</span> <span class="o">=</span>
                <span class="n">fun</span> <span class="n">stdin</span> <span class="o">=&gt;</span>
                    <span class="n">inl</span> <span class="n">stdin</span> <span class="o">=</span>
                        <span class="n">stdin</span>
                        <span class="o">|&gt;</span> <span class="n">threading</span><span class="o">.</span><span class="n">arc_mutex_lock</span>
                        <span class="o">|&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">unwrap</span><span class="s1">'</span>
                    <span class="n">text</span> <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">stdin_write_all</span> <span class="n">stdin</span>
                <span class="o">|&gt;</span> <span class="n">Some</span> <span class="o">|&gt;</span> <span class="n">optionm</span><span class="s1">'.box</span>
        <span class="p">}</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">execute_with_options</span>

    <span class="n">inl</span> <span class="n">result</span> <span class="p">:</span> <span class="n">string</span> <span class="o">=</span>
        <span class="n">inl</span> <span class="n">result</span> <span class="o">=</span>
            <span class="n">result</span>
            <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.split "</span><span class="se">\n</span><span class="s1">"</span>
            <span class="o">|&gt;</span> <span class="n">fun</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="n">x</span> <span class="p">:</span> <span class="n">_</span> <span class="n">i32</span> <span class="n">_</span>
        <span class="n">inl</span> <span class="n">result_len</span> <span class="o">=</span> <span class="n">result</span> <span class="o">|&gt;</span> <span class="n">am</span><span class="s1">'.length</span>

        <span class="p">((</span><span class="s2">""</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="n">i32</span><span class="p">,</span> <span class="mi">0</span><span class="n">i32</span><span class="p">)),</span> <span class="n">lines</span><span class="p">)</span>
        <span class="o">||&gt;</span> <span class="n">am</span><span class="o">.</span><span class="n">fold</span> <span class="n">fun</span> <span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="n">x</span> <span class="o">=&gt;</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">=</span> <span class="s2">""</span>
            <span class="n">then</span> <span class="err">$</span><span class="s1">'$"{!acc}</span><span class="se">\n</span><span class="s1">"'</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span>
                <span class="n">inl</span> <span class="n">acc</span> <span class="o">=</span>
                    <span class="n">inl</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">n</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">result_len</span>
                    <span class="n">then</span> <span class="n">acc</span>
                    <span class="k">else</span>
                        <span class="n">inl</span> <span class="n">line</span> <span class="o">=</span> <span class="n">result</span> <span class="o">|&gt;</span> <span class="n">am</span><span class="s1">'.index i</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">=</span> <span class="n">result_len</span> <span class="o">-</span> <span class="mi">1</span>
                        <span class="n">then</span> <span class="err">$</span><span class="s1">'$"{!acc}{!line}"'</span>
                        <span class="k">else</span> <span class="err">$</span><span class="s1">'$"{!acc}{!line}</span><span class="se">\n</span><span class="s1">"'</span>
                <span class="n">acc</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="o">|&gt;</span> <span class="n">fst</span>

    <span class="n">result</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">write_all_text</span> <span class="n">output_path</span>

    <span class="n">trace</span> <span class="n">Info</span>
        <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'"documents.hangul"'</span>
        <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span>
            <span class="n">inl</span> <span class="n">result_len</span> <span class="p">:</span> <span class="n">i32</span> <span class="o">=</span> <span class="n">result</span> <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.length</span>
            <span class="err">$</span><span class="s1">'$"exit_code: %A{!exit_code} / result_len: {!result_len} / output_path: {!output_path} / {!_locals ()}"'</span>

    <span class="p">(</span><span class="n">exit_code</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="n">Ok</span>
    <span class="o">|&gt;</span> <span class="n">fun</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">x</span> <span class="p">:</span> <span class="n">result</span> <span class="p">(</span><span class="n">i32</span> <span class="o">*</span> <span class="n">string</span><span class="p">)</span> <span class="p">(</span><span class="n">i32</span> <span class="o">*</span> <span class="n">string</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>()

</pre>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=14">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h2 id="fix_paths">fix_paths<a class="anchor-link" href="#fix_paths">¶</a></h2>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=15">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [ ]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">let</span> <span class="n">fix_paths</span> <span class="p">{</span> <span class="n">cache_dir</span> <span class="n">dist_path</span> <span class="n">ext</span> <span class="p">}</span> <span class="o">=</span>
    <span class="n">inl</span> <span class="n">file_name</span> <span class="o">=</span> <span class="n">dist_path</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">get_file_name</span>
    <span class="n">inl</span> <span class="n">cache_path</span> <span class="o">=</span> <span class="n">cache_dir</span> <span class="o">&lt;/&gt;</span> <span class="n">file_name</span>
    <span class="n">inl</span> <span class="n">dist_path_no_ext</span> <span class="o">=</span>
        <span class="n">dist_path</span>
        <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.slice 0 ((dist_path |&gt; sm'</span><span class="o">.</span><span class="n">last_index_of</span> <span class="s2">"."</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">inl</span> <span class="n">cache_path_no_ext</span> <span class="o">=</span>
        <span class="n">cache_path</span>
        <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.slice 0 ((cache_path |&gt; sm'</span><span class="o">.</span><span class="n">last_index_of</span> <span class="s2">"."</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">inl</span> <span class="n">is_md</span> <span class="o">=</span> <span class="n">ext</span> <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.ends_with ".md"</span>
    <span class="n">inl</span> <span class="n">output_path</span> <span class="p">:</span> <span class="n">string</span> <span class="o">=</span>
        <span class="k">if</span> <span class="n">is_md</span> <span class="o">|&gt;</span> <span class="ow">not</span>
        <span class="n">then</span> <span class="err">$</span><span class="s1">'$"{!dist_path}.{!ext}"'</span>
        <span class="k">else</span> <span class="err">$</span><span class="s1">'$"{!dist_path_no_ext}.{!ext}"'</span>
    <span class="n">inl</span> <span class="n">output_cache_path</span> <span class="p">:</span> <span class="n">string</span> <span class="o">=</span>
        <span class="k">if</span> <span class="n">is_md</span> <span class="o">|&gt;</span> <span class="ow">not</span>
        <span class="n">then</span> <span class="err">$</span><span class="s1">'$"{!cache_path}.{!ext}"'</span>
        <span class="k">else</span> <span class="err">$</span><span class="s1">'$"{!cache_path_no_ext}.{!ext}"'</span>
    <span class="p">{</span> <span class="n">output_path</span> <span class="n">output_cache_path</span> <span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>()

</pre>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=16">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h2 id="files_fn">files_fn<a class="anchor-link" href="#files_fn">¶</a></h2>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=17">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [ ]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">inl</span> <span class="n">files_fn</span> <span class="p">{</span> <span class="n">dist_dir</span> <span class="n">cache_dir</span> <span class="p">}</span> <span class="n">fn</span> <span class="n">dist_path</span> <span class="n">ext</span> <span class="o">=</span>
    <span class="n">inl</span> <span class="p">{</span> <span class="n">output_path</span> <span class="n">output_cache_path</span> <span class="p">}</span> <span class="o">=</span> <span class="n">fix_paths</span> <span class="p">{</span> <span class="n">cache_dir</span> <span class="n">dist_path</span> <span class="n">ext</span> <span class="p">}</span>
    <span class="n">inl</span> <span class="n">equal</span> <span class="o">=</span>
        <span class="k">if</span> <span class="n">file_system</span><span class="o">.</span><span class="n">file_exists</span> <span class="n">output_path</span>
            <span class="o">&amp;&amp;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">file_exists</span> <span class="n">output_cache_path</span> <span class="n">then</span>
            <span class="n">inl</span> <span class="n">output_hash</span> <span class="o">=</span> <span class="n">output_path</span> <span class="o">|&gt;</span> <span class="n">crypto</span><span class="o">.</span><span class="n">get_file_hash</span> <span class="o">|&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">get</span>
            <span class="n">inl</span> <span class="n">output_cache_hash</span> <span class="o">=</span> <span class="n">output_cache_path</span> <span class="o">|&gt;</span> <span class="n">crypto</span><span class="o">.</span><span class="n">get_file_hash</span> <span class="o">|&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">get</span>
            <span class="n">output_hash</span> <span class="o">=</span> <span class="n">output_cache_hash</span>
        <span class="k">else</span> <span class="n">false</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">equal</span>
    <span class="n">then</span>
        <span class="k">match</span> <span class="n">fn</span> <span class="p">{</span> <span class="n">ext</span> <span class="n">dist_dir</span> <span class="n">dist_path</span> <span class="n">output_path</span> <span class="p">}</span> <span class="k">with</span>
        <span class="o">|</span> <span class="n">Ok</span> <span class="p">(</span><span class="n">exit_code</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span> <span class="n">when</span> <span class="n">exit_code</span> <span class="o">&lt;&gt;.</span> <span class="mi">0</span> <span class="o">=&gt;</span>
            <span class="n">trace</span> <span class="n">Info</span>
                <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'"documents.files_fn / error"'</span>
                <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'$"exit_code: %A{!exit_code} / result: {!result} / {!_locals ()}"'</span>
            <span class="n">new_pair</span> <span class="n">output_path</span> <span class="n">result</span> <span class="o">|&gt;</span> <span class="n">Error</span> <span class="o">|&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">box</span> <span class="o">|&gt;</span> <span class="n">Some</span>
        <span class="o">|</span> <span class="n">Error</span> <span class="p">(</span><span class="n">exit_code</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span> <span class="o">=&gt;</span>
            <span class="n">new_pair</span> <span class="n">output_path</span> <span class="n">result</span> <span class="o">|&gt;</span> <span class="n">Error</span> <span class="o">|&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">box</span> <span class="o">|&gt;</span> <span class="n">Some</span>
        <span class="o">|</span> <span class="n">_</span> <span class="o">=&gt;</span>
            <span class="k">if</span> <span class="n">output_path</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">file_exists</span>
            <span class="n">then</span> <span class="n">output_path</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">file_copy</span> <span class="n">output_cache_path</span>
            <span class="k">else</span> <span class="n">failwith</span> <span class="err">$</span><span class="s1">'$"documents.files_fn / {!output_path} should exist"'</span>
            <span class="n">output_path</span> <span class="o">|&gt;</span> <span class="n">Ok</span> <span class="o">|&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">box</span> <span class="o">|&gt;</span> <span class="n">Some</span>
    <span class="k">else</span> <span class="kc">None</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>()

</pre>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=18">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h2 id="run">run<a class="anchor-link" href="#run">¶</a></h2>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=19">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [ ]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">let</span> <span class="n">run</span> <span class="p">{</span> <span class="n">source_dir</span> <span class="n">dist_dir</span> <span class="n">cache_dir</span> <span class="n">hangul_spec</span> <span class="p">}</span>
    <span class="p">:</span> <span class="k">async</span><span class="o">.</span><span class="n">future_pin</span> <span class="p">(</span><span class="n">resultm</span><span class="o">.</span><span class="n">result</span><span class="s1">' (am'</span><span class="o">.</span><span class="n">vec</span> <span class="p">(</span><span class="n">resultm</span><span class="o">.</span><span class="n">result</span><span class="s1">' (pair string (am'</span><span class="o">.</span><span class="n">vec</span> <span class="p">(</span><span class="n">optionm</span><span class="s1">'.option'</span> <span class="p">(</span><span class="n">resultm</span><span class="o">.</span><span class="n">result</span><span class="s1">' string (pair string string))))) sm'</span><span class="o">.</span><span class="n">std_string</span><span class="p">))</span> <span class="n">sm</span><span class="s1">'.std_string) =</span>

    <span class="n">inl</span> <span class="n">workspace_root</span> <span class="o">=</span> <span class="n">file_system</span><span class="o">.</span><span class="n">get_workspace_root</span> <span class="p">()</span>

    <span class="n">inl</span> <span class="n">source_dir</span> <span class="o">=</span> <span class="n">source_dir</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">get_full_path</span>
    <span class="n">inl</span> <span class="n">dist_dir</span> <span class="o">=</span> <span class="n">dist_dir</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">get_full_path</span>
    <span class="n">inl</span> <span class="n">cache_dir</span> <span class="o">=</span> <span class="n">cache_dir</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">get_full_path</span>

    <span class="n">trace</span> <span class="n">Debug</span>
        <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'"documents.run"'</span>
        <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'$"source_dir: {!source_dir} / dist_dir: {!dist_dir} / cache_dir: {!cache_dir} / hangul_spec: %A{!hangul_spec} / {!_locals ()}"'</span>

    <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span>
        <span class="n">inl</span> <span class="n">files</span> <span class="o">=</span>
            <span class="n">dist_dir</span>
            <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">new_walk_dir</span>
            <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">walk_dir_filter</span> <span class="n">fun</span> <span class="n">entry</span> <span class="o">=&gt;</span> <span class="k">async</span><span class="o">.</span><span class="n">future_init_send</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">1</span> <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span>
                <span class="n">entry</span>
                <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">dir_entry_file_type</span>
                <span class="o">|&gt;</span> <span class="k">async</span><span class="o">.</span><span class="n">await_send</span>
                <span class="o">|&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">map_error</span><span class="s1">' sm'</span><span class="o">.</span><span class="n">format</span><span class="s1">'</span>
                <span class="o">|&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">unbox</span>
                <span class="o">|&gt;</span> <span class="n">function</span>
                    <span class="o">|</span> <span class="n">Ok</span> <span class="n">file_type</span> <span class="n">when</span> <span class="n">file_type</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">file_type_is_dir</span> <span class="o">=&gt;</span>
                        <span class="n">file_system</span><span class="o">.</span><span class="n">Ignore</span>
                    <span class="o">|</span> <span class="n">_</span> <span class="o">=&gt;</span>
                        <span class="n">inl</span> <span class="n">path</span> <span class="o">=</span>
                            <span class="n">entry</span>
                            <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">dir_entry_path</span>
                            <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">path_buf_display</span>
                            <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.format'</span>
                            <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.from_std_string</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">path</span> <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.ends_with ".md" |&gt; not) || (path |&gt; sm'</span><span class="o">.</span><span class="n">ends_with</span> <span class="s2">".hangul.md"</span><span class="p">)</span>
                        <span class="n">then</span> <span class="n">file_system</span><span class="o">.</span><span class="n">Ignore</span>
                        <span class="k">else</span> <span class="n">file_system</span><span class="o">.</span><span class="n">Continue</span>
            <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">stream_filter_map</span> <span class="n">fun</span> <span class="n">entry</span> <span class="o">=&gt;</span>
                <span class="k">match</span> <span class="n">entry</span> <span class="o">|&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">map_error</span><span class="s1">' sm'</span><span class="o">.</span><span class="n">format</span><span class="s1">' |&gt; resultm.unbox with</span>
                <span class="o">|</span> <span class="n">Ok</span> <span class="n">entry</span> <span class="o">=&gt;</span>
                    <span class="n">entry</span>
                    <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">dir_entry_path</span>
                    <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">path_buf_display</span>
                    <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.format'</span>
                    <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.from_std_string</span>
                    <span class="o">|&gt;</span> <span class="n">Some</span>
                <span class="o">|</span> <span class="n">Error</span> <span class="n">error</span> <span class="o">=&gt;</span>
                    <span class="n">trace</span> <span class="n">Critical</span>
                        <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'"documents.run / stream_filter_map"'</span>
                        <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'$"error: {!error} / {!_locals ()}"'</span>
                    <span class="kc">None</span>
                <span class="o">|&gt;</span> <span class="n">optionm</span><span class="s1">'.box</span>

        <span class="n">trace</span> <span class="n">Debug</span>
            <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'"documents.run"'</span>
            <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span>
                <span class="n">inl</span> <span class="n">files_len</span> <span class="o">=</span> <span class="n">files</span> <span class="o">|&gt;</span> <span class="n">am</span><span class="s1">'.vec_len</span>
                <span class="err">$</span><span class="s1">'$"files_len: {!files_len} / {!_locals ()}"'</span>

        <span class="n">inl</span> <span class="n">result</span> <span class="o">=</span>
            <span class="n">files</span>
            <span class="o">|&gt;</span> <span class="k">async</span><span class="o">.</span><span class="n">into_par_iter</span>
            <span class="o">|&gt;</span> <span class="k">async</span><span class="o">.</span><span class="n">par_map</span> <span class="n">fun</span> <span class="n">file</span> <span class="o">=&gt;</span>
                <span class="n">inl</span> <span class="n">file</span> <span class="o">=</span> <span class="n">file</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">get_full_path</span>

                <span class="n">inl</span> <span class="n">relative_path</span> <span class="o">=</span>
                    <span class="n">file</span>
                    <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.to_std_string</span>
                    <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">new_path_buf</span>
                    <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">path_buf_display</span>
                    <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.format'</span>
                    <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.from_std_string</span>
                    <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.replace dist_dir ""</span>
                    <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.replace "</span><span class="se">\\</span><span class="s1">" "/"</span>
                    <span class="o">|&gt;</span> <span class="n">fun</span> <span class="n">s</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'$".</span><span class="si">{!s}</span><span class="s1">"'</span>

                <span class="n">inl</span> <span class="n">file</span> <span class="o">=</span> <span class="n">file</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">normalize_path</span>

                <span class="n">inl</span> <span class="n">real_path</span> <span class="o">=</span> <span class="n">source_dir</span> <span class="o">&lt;/&gt;</span> <span class="n">relative_path</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">standardize_path</span>

                <span class="n">inl</span> <span class="n">origin_hash_exit_code</span><span class="p">,</span> <span class="n">origin_hash</span> <span class="o">=</span>
                    <span class="n">runtime</span><span class="o">.</span><span class="n">execution_options</span> <span class="n">fun</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="n">x</span> <span class="k">with</span>
                        <span class="n">command</span> <span class="o">=</span> <span class="err">$</span><span class="s1">'$"git ls-tree --format=</span><span class="se">\'</span><span class="si">%%</span><span class="s1">(objectname)</span><span class="se">\'</span><span class="s1"> origin/gh-pages </span><span class="se">\\</span><span class="s1">"{!real_path}</span><span class="se">\\</span><span class="s1">""'</span>
                        <span class="n">working_directory</span> <span class="o">=</span> <span class="n">source_dir</span> <span class="o">|&gt;</span> <span class="n">Some</span> <span class="o">|&gt;</span> <span class="n">optionm</span><span class="s1">'.box</span>
                    <span class="p">}</span>
                    <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">execute_with_options</span>

                <span class="n">inl</span> <span class="n">dist_path</span> <span class="o">=</span> <span class="n">dist_dir</span> <span class="o">&lt;/&gt;</span> <span class="n">relative_path</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">standardize_path</span>

                <span class="n">inl</span> <span class="n">local_git_hash_exit_code</span><span class="p">,</span> <span class="n">local_git_hash</span> <span class="o">=</span>
                    <span class="n">runtime</span><span class="o">.</span><span class="n">execution_options</span> <span class="n">fun</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="n">x</span> <span class="k">with</span>
                        <span class="n">command</span> <span class="o">=</span> <span class="err">$</span><span class="s1">'$"git hash-object </span><span class="se">\\</span><span class="s1">"{!dist_path}</span><span class="se">\\</span><span class="s1">""'</span>
                        <span class="n">working_directory</span> <span class="o">=</span> <span class="n">dist_dir</span> <span class="o">|&gt;</span> <span class="n">Some</span> <span class="o">|&gt;</span> <span class="n">optionm</span><span class="s1">'.box</span>
                    <span class="p">}</span>
                    <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">execute_with_options</span>

                <span class="n">inl</span> <span class="n">cache_path</span> <span class="o">=</span> <span class="n">cache_dir</span> <span class="o">&lt;/&gt;</span> <span class="n">relative_path</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">standardize_path</span>

                <span class="n">inl</span> <span class="n">files</span> <span class="o">=</span>
                    <span class="n">inl</span> <span class="n">files_fn</span> <span class="o">=</span> <span class="n">files_fn</span> <span class="p">{</span> <span class="n">dist_dir</span> <span class="n">cache_dir</span> <span class="p">}</span>
                    <span class="n">inl</span> <span class="n">files</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="s2">"hangul.md"</span><span class="p">,</span> <span class="n">dist_path</span><span class="p">,</span> <span class="n">hangul</span> <span class="n">workspace_root</span> <span class="n">hangul_spec</span> <span class="o">|&gt;</span> <span class="n">files_fn</span>
                    <span class="p">]</span>

                    <span class="n">inl</span> <span class="p">{</span> <span class="n">output_path</span> <span class="p">}</span> <span class="o">=</span> <span class="n">fix_paths</span> <span class="p">{</span> <span class="n">dist_path</span> <span class="n">cache_dir</span> <span class="n">ext</span> <span class="o">=</span> <span class="s2">"hangul.md"</span> <span class="p">}</span>

                    <span class="n">inl</span> <span class="n">files</span><span class="s1">' = [</span>
                        <span class="s2">"html"</span><span class="p">,</span> <span class="n">dist_path</span><span class="p">,</span> <span class="n">crowbook</span> <span class="o">|&gt;</span> <span class="n">files_fn</span>
                        <span class="s2">"pdf"</span><span class="p">,</span> <span class="n">dist_path</span><span class="p">,</span> <span class="n">crowbook</span> <span class="o">|&gt;</span> <span class="n">files_fn</span>
                        <span class="s2">"epub"</span><span class="p">,</span> <span class="n">dist_path</span><span class="p">,</span> <span class="n">crowbook</span> <span class="o">|&gt;</span> <span class="n">files_fn</span>
                        <span class="s2">"html"</span><span class="p">,</span> <span class="n">output_path</span><span class="p">,</span> <span class="n">crowbook</span> <span class="o">|&gt;</span> <span class="n">files_fn</span>
                        <span class="s2">"pdf"</span><span class="p">,</span> <span class="n">output_path</span><span class="p">,</span> <span class="n">crowbook</span> <span class="o">|&gt;</span> <span class="n">files_fn</span>
                        <span class="s2">"epub"</span><span class="p">,</span> <span class="n">output_path</span><span class="p">,</span> <span class="n">crowbook</span> <span class="o">|&gt;</span> <span class="n">files_fn</span>
                    <span class="p">]</span>

                    <span class="p">[</span> <span class="n">files</span><span class="p">;</span> <span class="n">files</span><span class="s1">' ]</span>

                <span class="n">inl</span> <span class="n">files</span><span class="s1">' =</span>
                    <span class="k">if</span> <span class="n">origin_hash</span> <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.contains local_git_hash |&gt; not then</span>
                        <span class="n">inl</span> <span class="n">hash1</span> <span class="o">=</span> <span class="n">dist_path</span> <span class="o">|&gt;</span> <span class="n">crypto</span><span class="o">.</span><span class="n">get_file_hash</span> <span class="o">|&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">get</span>
                        <span class="n">inl</span> <span class="n">hash2</span> <span class="o">=</span>
                            <span class="k">if</span> <span class="n">cache_path</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">file_exists</span>
                            <span class="n">then</span> <span class="n">cache_path</span> <span class="o">|&gt;</span> <span class="n">crypto</span><span class="o">.</span><span class="n">get_file_hash</span> <span class="o">|&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">ok</span>
                            <span class="k">else</span> <span class="kc">None</span>

                        <span class="k">if</span> <span class="n">hash2</span> <span class="o">=</span> <span class="kc">None</span> <span class="o">||</span> <span class="n">hash1</span> <span class="o">&lt;&gt;.</span> <span class="p">(</span><span class="n">hash2</span> <span class="o">|&gt;</span> <span class="n">optionm</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="n">then</span>
                            <span class="n">trace</span> <span class="n">Info</span>
                                <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'"documents.run / par_map / origin_hash |&gt; sm</span><span class="se">\'</span><span class="s1">.contains local_git_hash |&gt; not / hash2 = None || hash1 &lt;&gt;. (hash2 |&gt; optionm.value)"'</span>
                                <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'$"file: {!file} / real_path: {!real_path} / relative_path: {!relative_path} / origin_hash_exit_code: {!origin_hash_exit_code} / origin_hash: {!origin_hash} / local_git_hash_exit_code: {!local_git_hash_exit_code} / local_git_hash: {!local_git_hash} / hash1: {!hash1} / hash2: %A{!hash2} / dist_path: {!dist_path} / cache_path: {!cache_path} / {!_locals ()}"'</span>
                            <span class="n">dist_path</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">file_copy</span> <span class="n">cache_path</span>
                            <span class="n">files</span>
                        <span class="k">else</span> <span class="p">[]</span>
                    <span class="k">else</span> <span class="p">[]</span>

                <span class="n">inl</span> <span class="n">files</span><span class="s1">' =</span>
                    <span class="k">if</span> <span class="n">files</span><span class="s1">' &lt;&gt; []</span>
                    <span class="n">then</span> <span class="n">files</span><span class="s1">'</span>
                    <span class="k">else</span>
                        <span class="n">files</span>
                        <span class="o">|&gt;</span> <span class="n">listm</span><span class="o">.</span><span class="n">map</span> <span class="n">fun</span> <span class="n">files</span> <span class="o">=&gt;</span>
                            <span class="n">files</span>
                            <span class="o">|&gt;</span> <span class="n">listm</span><span class="s1">'.filter fun ext, path, fn =&gt;</span>
                                <span class="n">inl</span> <span class="p">{</span> <span class="n">output_path</span> <span class="n">output_cache_path</span> <span class="p">}</span> <span class="o">=</span>
                                    <span class="n">fix_paths</span> <span class="p">{</span> <span class="n">cache_dir</span> <span class="n">dist_path</span> <span class="o">=</span> <span class="n">path</span><span class="p">;</span> <span class="n">ext</span> <span class="p">}</span>
                                <span class="k">if</span> <span class="n">output_path</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">file_exists</span> <span class="o">|&gt;</span> <span class="ow">not</span> <span class="n">then</span>
                                    <span class="k">if</span> <span class="n">file_system</span><span class="o">.</span><span class="n">file_exists</span> <span class="n">output_cache_path</span> <span class="n">then</span>
                                        <span class="n">trace</span> <span class="n">Info</span>
                                            <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'"documents.run / par_map / files</span><span class="se">\'</span><span class="s1"> = [] / listm.iter"'</span>
                                            <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'$"output_path: %A{!output_path} / output_cache_path: {!output_cache_path} / {!_locals ()}"'</span>
                                        <span class="n">output_cache_path</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">file_copy</span> <span class="n">output_path</span>
                                        <span class="n">false</span>
                                    <span class="k">else</span> <span class="n">true</span>
                                <span class="k">else</span> <span class="n">true</span>

                <span class="n">inl</span> <span class="n">files</span> <span class="o">=</span>
                    <span class="n">files</span><span class="s1">'</span>
                    <span class="o">|&gt;</span> <span class="n">listm</span><span class="s1">'.box</span>
                    <span class="o">|&gt;</span> <span class="n">listm</span><span class="s1">'.to_array'</span>
                    <span class="o">|&gt;</span> <span class="n">fun</span> <span class="p">(</span><span class="n">a</span> <span class="n">x</span> <span class="p">:</span> <span class="n">_</span> <span class="n">i32</span> <span class="n">_</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">x</span>
                    <span class="o">|&gt;</span> <span class="n">am</span><span class="s1">'.to_vec</span>
                    <span class="o">|&gt;</span> <span class="n">am</span><span class="s1">'.vec_collect fun files =&gt;</span>
                        <span class="n">files</span>
                        <span class="o">|&gt;</span> <span class="n">listm</span><span class="s1">'.box</span>
                        <span class="o">|&gt;</span> <span class="n">listm</span><span class="s1">'.to_array'</span>
                        <span class="o">|&gt;</span> <span class="n">fun</span> <span class="p">(</span><span class="n">a</span> <span class="n">x</span> <span class="p">:</span> <span class="n">_</span> <span class="n">i32</span> <span class="n">_</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">x</span>
                        <span class="o">|&gt;</span> <span class="n">am</span><span class="s1">'.to_vec</span>
                        <span class="o">|&gt;</span> <span class="k">async</span><span class="o">.</span><span class="n">into_par_iter</span>
                        <span class="o">|&gt;</span> <span class="k">async</span><span class="o">.</span><span class="n">par_map</span> <span class="n">fun</span> <span class="n">ext</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">fn</span> <span class="o">=&gt;</span>
                            <span class="n">fn</span> <span class="n">path</span> <span class="n">ext</span> <span class="o">|&gt;</span> <span class="n">optionm</span><span class="s1">'.box</span>
                        <span class="o">|&gt;</span> <span class="k">async</span><span class="o">.</span><span class="n">par_collect</span>

                <span class="p">(</span><span class="n">new_pair</span> <span class="n">file</span> <span class="n">files</span> <span class="o">|&gt;</span> <span class="n">Ok</span> <span class="o">|&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">box</span><span class="p">)</span> <span class="p">:</span> <span class="n">_</span> <span class="n">_</span> <span class="n">sm</span><span class="s1">'.std_string</span>
            <span class="o">|&gt;</span> <span class="k">async</span><span class="o">.</span><span class="n">par_collect</span>

        <span class="n">trace</span> <span class="n">Info</span>
            <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'"documents.run"'</span>
            <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span>
                <span class="n">inl</span> <span class="n">result_len</span> <span class="o">=</span> <span class="n">result</span> <span class="o">|&gt;</span> <span class="n">am</span><span class="s1">'.vec_len</span>
                <span class="err">$</span><span class="s1">'$"result_len: {!result_len} / {!_locals ()}"'</span>

        <span class="n">result</span> <span class="o">|&gt;</span> <span class="n">Ok</span> <span class="o">|&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">box</span>
    <span class="o">|&gt;</span> <span class="k">async</span><span class="o">.</span><span class="n">future_init</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>()

</pre>
</div>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=20">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [ ]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="o">////</span> <span class="n">test</span>
<span class="o">////</span> <span class="n">print_code</span><span class="o">=</span><span class="n">false</span>
<span class="o">///!</span><span class="w"> </span>rust<span class="w"> </span>-d<span class="w"> </span>async-walkdir<span class="w"> </span>encoding_rs<span class="w"> </span>encoding_rs_io<span class="w"> </span>futures-lite<span class="w"> </span>rayon<span class="w"> </span>regex<span class="w"> </span>sha2

<span class="n">types</span> <span class="p">()</span>
<span class="n">inl</span> <span class="n">workspace_root</span> <span class="o">=</span> <span class="n">file_system</span><span class="o">.</span><span class="n">get_workspace_root</span> <span class="p">()</span>
<span class="n">inl</span> <span class="n">source_dir</span> <span class="o">=</span> <span class="n">workspace_root</span> <span class="o">&lt;/&gt;</span> <span class="s2">"../vault/target/documents"</span>
<span class="n">inl</span> <span class="n">dist_dir</span> <span class="o">=</span> <span class="n">source_dir</span> <span class="o">&lt;/&gt;</span> <span class="s2">"dist"</span>
<span class="n">inl</span> <span class="n">cache_dir</span> <span class="o">=</span> <span class="n">source_dir</span> <span class="o">&lt;/&gt;</span> <span class="s2">"cache"</span>
<span class="n">inl</span> <span class="n">file_name_no_ext</span> <span class="o">=</span> <span class="s2">"test"</span>
<span class="n">inl</span> <span class="n">file_name</span> <span class="o">=</span> <span class="n">join</span> <span class="err">$</span><span class="s1">'$"{!file_name_no_ext}.md"'</span>

<span class="n">source_dir</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">directory_delete</span> <span class="n">true</span>
<span class="n">dist_dir</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">directory_delete</span> <span class="n">true</span>
<span class="n">cache_dir</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">directory_delete</span> <span class="n">true</span>

<span class="n">source_dir</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">create_directory</span><span class="s1">' |&gt; ignore</span>
<span class="n">dist_dir</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">create_directory</span><span class="s1">' |&gt; ignore</span>
<span class="n">cache_dir</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">create_directory</span><span class="s1">' |&gt; ignore</span>

<span class="n">inl</span> <span class="n">text</span> <span class="o">=</span> <span class="s2">"# a</span><span class="se">\n\n</span><span class="s2">## b</span><span class="se">\n\n</span><span class="s2">---</span><span class="se">\n\n</span><span class="s2">abc</span><span class="se">\n</span><span class="s2">abc</span><span class="se">\n\n</span><span class="s2">abc</span><span class="se">\n\n</span><span class="s2">abc</span><span class="se">\n</span><span class="s2">"</span>
<span class="n">text</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">write_all_text</span> <span class="p">(</span><span class="n">source_dir</span> <span class="o">&lt;/&gt;</span> <span class="n">file_name</span><span class="p">)</span>
<span class="n">text</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">write_all_text</span> <span class="p">(</span><span class="n">dist_dir</span> <span class="o">&lt;/&gt;</span> <span class="n">file_name</span><span class="p">)</span>

<span class="n">inl</span> <span class="n">html_path</span> <span class="o">=</span> <span class="n">dist_dir</span> <span class="o">&lt;/&gt;</span> <span class="err">$</span><span class="s1">'$"{!file_name}.html"'</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">absolute_path</span>
<span class="n">inl</span> <span class="n">pdf_path</span> <span class="o">=</span> <span class="n">dist_dir</span> <span class="o">&lt;/&gt;</span> <span class="err">$</span><span class="s1">'$"{!file_name}.pdf"'</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">absolute_path</span>
<span class="n">inl</span> <span class="n">epub_path</span> <span class="o">=</span> <span class="n">dist_dir</span> <span class="o">&lt;/&gt;</span> <span class="err">$</span><span class="s1">'$"{!file_name}.epub"'</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">absolute_path</span>
<span class="n">inl</span> <span class="n">hangul_path</span> <span class="o">=</span> <span class="n">dist_dir</span> <span class="o">&lt;/&gt;</span> <span class="err">$</span><span class="s1">'$"{!file_name_no_ext}.hangul.md"'</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">absolute_path</span>
<span class="n">inl</span> <span class="n">hangul_html_path</span> <span class="o">=</span> <span class="n">dist_dir</span> <span class="o">&lt;/&gt;</span> <span class="err">$</span><span class="s1">'$"{!file_name_no_ext}.hangul.md.html"'</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">absolute_path</span>
<span class="n">inl</span> <span class="n">hangul_pdf_path</span> <span class="o">=</span> <span class="n">dist_dir</span> <span class="o">&lt;/&gt;</span> <span class="err">$</span><span class="s1">'$"{!file_name_no_ext}.hangul.md.pdf"'</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">absolute_path</span>
<span class="n">inl</span> <span class="n">hangul_epub_path</span> <span class="o">=</span> <span class="n">dist_dir</span> <span class="o">&lt;/&gt;</span> <span class="err">$</span><span class="s1">'$"{!file_name_no_ext}.hangul.md.epub"'</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">absolute_path</span>

<span class="n">run</span> <span class="p">{</span>
    <span class="n">source_dir</span>
    <span class="n">dist_dir</span>
    <span class="n">cache_dir</span>
    <span class="n">hangul_spec</span> <span class="o">=</span> <span class="s2">"por-br"</span>
<span class="p">}</span>
<span class="o">|&gt;</span> <span class="k">async</span><span class="o">.</span><span class="n">block_on</span>
<span class="o">|&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">unwrap</span><span class="s1">'</span>
<span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.format_debug'</span>
<span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.from_std_string</span>
<span class="o">|&gt;</span> <span class="n">_assert_eq</span> <span class="p">(</span>
    <span class="p">;[</span>
        <span class="n">Ok</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">dist_dir</span> <span class="o">&lt;/&gt;</span> <span class="n">file_name</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">absolute_path</span><span class="p">),</span>
            <span class="p">;[</span>
                <span class="n">hangul_path</span>
                <span class="n">html_path</span>
                <span class="n">pdf_path</span>
                <span class="n">epub_path</span>
                <span class="n">hangul_html_path</span>
                <span class="n">hangul_pdf_path</span>
                <span class="n">hangul_epub_path</span>
            <span class="p">]</span>
            <span class="o">|&gt;</span> <span class="n">am</span><span class="s1">'.to_vec |&gt; am'</span><span class="o">.</span><span class="n">vec_map</span> <span class="p">(</span><span class="n">Ok</span> <span class="o">&gt;&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">box</span> <span class="o">&gt;&gt;</span> <span class="n">Some</span> <span class="o">&gt;&gt;</span> <span class="n">optionm</span><span class="s1">'.box)</span>
            <span class="o">|&gt;</span> <span class="n">fun</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">x</span> <span class="p">:</span> <span class="n">_</span> <span class="p">(</span><span class="n">_</span> <span class="p">(</span><span class="n">_</span> <span class="n">_</span> <span class="n">sm</span><span class="s1">'.std_string))</span>
        <span class="p">)</span>
    <span class="p">]</span>
    <span class="o">|&gt;</span> <span class="n">am</span><span class="s1">'.to_vec</span>
    <span class="o">|&gt;</span> <span class="n">am</span><span class="s1">'.vec_map resultm.box</span>
    <span class="o">|&gt;</span> <span class="n">fun</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">x</span> <span class="p">:</span> <span class="n">_</span> <span class="p">(</span><span class="n">_</span> <span class="n">_</span> <span class="n">sm</span><span class="s1">'.std_string)</span>
    <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.format_debug'</span>
    <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.from_std_string</span>
<span class="p">)</span>

<span class="n">dist_dir</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">directory_delete</span> <span class="n">true</span>
<span class="n">dist_dir</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">create_directory</span><span class="s1">' |&gt; ignore</span>

<span class="n">text</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">write_all_text</span> <span class="p">(</span><span class="n">dist_dir</span> <span class="o">&lt;/&gt;</span> <span class="n">file_name</span><span class="p">)</span>

<span class="n">run</span> <span class="p">{</span>
    <span class="n">source_dir</span> <span class="o">=</span> <span class="n">source_dir</span>
    <span class="n">dist_dir</span> <span class="o">=</span> <span class="n">dist_dir</span>
    <span class="n">cache_dir</span> <span class="o">=</span> <span class="n">cache_dir</span>
    <span class="n">hangul_spec</span> <span class="o">=</span> <span class="s2">"por-br"</span>
<span class="p">}</span>
<span class="o">|&gt;</span> <span class="k">async</span><span class="o">.</span><span class="n">block_on</span>
<span class="o">|&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">unwrap</span><span class="s1">'</span>
<span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.format_debug'</span>
<span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.from_std_string</span>
<span class="o">|&gt;</span> <span class="n">_assert_eq</span> <span class="p">(</span>
    <span class="p">;[</span>
        <span class="n">Ok</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">dist_dir</span> <span class="o">&lt;/&gt;</span> <span class="n">file_name</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">absolute_path</span><span class="p">),</span>
            <span class="p">;[</span>
            <span class="p">]</span>
            <span class="o">|&gt;</span> <span class="n">am</span><span class="s1">'.to_vec |&gt; am'</span><span class="o">.</span><span class="n">vec_map</span> <span class="p">((</span><span class="n">optionm</span><span class="o">.</span><span class="n">map</span> <span class="n">resultm</span><span class="o">.</span><span class="n">box</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">optionm</span><span class="s1">'.box)</span>
        <span class="p">)</span>
    <span class="p">]</span>
    <span class="o">|&gt;</span> <span class="n">am</span><span class="s1">'.to_vec</span>
    <span class="o">|&gt;</span> <span class="n">am</span><span class="s1">'.vec_map resultm.box</span>
    <span class="o">|&gt;</span> <span class="n">fun</span> <span class="n">x</span> <span class="o">=&gt;</span>
        <span class="n">x</span> <span class="p">:</span> <span class="n">am</span><span class="s1">'.vec (</span>
            <span class="n">resultm</span><span class="o">.</span><span class="n">result</span><span class="s1">'</span>
                <span class="p">(</span><span class="n">string</span> <span class="o">*</span> <span class="n">am</span><span class="s1">'.vec (optionm'</span><span class="o">.</span><span class="n">option</span><span class="s1">' (resultm.result'</span> <span class="n">string</span> <span class="n">string</span><span class="p">)))</span>
                <span class="n">sm</span><span class="s1">'.std_string</span>
        <span class="p">)</span>
    <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.format_debug'</span>
    <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.from_std_string</span>
<span class="p">)</span>

<span class="n">hangul_path</span>
<span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">read_all_text</span>
<span class="o">|&gt;</span> <span class="n">_assert_eq</span> <span class="s2">"# 아</span><span class="se">\n\n</span><span class="s2">## 브</span><span class="se">\n\n</span><span class="s2">---</span><span class="se">\n\n</span><span class="s2">아브크</span><span class="se">\n</span><span class="s2">아브크</span><span class="se">\n\n</span><span class="s2">아브크</span><span class="se">\n\n</span><span class="s2">아브크</span><span class="se">\n</span><span class="s2">"</span>

<span class="n">html_path</span>
<span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">read_all_text</span>
<span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.contains "&lt;p class = </span><span class="se">\"</span><span class="s1">rule</span><span class="se">\"</span><span class="s1">&gt;***&lt;/p&gt;</span><span class="se">\n</span><span class="s1">&lt;p id = </span><span class="se">\"</span><span class="s1">para-1</span><span class="se">\"</span><span class="s1">&gt;abc abc&lt;/p&gt;"</span>
<span class="o">|&gt;</span> <span class="n">_assert_eq</span> <span class="n">true</span>

<span class="n">pdf_path</span>
<span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">read_all_bytes</span>
<span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.slice_contains "%PDF-1.5"</span>
<span class="o">|&gt;</span> <span class="n">_assert_eq</span> <span class="n">true</span>

<span class="n">epub_path</span>
<span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">read_all_bytes</span>
<span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.slice_contains "application/epub+zip"</span>
<span class="o">|&gt;</span> <span class="n">_assert_eq</span> <span class="n">true</span>

<span class="n">hangul_html_path</span>
<span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">read_all_text</span>
<span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.contains "&lt;p class = </span><span class="se">\"</span><span class="s1">rule</span><span class="se">\"</span><span class="s1">&gt;***&lt;/p&gt;</span><span class="se">\n</span><span class="s1">&lt;p id = </span><span class="se">\"</span><span class="s1">para-1</span><span class="se">\"</span><span class="s1">&gt;아브크 아브크&lt;/p&gt;"</span>
<span class="o">|&gt;</span> <span class="n">_assert_eq</span> <span class="n">true</span>

<span class="n">hangul_pdf_path</span>
<span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">read_all_bytes</span>
<span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.slice_contains "%PDF-1.5"</span>
<span class="o">|&gt;</span> <span class="n">_assert_eq</span> <span class="n">true</span>

<span class="n">hangul_epub_path</span>
<span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">read_all_bytes</span>
<span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.slice_contains "application/epub+zip"</span>
<span class="o">|&gt;</span> <span class="n">_assert_eq</span> <span class="n">true</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>00:00:00 <span class="ansi-black-intense-fg">verbose</span> #1 file_system.create_directory / dir: C:\home\git\polyglot\../vault/target/documents
00:00:00 <span class="ansi-black-intense-fg">verbose</span> #2 file_system.create_directory / dir: C:\home\git\polyglot\../vault/target/documents\dist
00:00:00 <span class="ansi-black-intense-fg">verbose</span> #3 file_system.create_directory / dir: C:\home\git\polyglot\../vault/target/documents\cache
00:00:00 <span class="ansi-blue-intense-fg">  debug</span> #4 documents.run / source_dir: \\?\C:\home\git\vault\target\documents / dist_dir: \\?\C:\home\git\vault\target\documents\dist / cache_dir: \\?\C:\home\git\vault\target\documents\cache / hangul_spec: "por-br"
00:00:00 <span class="ansi-blue-intense-fg">  debug</span> #5 documents.run / files_len: 1
00:00:00 <span class="ansi-blue-intense-fg">  debug</span> #6 runtime.execute_with_options / file_name: git / arguments: ["ls-tree", "--format='%(objectname)'", "origin/gh-pages", "c:/home/git/vault/target/documents/test.md"] / options: (None, "git ls-tree --format='%(objectname)' origin/gh-pages "c:/home/git/vault/target/documents/test.md"", Array(MutCell([])), None, None, Some("\\?\C:\home\git\vault\target\documents"))
00:00:00 <span class="ansi-black-intense-fg">verbose</span> #7 runtime.execute_with_options / result / exit_code: 0 / std_trace.Length: 0
00:00:00 <span class="ansi-blue-intense-fg">  debug</span> #8 runtime.execute_with_options / file_name: git / arguments: ["hash-object", "c:/home/git/vault/target/documents/dist/test.md"] / options: (None, "git hash-object "c:/home/git/vault/target/documents/dist/test.md"", Array(MutCell([])), None, None, Some("\\?\C:\home\git\vault\target\documents\dist"))
00:00:00 <span class="ansi-black-intense-fg">verbose</span> #9 &gt; ba0ba7eb68b2a508ff0525bcbb91bd5ebc95e71b
00:00:00 <span class="ansi-black-intense-fg">verbose</span> #10 runtime.execute_with_options / result / exit_code: 0 / std_trace.Length: 40
00:00:00 <span class="ansi-green-intense-fg">   info</span> #11 documents.run / par_map / origin_hash |&gt; sm'.contains local_git_hash |&gt; not / hash2 = None || hash1 &lt;&gt;. (hash2 |&gt; optionm.value) / file: c:/home/git/vault/target/documents/dist/test.md / real_path: c:/home/git/vault/target/documents/test.md / relative_path: ./test.md / origin_hash_exit_code: 0 / origin_hash:  / local_git_hash_exit_code: 0 / local_git_hash: ba0ba7eb68b2a508ff0525bcbb91bd5ebc95e71b / hash1: f87ee09ec1dadc95e06e23bef39aa3185381d285bb9ca41a8a112061a6f504ec / hash2: US0_1 / dist_path: c:/home/git/vault/target/documents/dist/test.md / cache_path: c:/home/git/vault/target/documents/cache/test.md
00:00:00 <span class="ansi-blue-intense-fg">  debug</span> #12 runtime.execute_with_options / file_name: C:/home/git/polyglot/../vault/deps/hangulize/cmd/hangulize/hangulize.exe / arguments: ["por-br"] / options: (None, "C:\home\git\polyglot\../vault/deps/hangulize/cmd/hangulize/hangulize.exe por-br", Array(MutCell([])), None, Some(fable_library_rust::module_3bd9ae6a::FuncType::Func1&lt;alloc::sync::Arc&lt;std::sync::mutex::Mutex&lt;std::process::ChildStdin&gt;&gt;, ()&gt;), None)
00:00:00 <span class="ansi-black-intense-fg">verbose</span> #13 &gt; # ?
00:00:00 <span class="ansi-black-intense-fg">verbose</span> #14 &gt; ## ?
00:00:00 <span class="ansi-black-intense-fg">verbose</span> #15 &gt; ---
00:00:00 <span class="ansi-black-intense-fg">verbose</span> #16 &gt; ???
00:00:00 <span class="ansi-black-intense-fg">verbose</span> #17 &gt; ???
00:00:00 <span class="ansi-black-intense-fg">verbose</span> #18 &gt; ???
00:00:00 <span class="ansi-black-intense-fg">verbose</span> #19 &gt; ???
00:00:00 <span class="ansi-black-intense-fg">verbose</span> #20 runtime.execute_with_options / result / exit_code: 0 / std_trace.Length: 28
00:00:00 <span class="ansi-green-intense-fg">   info</span> #21 documents.hangul / exit_code: 0 / result_len: 34 / output_path: c:/home/git/vault/target/documents/dist/test.hangul.md
00:00:00 <span class="ansi-blue-intense-fg">  debug</span> #24 runtime.execute_with_options / file_name: crowbook / arguments: ["--single", "c:/home/git/vault/target/documents/dist/test.md", "--output", "c:/home/git/vault/target/documents/dist/test.md.html", "--to", "html", "--set", "rendering.num_depth", "6", "html.css.add", "' body { color: #e8e6e3; background-color: #202324; } a { color: #989693; } '"] / options: (None, "crowbook --single "c:/home/git/vault/target/documents/dist/test.md" --output "c:/home/git/vault/target/documents/dist/test.md.html" --to html --set rendering.num_depth 6 html.css.add \"' body { color: #e8e6e3; background-color: #202324; } a { color: #989693; } '\"", Array(MutCell([])), None, None, Some("\\?\C:\home\git\vault\target\documents\dist"))
00:00:00 <span class="ansi-blue-intense-fg">  debug</span> #24 runtime.execute_with_options / file_name: crowbook / arguments: ["--single", "c:/home/git/vault/target/documents/dist/test.md", "--output", "c:/home/git/vault/target/documents/dist/test.md.epub", "--to", "epub", "--set", "rendering.num_depth", "6", "html.css.add", "' body { color: #e8e6e3; background-color: #202324; } a { color: #989693; } '"] / options: (None, "crowbook --single "c:/home/git/vault/target/documents/dist/test.md" --output "c:/home/git/vault/target/documents/dist/test.md.epub" --to epub --set rendering.num_depth 6 html.css.add \"' body { color: #e8e6e3; background-color: #202324; } a { color: #989693; } '\"", Array(MutCell([])), None, None, Some("\\?\C:\home\git\vault\target\documents\dist"))
00:00:00 <span class="ansi-blue-intense-fg">  debug</span> #24 runtime.execute_with_options / file_name: crowbook / arguments: ["--single", "c:/home/git/vault/target/documents/dist/test.md", "--output", "c:/home/git/vault/target/documents/dist/test.md.pdf", "--to", "pdf", "--set", "rendering.num_depth", "6", "html.css.add", "' body { color: #e8e6e3; background-color: #202324; } a { color: #989693; } '"] / options: (None, "crowbook --single "c:/home/git/vault/target/documents/dist/test.md" --output "c:/home/git/vault/target/documents/dist/test.md.pdf" --to pdf --set rendering.num_depth 6 html.css.add \"' body { color: #e8e6e3; background-color: #202324; } a { color: #989693; } '\"", Array(MutCell([])), None, None, Some("\\?\C:\home\git\vault\target\documents\dist"))
00:00:00 <span class="ansi-blue-intense-fg">  debug</span> #27 runtime.execute_with_options / file_name: crowbook / arguments: ["--single", "c:/home/git/vault/target/documents/dist/test.hangul.md", "--output", "c:/home/git/vault/target/documents/dist/test.hangul.md.html", "--to", "html", "--set", "rendering.num_depth", "6", "html.css.add", "' body { color: #e8e6e3; background-color: #202324; } a { color: #989693; } '"] / options: (None, "crowbook --single "c:/home/git/vault/target/documents/dist/test.hangul.md" --output "c:/home/git/vault/target/documents/dist/test.hangul.md.html" --to html --set rendering.num_depth 6 html.css.add \"' body { color: #e8e6e3; background-color: #202324; } a { color: #989693; } '\"", Array(MutCell([])), None, None, Some("\\?\C:\home\git\vault\target\documents\dist"))
00:00:00 <span class="ansi-blue-intense-fg">  debug</span> #27 runtime.execute_with_options / file_name: crowbook / arguments: ["--single", "c:/home/git/vault/target/documents/dist/test.hangul.md", "--output", "c:/home/git/vault/target/documents/dist/test.hangul.md.epub", "--to", "epub", "--set", "rendering.num_depth", "6", "html.css.add", "' body { color: #e8e6e3; background-color: #202324; } a { color: #989693; } '"] / options: (None, "crowbook --single "c:/home/git/vault/target/documents/dist/test.hangul.md" --output "c:/home/git/vault/target/documents/dist/test.hangul.md.epub" --to epub --set rendering.num_depth 6 html.css.add \"' body { color: #e8e6e3; background-color: #202324; } a { color: #989693; } '\"", Array(MutCell([])), None, None, Some("\\?\C:\home\git\vault\target\documents\dist"))
00:00:00 <span class="ansi-blue-intense-fg">  debug</span> #27 runtime.execute_with_options / file_name: crowbook / arguments: ["--single", "c:/home/git/vault/target/documents/dist/test.hangul.md", "--output", "c:/home/git/vault/target/documents/dist/test.hangul.md.pdf", "--to", "pdf", "--set", "rendering.num_depth", "6", "html.css.add", "' body { color: #e8e6e3; background-color: #202324; } a { color: #989693; } '"] / options: (None, "crowbook --single "c:/home/git/vault/target/documents/dist/test.hangul.md" --output "c:/home/git/vault/target/documents/dist/test.hangul.md.pdf" --to pdf --set rendering.num_depth 6 html.css.add \"' body { color: #e8e6e3; background-color: #202324; } a { color: #989693; } '\"", Array(MutCell([])), None, None, Some("\\?\C:\home\git\vault\target\documents\dist"))
00:00:00 <span class="ansi-black-intense-fg">verbose</span> #28 &gt; CROWBOOK 0.16.1
00:00:00 <span class="ansi-black-intense-fg">verbose</span> #29 runtime.execute_with_options / result / exit_code: 0 / std_trace.Length: 15
00:00:00 <span class="ansi-black-intense-fg">verbose</span> #30 &gt; CROWBOOK 0.16.1
00:00:00 <span class="ansi-black-intense-fg">verbose</span> #31 runtime.execute_with_options / result / exit_code: 0 / std_trace.Length: 15
00:00:01 <span class="ansi-black-intense-fg">verbose</span> #32 &gt; CROWBOOK 0.16.1
00:00:01 <span class="ansi-black-intense-fg">verbose</span> #33 runtime.execute_with_options / result / exit_code: 0 / std_trace.Length: 15
00:00:01 <span class="ansi-black-intense-fg">verbose</span> #34 &gt; CROWBOOK 0.16.1
00:00:01 <span class="ansi-black-intense-fg">verbose</span> #35 runtime.execute_with_options / result / exit_code: 0 / std_trace.Length: 15
00:00:12 <span class="ansi-black-intense-fg">verbose</span> #36 &gt; CROWBOOK 0.16.1
00:00:12 <span class="ansi-black-intense-fg">verbose</span> #37 runtime.execute_with_options / result / exit_code: 0 / std_trace.Length: 15
00:00:12 <span class="ansi-black-intense-fg">verbose</span> #38 &gt; CROWBOOK 0.16.1
00:00:12 <span class="ansi-black-intense-fg">verbose</span> #39 runtime.execute_with_options / result / exit_code: 0 / std_trace.Length: 15
00:00:12 <span class="ansi-green-intense-fg">   info</span> #40 documents.run / result_len: 1
assert_eq / actual: "[Ok(("c:/home/git/vault/target/documents/dist/test.md", [Some(Ok("c:/home/git/vault/target/documents/dist/test.hangul.md")), Some(Ok("c:/home/git/vault/target/documents/dist/test.md.html")), Some(Ok("c:/home/git/vault/target/documents/dist/test.md.pdf")), Some(Ok("c:/home/git/vault/target/documents/dist/test.md.epub")), Some(Ok("c:/home/git/vault/target/documents/dist/test.hangul.md.html")), Some(Ok("c:/home/git/vault/target/documents/dist/test.hangul.md.pdf")), Some(Ok("c:/home/git/vault/target/documents/dist/test.hangul.md.epub"))]))]" / expected: "[Ok(("c:/home/git/vault/target/documents/dist/test.md", [Some(Ok("c:/home/git/vault/target/documents/dist/test.hangul.md")), Some(Ok("c:/home/git/vault/target/documents/dist/test.md.html")), Some(Ok("c:/home/git/vault/target/documents/dist/test.md.pdf")), Some(Ok("c:/home/git/vault/target/documents/dist/test.md.epub")), Some(Ok("c:/home/git/vault/target/documents/dist/test.hangul.md.html")), Some(Ok("c:/home/git/vault/target/documents/dist/test.hangul.md.pdf")), Some(Ok("c:/home/git/vault/target/documents/dist/test.hangul.md.epub"))]))]"
00:00:12 <span class="ansi-black-intense-fg">verbose</span> #41 file_system.create_directory / dir: C:\home\git\polyglot\../vault/target/documents\dist
00:00:12 <span class="ansi-blue-intense-fg">  debug</span> #42 documents.run / source_dir: \\?\C:\home\git\vault\target\documents / dist_dir: \\?\C:\home\git\vault\target\documents\dist / cache_dir: \\?\C:\home\git\vault\target\documents\cache / hangul_spec: "por-br"
00:00:12 <span class="ansi-blue-intense-fg">  debug</span> #43 documents.run / files_len: 1
00:00:12 <span class="ansi-blue-intense-fg">  debug</span> #44 runtime.execute_with_options / file_name: git / arguments: ["ls-tree", "--format='%(objectname)'", "origin/gh-pages", "c:/home/git/vault/target/documents/test.md"] / options: (None, "git ls-tree --format='%(objectname)' origin/gh-pages "c:/home/git/vault/target/documents/test.md"", Array(MutCell([])), None, None, Some("\\?\C:\home\git\vault\target\documents"))
00:00:12 <span class="ansi-black-intense-fg">verbose</span> #45 runtime.execute_with_options / result / exit_code: 0 / std_trace.Length: 0
00:00:12 <span class="ansi-blue-intense-fg">  debug</span> #46 runtime.execute_with_options / file_name: git / arguments: ["hash-object", "c:/home/git/vault/target/documents/dist/test.md"] / options: (None, "git hash-object "c:/home/git/vault/target/documents/dist/test.md"", Array(MutCell([])), None, None, Some("\\?\C:\home\git\vault\target\documents\dist"))
00:00:12 <span class="ansi-black-intense-fg">verbose</span> #47 &gt; ba0ba7eb68b2a508ff0525bcbb91bd5ebc95e71b
00:00:12 <span class="ansi-black-intense-fg">verbose</span> #48 runtime.execute_with_options / result / exit_code: 0 / std_trace.Length: 40
00:00:12 <span class="ansi-green-intense-fg">   info</span> #49 documents.run / par_map / files' = [] / listm.iter / output_path: "c:/home/git/vault/target/documents/dist/test.hangul.md.epub" / output_cache_path: \\?\C:\home\git\vault\target\documents\cache\test.hangul.md.epub
00:00:12 <span class="ansi-green-intense-fg">   info</span> #50 documents.run / par_map / files' = [] / listm.iter / output_path: "c:/home/git/vault/target/documents/dist/test.hangul.md.pdf" / output_cache_path: \\?\C:\home\git\vault\target\documents\cache\test.hangul.md.pdf
00:00:12 <span class="ansi-green-intense-fg">   info</span> #51 documents.run / par_map / files' = [] / listm.iter / output_path: "c:/home/git/vault/target/documents/dist/test.hangul.md.html" / output_cache_path: \\?\C:\home\git\vault\target\documents\cache\test.hangul.md.html
00:00:12 <span class="ansi-green-intense-fg">   info</span> #52 documents.run / par_map / files' = [] / listm.iter / output_path: "c:/home/git/vault/target/documents/dist/test.md.epub" / output_cache_path: \\?\C:\home\git\vault\target\documents\cache\test.md.epub
00:00:12 <span class="ansi-green-intense-fg">   info</span> #53 documents.run / par_map / files' = [] / listm.iter / output_path: "c:/home/git/vault/target/documents/dist/test.md.pdf" / output_cache_path: \\?\C:\home\git\vault\target\documents\cache\test.md.pdf
00:00:12 <span class="ansi-green-intense-fg">   info</span> #54 documents.run / par_map / files' = [] / listm.iter / output_path: "c:/home/git/vault/target/documents/dist/test.md.html" / output_cache_path: \\?\C:\home\git\vault\target\documents\cache\test.md.html
00:00:12 <span class="ansi-green-intense-fg">   info</span> #55 documents.run / par_map / files' = [] / listm.iter / output_path: "c:/home/git/vault/target/documents/dist/test.hangul.md" / output_cache_path: \\?\C:\home\git\vault\target\documents\cache\test.hangul.md
00:00:12 <span class="ansi-green-intense-fg">   info</span> #56 documents.run / result_len: 1
assert_eq / actual: "[Ok(("c:/home/git/vault/target/documents/dist/test.md", []))]" / expected: "[Ok(("c:/home/git/vault/target/documents/dist/test.md", []))]"
assert_eq / actual: "# ?

## ?

---

???
???

???

???
" / expected: "# ?

## ?

---

???
???

???

???
"
assert_eq / actual: true / expected: true
assert_eq / actual: true / expected: true
assert_eq / actual: true / expected: true
assert_eq / actual: true / expected: true
assert_eq / actual: true / expected: true
assert_eq / actual: true / expected: true
</pre>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=21">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h2 id="tests">tests<a class="anchor-link" href="#tests">¶</a></h2>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=22">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [ ]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">inl</span> <span class="n">tests</span> <span class="p">()</span> <span class="o">=</span>
    <span class="n">rust</span><span class="o">.</span><span class="n">run_tests</span> <span class="p">[</span>
        <span class="s2">"verify_app"</span><span class="p">,</span> <span class="n">fun</span> <span class="n">_</span> <span class="o">=&gt;</span>
            <span class="n">get_command</span> <span class="p">()</span> <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">command_debug_assert</span>
    <span class="p">]</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>()

</pre>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=23">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h2 id="main">main<a class="anchor-link" href="#main">¶</a></h2>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=24">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [ ]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="o">///!</span><span class="w"> </span>

<span class="n">inl</span> <span class="n">main</span> <span class="p">(</span><span class="n">args</span> <span class="p">:</span> <span class="n">array_base</span> <span class="n">string</span><span class="p">)</span> <span class="o">=</span>
    <span class="n">Info</span> <span class="o">|&gt;</span> <span class="n">Some</span> <span class="o">|&gt;</span> <span class="n">init_trace_state</span>

    <span class="n">trace</span> <span class="n">Info</span>
        <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'$"documents.main"'</span>
        <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'$"args: {!args} / {!_locals ()}"'</span>

    <span class="n">inl</span> <span class="n">command</span> <span class="o">=</span> <span class="n">get_command</span> <span class="p">()</span>
    <span class="n">inl</span> <span class="n">arg_matches</span> <span class="o">=</span> <span class="n">command</span> <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">command_get_matches</span>

    <span class="n">inl</span> <span class="n">source_dir</span> <span class="o">=</span>
        <span class="n">arg_matches</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">matches_get_one</span> <span class="p">(</span><span class="n">get_args</span> <span class="p">()</span> <span class="o">.</span><span class="n">source_dir</span><span class="p">)</span>
        <span class="o">|&gt;</span> <span class="n">optionm</span><span class="s1">'.unbox</span>
        <span class="o">|&gt;</span> <span class="n">optionm</span><span class="o">.</span><span class="n">value</span>
        <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.from_std_string</span>

    <span class="n">inl</span> <span class="n">dist_dir</span> <span class="o">=</span>
        <span class="n">arg_matches</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">matches_get_one</span> <span class="p">(</span><span class="n">get_args</span> <span class="p">()</span> <span class="o">.</span><span class="n">dist_dir</span><span class="p">)</span>
        <span class="o">|&gt;</span> <span class="n">optionm</span><span class="s1">'.unbox</span>
        <span class="o">|&gt;</span> <span class="n">optionm</span><span class="o">.</span><span class="n">value</span>
        <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.from_std_string</span>

    <span class="n">inl</span> <span class="n">cache_dir</span> <span class="o">=</span>
        <span class="n">arg_matches</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">matches_get_one</span> <span class="p">(</span><span class="n">get_args</span> <span class="p">()</span> <span class="o">.</span><span class="n">cache_dir</span><span class="p">)</span>
        <span class="o">|&gt;</span> <span class="n">optionm</span><span class="s1">'.unbox</span>
        <span class="o">|&gt;</span> <span class="n">optionm</span><span class="o">.</span><span class="n">value</span>
        <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.from_std_string</span>

    <span class="n">inl</span> <span class="n">hangul_spec</span> <span class="o">=</span>
        <span class="n">arg_matches</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">matches_get_one</span> <span class="p">(</span><span class="n">get_args</span> <span class="p">()</span> <span class="o">.</span><span class="n">hangul_spec</span><span class="p">)</span>
        <span class="o">|&gt;</span> <span class="n">optionm</span><span class="s1">'.unbox</span>
        <span class="o">|&gt;</span> <span class="n">optionm</span><span class="o">.</span><span class="n">value</span>
        <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.from_std_string</span>

    <span class="n">run</span> <span class="p">{</span> <span class="n">source_dir</span> <span class="n">dist_dir</span> <span class="n">cache_dir</span> <span class="n">hangul_spec</span> <span class="p">}</span>
    <span class="o">|&gt;</span> <span class="k">async</span><span class="o">.</span><span class="n">block_on</span>
    <span class="o">|&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">unwrap</span><span class="s1">'</span>
    <span class="o">|&gt;</span> <span class="n">ignore</span>

    <span class="mi">0</span><span class="n">i32</span>

<span class="n">inl</span> <span class="n">main</span> <span class="p">()</span> <span class="o">=</span>
    <span class="n">types</span> <span class="p">()</span>
    <span class="err">$</span><span class="s2">"let tests () = !tests ()"</span> <span class="p">:</span> <span class="p">()</span>
    <span class="err">$</span><span class="s2">"let main args = !main args"</span> <span class="p">:</span> <span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>.fsx:
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("[$0]")&gt;]
#endif
type Slice&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("_")&gt;]
#endif
type Slice'&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("Vec&lt;$0&gt;")&gt;]
#endif
type Vec&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::future::Future&lt;Output = $0&gt;")&gt;]
#endif
type std_future_Future&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("futures::future::TryJoinAll&lt;$0&gt;")&gt;]
#endif
type futures_future_TryJoinAll&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("rayon::vec::IntoIter&lt;$0&gt;")&gt;]
#endif
type rayon_vec_IntoIter&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("rayon::iter::Map&lt;$0, _&gt;")&gt;]
#endif
type rayon_iter_Map&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("futures_lite::stream::StreamExt")&gt;]
#endif
type futures_lite_stream_StreamExt = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("_")&gt;]
#endif
type Any = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("Func0&lt;$0&gt;")&gt;]
#endif
type Func0&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("Func1&lt;$0, $1&gt;")&gt;]
#endif
type Func0&lt;'T, 'U&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("Box&lt;$0&gt;")&gt;]
#endif
type Box&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("dyn $0")&gt;]
#endif
type Dyn&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("$0 + Send")&gt;]
#endif
type Send&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("Fn() -&gt; $0")&gt;]
#endif
type Fn&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("Fn()")&gt;]
#endif
type FnUnit = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("FnOnce() -&gt; $0")&gt;]
#endif
type FnOnce&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("Fn($0)")&gt;]
#endif
type ActionFn&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("Fn($0, $1)")&gt;]
#endif
type ActionFn2&lt;'T, 'U&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("impl $0")&gt;]
#endif
type Impl&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("mut $0")&gt;]
#endif
type Mut&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("&amp;$0")&gt;]
#endif
type Ref&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("&amp;'static $0")&gt;]
#endif
type StaticRef&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("MutCell&lt;$0&gt;")&gt;]
#endif
type MutCell&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::any::Any")&gt;]
#endif
type std_any_Any = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::borrow::Cow&lt;$0&gt;")&gt;]
#endif
type std_borrow_Cow&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::cell::RefCell&lt;$0&gt;")&gt;]
#endif
type std_cell_RefCell&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::pin::Pin&lt;$0&gt;")&gt;]
#endif
type std_pin_Pin&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::rc::Rc&lt;$0&gt;")&gt;]
#endif
type std_rc_Rc&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::rc::Weak&lt;$0&gt;")&gt;]
#endif
type std_rc_Weak&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::collections::HashMap&lt;$0, $1&gt;")&gt;]
#endif
type std_collections_HashMap&lt;'K, 'V&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::collections::BTreeMap&lt;$0, $1&gt;")&gt;]
#endif
type std_collections_BTreeMap&lt;'K, 'V&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("str")&gt;]
#endif
type Str = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("base64::DecodeError")&gt;]
#endif
type base64_DecodeError = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("borsh::io::Error")&gt;]
#endif
type borsh_io_Error = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("encoding_rs::Encoding")&gt;]
#endif
type encoding_rs_Encoding = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("js_sys::JsString")&gt;]
#endif
type js_sys_JsString = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("serde_json::Error")&gt;]
#endif
type serde_json_Error = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("serde_json::Value")&gt;]
#endif
type serde_json_Value = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("serde_wasm_bindgen::Error")&gt;]
#endif
type serde_wasm_bindgen_Error = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::ffi::OsStr")&gt;]
#endif
type std_ffi_OsStr = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::ffi::OsString")&gt;]
#endif
type std_ffi_OsString = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::fmt::Display&lt;$0&gt;")&gt;]
#endif
type std_fmt_Display&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::str::Utf8Error")&gt;]
#endif
type std_str_Utf8Error = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::string::FromUtf8Error")&gt;]
#endif
type std_string_FromUtf8Error = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::string::String")&gt;]
#endif
type std_string_String = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::slice::Windows&lt;$0&gt;")&gt;]
#endif
type std_slice_Windows&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("regex::Regex")&gt;]
#endif
type regex_Regex = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("regex::Captures")&gt;]
#endif
type regex_Captures = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("regex::CaptureMatches")&gt;]
#endif
type regex_CaptureMatches = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("regex::Error")&gt;]
#endif
type regex_Error = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::thread::JoinHandle&lt;$0&gt;")&gt;]
#endif
type std_thread_JoinHandle&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::sync::Arc&lt;$0&gt;")&gt;]
#endif
type std_sync_Arc&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::sync::Mutex&lt;$0&gt;")&gt;]
#endif
type std_sync_Mutex&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::sync::MutexGuard&lt;$0&gt;")&gt;]
#endif
type std_sync_MutexGuard&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::sync::PoisonError&lt;$0&gt;")&gt;]
#endif
type std_sync_PoisonError&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("chrono::DateTime&lt;$0&gt;")&gt;]
#endif
type chrono_DateTime&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("chrono::Local")&gt;]
#endif
type chrono_Local = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("chrono::NaiveDateTime")&gt;]
#endif
type chrono_NaiveDateTime = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("chrono::Utc")&gt;]
#endif
type chrono_Utc = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::time::Duration")&gt;]
#endif
type std_time_Duration = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::fs::File")&gt;]
#endif
type std_fs_File = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::fs::FileType")&gt;]
#endif
type std_fs_FileType = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::path::Display")&gt;]
#endif
type std_path_Display = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::path::Path")&gt;]
#endif
type std_path_Path = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::path::PathBuf")&gt;]
#endif
type std_path_PathBuf = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("async_walkdir::DirEntry")&gt;]
#endif
type async_walkdir_DirEntry = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("async_walkdir::Filtering")&gt;]
#endif
type async_walkdir_Filtering = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("async_walkdir::WalkDir")&gt;]
#endif
type async_walkdir_WalkDir = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::env::VarError")&gt;]
#endif
type std_env_VarError = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("async_std::io::BufReader&lt;$0&gt;")&gt;]
#endif
type async_std_io_BufReader&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::io::BufReader&lt;$0&gt;")&gt;]
#endif
type std_io_BufReader&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::io::Error")&gt;]
#endif
type std_io_Error = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::io::Lines&lt;$0&gt;")&gt;]
#endif
type std_io_Lines&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("encoding_rs_io::DecodeReaderBytes&lt;$0, $1&gt;")&gt;]
#endif
type encoding_rs_io_DecodeReaderBytes&lt;'T, 'U&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("clap::Arg")&gt;]
#endif
type clap_Arg = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("clap::ArgAction")&gt;]
#endif
type clap_ArgAction = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("clap::Command")&gt;]
#endif
type clap_Command = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("clap::ArgMatches")&gt;]
#endif
type clap_ArgMatches = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("clap::builder::ValueRange")&gt;]
#endif
type clap_builder_ValueRange = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("clap::builder::ValueParser")&gt;]
#endif
type clap_builder_ValueParser = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("clap::builder::PossibleValue")&gt;]
#endif
type clap_builder_PossibleValue = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::process::Child")&gt;]
#endif
type std_process_Child = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::process::ChildStderr")&gt;]
#endif
type std_process_ChildStderr = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::process::ChildStdout")&gt;]
#endif
type std_process_ChildStdout = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::process::ChildStdin")&gt;]
#endif
type std_process_ChildStdin = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::process::Command")&gt;]
#endif
type std_process_Command = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::process::Output")&gt;]
#endif
type std_process_Output = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::process::Stdio")&gt;]
#endif
type std_process_Stdio = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::sync::mpsc::Receiver&lt;$0&gt;")&gt;]
#endif
type std_sync_mpsc_Receiver&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::sync::mpsc::Sender&lt;$0&gt;")&gt;]
#endif
type std_sync_mpsc_Sender&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("core::iter::Fuse&lt;$0&gt;")&gt;]
#endif
type core_iter_Fuse&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("sha2::Sha256")&gt;]
#endif
type sha2_Sha256 = class end
module State = let mutable trace_state = None
type IPathJoin = abstract join: [&lt;System.ParamArray&gt;] paths: string[] -&gt; string
type IFsExistsSync = abstract existsSync: path: string -&gt; bool
type IPathDirname = abstract dirname: path: string -&gt; string
#if FABLE_COMPILER
[&lt;CompilationRepresentation (CompilationRepresentationFlags.ModuleSuffix)&gt;]
module System =
 module Diagnostics =
  type Process = unit
  type DataReceivedEventArgs = unit
#endif
type [&lt;Struct&gt;] US0 =
    | US0_0
    | US0_1
    | US0_2
    | US0_3
    | US0_4
and Mut0 = {mutable l0 : int64}
and Mut1 = {mutable l0 : bool}
and Mut2 = {mutable l0 : US0}
and Mut3 = {mutable l0 : (string -&gt; unit)}
and [&lt;Struct&gt;] US1 =
    | US1_0 of f0_0 : int64
    | US1_1
and [&lt;Struct&gt;] US2 =
    | US2_0 of f0_0 : std_string_String
    | US2_1
and [&lt;Struct&gt;] US3 =
    | US3_0 of f0_0 : string
    | US3_1
and Mut4 = {mutable l0 : int32; mutable l1 : int32; mutable l2 : (string [])}
and Mut5 = {mutable l0 : int32}
and [&lt;Struct&gt;] US4 =
    | US4_0
    | US4_1
    | US4_2
and [&lt;Struct&gt;] US5 =
    | US5_0 of f0_0 : std_fs_FileType
    | US5_1 of f1_0 : std_string_String
and [&lt;Struct&gt;] US6 =
    | US6_0 of f0_0 : async_walkdir_DirEntry
    | US6_1 of f1_0 : std_string_String
and UH0 =
    | UH0_0
    | UH0_1 of char * UH0
and [&lt;Struct&gt;] US8 =
    | US8_0
    | US8_1
and [&lt;Struct&gt;] US7 =
    | US7_0
    | US7_1 of f1_0 : US8
    | US7_2
and UH1 =
    | UH1_0
    | UH1_1 of string * UH1
and [&lt;Struct&gt;] US9 =
    | US9_0
    | US9_1 of f1_0 : char
    | US9_2 of f2_0 : uint8 * f2_1 : char
and [&lt;Struct&gt;] US10 =
    | US10_0 of f0_0 : std_sync_Arc&lt;std_sync_Mutex&lt;std_process_Child option&gt;&gt;
    | US10_1 of f1_0 : std_string_String
and [&lt;Struct&gt;] US11 =
    | US11_0 of f0_0 : std_sync_Arc&lt;std_sync_Mutex&lt;std_sync_Arc&lt;std_sync_mpsc_Receiver&lt;std_string_String&gt;&gt;&gt;&gt;
    | US11_1
and [&lt;Struct&gt;] US12 =
    | US12_0 of f0_0 : std_string_String
    | US12_1 of f1_0 : std_string_String
and [&lt;Struct&gt;] US13 =
    | US13_0 of f0_0 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit)
    | US13_1
and [&lt;Struct&gt;] US14 =
    | US14_0 of f0_0 : std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt;
    | US14_1
and [&lt;Struct&gt;] US15 =
    | US15_0 of f0_0 : std_process_Output
    | US15_1 of f1_0 : std_string_String
and [&lt;Struct&gt;] US16 =
    | US16_0 of f0_0 : (struct (bool * string * int32) -&gt; Async&lt;unit&gt;)
    | US16_1
and [&lt;Struct&gt;] US17 =
    | US17_0 of f0_0 : System.Threading.CancellationToken
    | US17_1
and [&lt;Struct&gt;] US18 =
    | US18_0 of f0_0 : Result&lt;string, (string * string)&gt;
    | US18_1
and UH3 =
    | UH3_0
    | UH3_1 of string * string * (string -&gt; (string -&gt; US18)) * UH3
and UH2 =
    | UH2_0
    | UH2_1 of UH3 * UH2
and [&lt;Struct&gt;] US19 =
    | US19_0 of f0_0 : int32 * f0_1 : string
    | US19_1 of f1_0 : int32 * f1_1 : string
and Mut6 = {mutable l0 : int32; mutable l1 : int32}
and Mut7 = {mutable l0 : int32; mutable l1 : string; mutable l2 : int32; mutable l3 : int32}
and Mut8 = {mutable l0 : int32; mutable l1 : Vec&lt;Result&lt;string, (string * string)&gt; option&gt;}
let rec method0 () : clap_Command =
    let v0 : string = "command"
    let v1 : string = "r#\"" + v0 + "\"#"
    let v2 : StaticRef&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v1
    let v3 : string = "clap::Command::new($0)"
    let v4 : clap_Command = Fable.Core.RustInterop.emitRustExpr v2 v3
    let v5 : string = "source-dir"
    let v6 : string = "r#\"" + v5 + "\"#"
    let v7 : StaticRef&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v6
    let v8 : string = "clap::Arg::new($0)"
    let v9 : clap_Arg = Fable.Core.RustInterop.emitRustExpr v7 v8
    let v10 : string = "$0.short($1)"
    let v11 : clap_Arg = Fable.Core.RustInterop.emitRustExpr struct (v9, 's') v10
    let v12 : string = "r#\"" + v5 + "\"#"
    let v13 : StaticRef&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v12
    let v14 : string = "$0.long($1)"
    let v15 : clap_Arg = Fable.Core.RustInterop.emitRustExpr struct (v11, v13) v14
    let v16 : string = "$0.required($1)"
    let v17 : clap_Arg = Fable.Core.RustInterop.emitRustExpr struct (v15, true) v16
    let v18 : string = "clap::Command::arg($0, $1)"
    let v19 : clap_Command = Fable.Core.RustInterop.emitRustExpr struct (v4, v17) v18
    let v20 : string = "dist-dir"
    let v21 : string = "r#\"" + v20 + "\"#"
    let v22 : StaticRef&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v21
    let v23 : string = "clap::Arg::new($0)"
    let v24 : clap_Arg = Fable.Core.RustInterop.emitRustExpr v22 v23
    let v25 : string = "$0.short($1)"
    let v26 : clap_Arg = Fable.Core.RustInterop.emitRustExpr struct (v24, 'd') v25
    let v27 : string = "r#\"" + v20 + "\"#"
    let v28 : StaticRef&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v27
    let v29 : string = "$0.long($1)"
    let v30 : clap_Arg = Fable.Core.RustInterop.emitRustExpr struct (v26, v28) v29
    let v31 : string = "$0.required($1)"
    let v32 : clap_Arg = Fable.Core.RustInterop.emitRustExpr struct (v30, true) v31
    let v33 : string = "clap::Command::arg($0, $1)"
    let v34 : clap_Command = Fable.Core.RustInterop.emitRustExpr struct (v19, v32) v33
    let v35 : string = "cache-dir"
    let v36 : string = "r#\"" + v35 + "\"#"
    let v37 : StaticRef&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v36
    let v38 : string = "clap::Arg::new($0)"
    let v39 : clap_Arg = Fable.Core.RustInterop.emitRustExpr v37 v38
    let v40 : string = "$0.short($1)"
    let v41 : clap_Arg = Fable.Core.RustInterop.emitRustExpr struct (v39, 'c') v40
    let v42 : string = "r#\"" + v35 + "\"#"
    let v43 : StaticRef&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v42
    let v44 : string = "$0.long($1)"
    let v45 : clap_Arg = Fable.Core.RustInterop.emitRustExpr struct (v41, v43) v44
    let v46 : string = "$0.required($1)"
    let v47 : clap_Arg = Fable.Core.RustInterop.emitRustExpr struct (v45, true) v46
    let v48 : string = "clap::Command::arg($0, $1)"
    let v49 : clap_Command = Fable.Core.RustInterop.emitRustExpr struct (v34, v47) v48
    let v50 : string = "hangul-spec"
    let v51 : string = "r#\"" + v50 + "\"#"
    let v52 : StaticRef&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v51
    let v53 : string = "clap::Arg::new($0)"
    let v54 : clap_Arg = Fable.Core.RustInterop.emitRustExpr v52 v53
    let v55 : string = "$0.short($1)"
    let v56 : clap_Arg = Fable.Core.RustInterop.emitRustExpr struct (v54, 's') v55
    let v57 : string = "r#\"" + v50 + "\"#"
    let v58 : StaticRef&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v57
    let v59 : string = "$0.long($1)"
    let v60 : clap_Arg = Fable.Core.RustInterop.emitRustExpr struct (v56, v58) v59
    let v61 : string = "$0.required($1)"
    let v62 : clap_Arg = Fable.Core.RustInterop.emitRustExpr struct (v60, true) v61
    let v63 : string = "clap::Command::arg($0, $1)"
    let v64 : clap_Command = Fable.Core.RustInterop.emitRustExpr struct (v49, v62) v63
    v64
and closure0 () () : unit =
    let v0 : string = "true; () //"
    let v1 : bool = Fable.Core.RustInterop.emitRustExpr () v0
    let v2 : string = "} /* /*"
    Fable.Core.RustInterop.emitRustExpr () v2
    let v3 : string = "verify_app"
    let v4 : string = $"*/ #[test] fn " + v3 + "() { //"
    let v5 : bool = Fable.Core.RustInterop.emitRustExpr () v4
    let v6 : clap_Command = method0()
    let v7 : string = "clap::Command::debug_assert($0)"
    Fable.Core.RustInterop.emitRustExpr v6 v7
    let v8 : string = "{ //"
    Fable.Core.RustInterop.emitRustExpr () v8
    ()
and closure3 () (v0 : string) : unit =
    ()
and method1 () : string =
    let v0 : string = ""
    v0
and method2 () : string =
    let v0 : string = "AUTOMATION"
    v0
and closure2 () (v0 : US0) : struct (Mut0 * Mut1 * Mut2 * int64 option * Mut3) =
    let v1 : Mut1 = {l0 = true} : Mut1
    let v2 : Mut0 = {l0 = 0L} : Mut0
    let v3 : Mut2 = {l0 = v0} : Mut2
    let v4 : (string -&gt; unit) = closure3()
    let v5 : Mut3 = {l0 = v4} : Mut3
    let v6 : bool = true
    let mutable _v6 : int64 option option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v7 : bool = true
    let mutable _v7 : string option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v8 : string = "std::env::var(&amp;*$0)"
    let v9 : string = "AUTOMATION"
    let v10 : Result&lt;std_string_String, std_env_VarError&gt; = Fable.Core.RustInterop.emitRustExpr v9 v8
    let v11 : string = "true; let _result = $0.map(|x| { //"
    let v12 : bool = Fable.Core.RustInterop.emitRustExpr v10 v11
    let v13 : string = "x"
    let v14 : std_string_String = Fable.Core.RustInterop.emitRustExpr () v13
    let v15 : string = "fable_library_rust::String_::fromString($0)"
    let v16 : string = Fable.Core.RustInterop.emitRustExpr v14 v15
    let v17 : string = "true; $0 })"
    let v18 : bool = Fable.Core.RustInterop.emitRustExpr v16 v17
    let v19 : string = "_result"
    let v20 : Result&lt;string, std_env_VarError&gt; = Fable.Core.RustInterop.emitRustExpr () v19
    let v21 : string = method1()
    let v22 : string = "$0.unwrap_or($1)"
    let v23 : string = Fable.Core.RustInterop.emitRustExpr struct (v20, v21) v22
    v23 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v24 : string = null |&gt; unbox&lt;string&gt;
    v24 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v25 : string = null |&gt; unbox&lt;string&gt;
    v25 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v26 : string = null |&gt; unbox&lt;string&gt;
    v26 
    #endif
#if FABLE_COMPILER_PYTHON
    let v27 : string = null |&gt; unbox&lt;string&gt;
    v27 
    #endif
#else
    let v28 : string = method2()
    let v29 : (string -&gt; string) = System.Environment.GetEnvironmentVariable
    let v30 : string = v29 v28
    v30 
    #endif
    |&gt; fun x -&gt; _v7 &lt;- Some x
    let v31 : string = _v7.Value
    let v33 : bool = v31 = "True"
    let v39 : US1 =
        if v33 then
            let v34 : System.DateTime = System.DateTime.Now
            let v35 : (System.DateTime -&gt; int64) = _.Ticks
            let v36 : int64 = v35 v34
            US1_0(v36)
        else
            US1_1
    let v44 : int64 option =
        match v39 with
        | US1_1 -&gt; (* None *)
            let v42 : int64 option = None
            v42
        | US1_0(v40) -&gt; (* Some *)
            let v41 : int64 option = Some v40 
            v41
    v44 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v45 : int64 option = None
    v45 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v46 : int64 option = None
    v46 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v47 : int64 option = None
    v47 
    #endif
#if FABLE_COMPILER_PYTHON
    let v48 : int64 option = None
    v48 
    #endif
#else
    let v49 : bool = true
    let mutable _v49 : string option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v50 : string = "std::env::var(&amp;*$0)"
    let v51 : Result&lt;std_string_String, std_env_VarError&gt; = Fable.Core.RustInterop.emitRustExpr v9 v50
    let v52 : string = "true; let _result = $0.map(|x| { //"
    let v53 : bool = Fable.Core.RustInterop.emitRustExpr v51 v52
    let v54 : string = "x"
    let v55 : std_string_String = Fable.Core.RustInterop.emitRustExpr () v54
    let v56 : string = "fable_library_rust::String_::fromString($0)"
    let v57 : string = Fable.Core.RustInterop.emitRustExpr v55 v56
    let v58 : string = "true; $0 })"
    let v59 : bool = Fable.Core.RustInterop.emitRustExpr v57 v58
    let v60 : string = "_result"
    let v61 : Result&lt;string, std_env_VarError&gt; = Fable.Core.RustInterop.emitRustExpr () v60
    let v62 : string = method1()
    let v63 : string = "$0.unwrap_or($1)"
    let v64 : string = Fable.Core.RustInterop.emitRustExpr struct (v61, v62) v63
    v64 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v65 : string = null |&gt; unbox&lt;string&gt;
    v65 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v66 : string = null |&gt; unbox&lt;string&gt;
    v66 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v67 : string = null |&gt; unbox&lt;string&gt;
    v67 
    #endif
#if FABLE_COMPILER_PYTHON
    let v68 : string = null |&gt; unbox&lt;string&gt;
    v68 
    #endif
#else
    let v69 : string = method2()
    let v70 : (string -&gt; string) = System.Environment.GetEnvironmentVariable
    let v71 : string = v70 v69
    v71 
    #endif
    |&gt; fun x -&gt; _v49 &lt;- Some x
    let v72 : string = _v49.Value
    let v74 : bool = v72 = "True"
    let v80 : US1 =
        if v74 then
            let v75 : System.DateTime = System.DateTime.Now
            let v76 : (System.DateTime -&gt; int64) = _.Ticks
            let v77 : int64 = v76 v75
            US1_0(v77)
        else
            US1_1
    let v85 : int64 option =
        match v80 with
        | US1_1 -&gt; (* None *)
            let v83 : int64 option = None
            v83
        | US1_0(v81) -&gt; (* Some *)
            let v82 : int64 option = Some v81 
            v82
    v85 
    #endif
    |&gt; fun x -&gt; _v6 &lt;- Some x
    let v86 : int64 option = _v6.Value
    struct (v2, v1, v3, v86, v5)
and closure4 () () : string =
    let v0 : string = $"documents.main"
    v0
and closure6 () () : string =
    let v0 : string = ""
    v0
and closure5 (v0 : (string [])) () : string =
    let v1 : (unit -&gt; string) = closure6()
    let v2 : string = $"args: {v0} / {v1 ()}"
    v2
and method4 () : string =
    let v0 : string = ""
    v0
and closure7 (v0 : US0, v1 : (unit -&gt; string), v2 : (unit -&gt; string)) () : string =
    let v3 : (US0 -&gt; struct (Mut0 * Mut1 * Mut2 * int64 option * Mut3)) = closure2()
    let v4 : US0 = US0_0
    if State.trace_state.IsNone then State.trace_state &lt;- v3 v4 |&gt; Some
    let struct (v5 : Mut0, v6 : Mut1, v7 : Mut2, v8 : int64 option, v9 : Mut3) = State.trace_state.Value
    let v10 : bool = true
    let mutable _v10 : string option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v11 : US1 option = None
    let _v11 = ref v11 
    match v8 with
    | Some x -&gt; (
    (fun () -&gt;
    (fun () -&gt;
    let v12 : int64 = x
    let v13 : US1 = US1_0(v12)
    v13 
    )
    |&gt; fun x -&gt; x () |&gt; Some
    ) () ) | None -&gt; None
    |&gt; fun x -&gt; _v11.Value &lt;- x
    let v14 : US1 option = _v11.Value 
    let v15 : US1 = US1_1
    let v16 : US1 = v14 |&gt; Option.defaultValue v15 
    let v34 : System.DateTime =
        match v16 with
        | US1_1 -&gt; (* None *)
            let v32 : System.DateTime = System.DateTime.Now
            v32
        | US1_0(v17) -&gt; (* Some *)
            let v18 : System.DateTime = System.DateTime.Now
            let v19 : (System.DateTime -&gt; int64) = _.Ticks
            let v20 : int64 = v19 v18
            let v21 : int64 = v20 - v17
            let v22 : System.TimeSpan = System.TimeSpan v21 
            let v23 : (System.TimeSpan -&gt; int32) = _.Hours
            let v24 : int32 = v23 v22
            let v25 : (System.TimeSpan -&gt; int32) = _.Minutes
            let v26 : int32 = v25 v22
            let v27 : (System.TimeSpan -&gt; int32) = _.Seconds
            let v28 : int32 = v27 v22
            let v29 : (System.TimeSpan -&gt; int32) = _.Milliseconds
            let v30 : int32 = v29 v22
            let v31 : System.DateTime = System.DateTime (1, 1, 1, v24, v26, v28, v30)
            v31
    let v35 : string = "hh:mm:ss"
    let v36 : string = v34.ToString v35 
    v36 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v37 : string = method4()
    v37 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v38 : string = method4()
    v38 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v39 : string = method4()
    v39 
    #endif
#if FABLE_COMPILER_PYTHON
    let v40 : string = method4()
    v40 
    #endif
#else
    let v41 : US1 option = None
    let _v41 = ref v41 
    match v8 with
    | Some x -&gt; (
    (fun () -&gt;
    (fun () -&gt;
    let v42 : int64 = x
    let v43 : US1 = US1_0(v42)
    v43 
    )
    |&gt; fun x -&gt; x () |&gt; Some
    ) () ) | None -&gt; None
    |&gt; fun x -&gt; _v41.Value &lt;- x
    let v44 : US1 option = _v41.Value 
    let v45 : US1 = US1_1
    let v46 : US1 = v44 |&gt; Option.defaultValue v45 
    let v64 : System.DateTime =
        match v46 with
        | US1_1 -&gt; (* None *)
            let v62 : System.DateTime = System.DateTime.Now
            v62
        | US1_0(v47) -&gt; (* Some *)
            let v48 : System.DateTime = System.DateTime.Now
            let v49 : (System.DateTime -&gt; int64) = _.Ticks
            let v50 : int64 = v49 v48
            let v51 : int64 = v50 - v47
            let v52 : System.TimeSpan = System.TimeSpan v51 
            let v53 : (System.TimeSpan -&gt; int32) = _.Hours
            let v54 : int32 = v53 v52
            let v55 : (System.TimeSpan -&gt; int32) = _.Minutes
            let v56 : int32 = v55 v52
            let v57 : (System.TimeSpan -&gt; int32) = _.Seconds
            let v58 : int32 = v57 v52
            let v59 : (System.TimeSpan -&gt; int32) = _.Milliseconds
            let v60 : int32 = v59 v52
            let v61 : System.DateTime = System.DateTime (1, 1, 1, v54, v56, v58, v60)
            v61
    let v65 : string = "HH:mm:ss"
    let v66 : string = v64.ToString v65 
    v66 
    #endif
    |&gt; fun x -&gt; _v10 &lt;- Some x
    let v67 : string = _v10.Value
    let v68 : int64 = v5.l0
    let v78 : string =
        match v0 with
        | US0_4 -&gt; (* Critical *)
            let v73 : string = "Critical"
            v73
        | US0_1 -&gt; (* Debug *)
            let v70 : string = "Debug"
            v70
        | US0_2 -&gt; (* Info *)
            let v71 : string = "Info"
            v71
        | US0_0 -&gt; (* Verbose *)
            let v69 : string = "Verbose"
            v69
        | US0_3 -&gt; (* Warning *)
            let v72 : string = "Warning"
            v72
    let v79 : string = v78.ToLower ()
    let v80 : string = v79.PadLeft (7, ' ')
    let v81 : bool = true
    let mutable _v81 : string option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v96 : Ref&lt;Str&gt; =
        match v0 with
        | US0_4 -&gt; (* Critical *)
            let v90 : string = "inline_colorization::color_bright_red"
            let v91 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v90
            v91
        | US0_1 -&gt; (* Debug *)
            let v84 : string = "inline_colorization::color_bright_blue"
            let v85 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v84
            v85
        | US0_2 -&gt; (* Info *)
            let v86 : string = "inline_colorization::color_bright_green"
            let v87 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v86
            v87
        | US0_0 -&gt; (* Verbose *)
            let v82 : string = "inline_colorization::color_bright_black"
            let v83 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v82
            v83
        | US0_3 -&gt; (* Warning *)
            let v88 : string = "inline_colorization::color_yellow"
            let v89 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v88
            v89
    let v97 : string = "&amp;*$0"
    let v98 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v80 v97
    let v99 : string = "inline_colorization::color_reset"
    let v100 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v99
    let v101 : string = "\"{v96}{v98}{v100}\""
    let v102 : string = @$"format!(" + v101 + ")"
    let v103 : std_string_String = Fable.Core.RustInterop.emitRustExpr () v102
    let v104 : string = "fable_library_rust::String_::fromString($0)"
    let v105 : string = Fable.Core.RustInterop.emitRustExpr v103 v104
    v105 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v120 : Ref&lt;Str&gt; =
        match v0 with
        | US0_4 -&gt; (* Critical *)
            let v114 : string = "inline_colorization::color_bright_red"
            let v115 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v114
            v115
        | US0_1 -&gt; (* Debug *)
            let v108 : string = "inline_colorization::color_bright_blue"
            let v109 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v108
            v109
        | US0_2 -&gt; (* Info *)
            let v110 : string = "inline_colorization::color_bright_green"
            let v111 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v110
            v111
        | US0_0 -&gt; (* Verbose *)
            let v106 : string = "inline_colorization::color_bright_black"
            let v107 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v106
            v107
        | US0_3 -&gt; (* Warning *)
            let v112 : string = "inline_colorization::color_yellow"
            let v113 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v112
            v113
    let v121 : string = "&amp;*$0"
    let v122 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v80 v121
    let v123 : string = "inline_colorization::color_reset"
    let v124 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v123
    let v125 : string = "\"{v120}{v122}{v124}\""
    let v126 : string = @$"format!(" + v125 + ")"
    let v127 : std_string_String = Fable.Core.RustInterop.emitRustExpr () v126
    let v128 : string = "fable_library_rust::String_::fromString($0)"
    let v129 : string = Fable.Core.RustInterop.emitRustExpr v127 v128
    v129 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v144 : Ref&lt;Str&gt; =
        match v0 with
        | US0_4 -&gt; (* Critical *)
            let v138 : string = "inline_colorization::color_bright_red"
            let v139 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v138
            v139
        | US0_1 -&gt; (* Debug *)
            let v132 : string = "inline_colorization::color_bright_blue"
            let v133 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v132
            v133
        | US0_2 -&gt; (* Info *)
            let v134 : string = "inline_colorization::color_bright_green"
            let v135 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v134
            v135
        | US0_0 -&gt; (* Verbose *)
            let v130 : string = "inline_colorization::color_bright_black"
            let v131 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v130
            v131
        | US0_3 -&gt; (* Warning *)
            let v136 : string = "inline_colorization::color_yellow"
            let v137 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v136
            v137
    let v145 : string = "&amp;*$0"
    let v146 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v80 v145
    let v147 : string = "inline_colorization::color_reset"
    let v148 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v147
    let v149 : string = "\"{v144}{v146}{v148}\""
    let v150 : string = @$"format!(" + v149 + ")"
    let v151 : std_string_String = Fable.Core.RustInterop.emitRustExpr () v150
    let v152 : string = "fable_library_rust::String_::fromString($0)"
    let v153 : string = Fable.Core.RustInterop.emitRustExpr v151 v152
    v153 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    v80 
    #endif
#if FABLE_COMPILER_PYTHON
    v80 
    #endif
#else
    v80 
    #endif
    |&gt; fun x -&gt; _v81 &lt;- Some x
    let v154 : string = _v81.Value
    let v155 : string = $"{v67} {v154} #{v68} %s{v1 ()} / %s{v2 ()}"
    let v156 : (char []) = [||]
    let v157 : string = v155.TrimStart v156
    let v158 : (char []) = [|' '; '/'|]
    let v159 : string = v157.TrimEnd v158
    v159
and method5 (v0 : US0, v1 : (unit -&gt; string)) : unit =
    let v2 : (US0 -&gt; struct (Mut0 * Mut1 * Mut2 * int64 option * Mut3)) = closure2()
    let v3 : US0 = US0_0
    if State.trace_state.IsNone then State.trace_state &lt;- v2 v3 |&gt; Some
    let struct (v4 : Mut0, v5 : Mut1, v6 : Mut2, v7 : int64 option, v8 : Mut3) = State.trace_state.Value
    let v9 : US0 = US0_0
    if State.trace_state.IsNone then State.trace_state &lt;- v2 v9 |&gt; Some
    let struct (v10 : Mut0, v11 : Mut1, v12 : Mut2, v13 : int64 option, v14 : Mut3) = State.trace_state.Value
    let v15 : US0 = v12.l0
    let v16 : bool = v11.l0
    let v17 : bool = v16 = false
    let v21 : bool =
        if v17 then
            false
        else
            let v18 : int32 = [ US0_0, 0; US0_1, 1; US0_2, 2; US0_3, 3; US0_4, 4 ] |&gt; Map |&gt; Map.find v0
            let v19 : int32 = [ US0_0, 0; US0_1, 1; US0_2, 2; US0_3, 3; US0_4, 4 ] |&gt; Map |&gt; Map.find v15
            let v20 : bool = v18 &gt;= v19
            v20
    if v21 then
        let v22 : int64 = v4.l0
        let v23 : int64 = v22 + 1L
        v4.l0 &lt;- v23
        let v24 : string = $"%s{v1 ()}"
        let v25 : bool = true
        let mutable _v25 : unit option = None 
        
#if FABLE_COMPILER || WASM || CONTRACT
        
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
        let v26 : string = @"println!(""{}"", $0)"
        Fable.Core.RustInterop.emitRustExpr v24 v26
        () 
        #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
        let v27 : string = @"println!(""{}"", $0)"
        Fable.Core.RustInterop.emitRustExpr v24 v27
        () 
        #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
        let v28 : string = @"println!(""{}"", $0)"
        Fable.Core.RustInterop.emitRustExpr v24 v28
        () 
        #endif
#if FABLE_COMPILER_TYPESCRIPT
        System.Console.WriteLine v24 
        () 
        #endif
#if FABLE_COMPILER_PYTHON
        System.Console.WriteLine v24 
        () 
        #endif
#else
        System.Console.WriteLine v24 
        () 
        #endif
        |&gt; fun x -&gt; _v25 &lt;- Some x
        _v25.Value
        let v29 : (string -&gt; unit) = v8.l0
        v29 v24
and method3 (v0 : US0, v1 : (unit -&gt; string), v2 : (unit -&gt; string)) : unit =
    let v3 : (unit -&gt; string) = closure7(v0, v1, v2)
    method5(v0, v3)
and method6 () : string =
    let v0 : string = "source-dir"
    v0
and method7 () : string =
    let v0 : string = "dist-dir"
    v0
and method8 () : string =
    let v0 : string = "cache-dir"
    v0
and method9 () : string =
    let v0 : string = "hangul-spec"
    v0
and method12 (v0 : string) : string =
    v0
and method13 (v0 : string) : string =
    v0
and method11 (v0 : string, v1 : string) : string =
    let v2 : bool = true
    let mutable _v2 : string option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v3 : string = "&amp;*$0"
    let v4 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v0 v3
    let v5 : string = "String::from($0)"
    let v6 : std_string_String = Fable.Core.RustInterop.emitRustExpr v4 v5
    let v7 : string = "std::path::PathBuf::from($0)"
    let v8 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v6 v7
    let v9 : string = "&amp;*$0"
    let v10 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v1 v9
    let v11 : string = "String::from($0)"
    let v12 : std_string_String = Fable.Core.RustInterop.emitRustExpr v10 v11
    let v13 : string = "$0.join($1)"
    let v14 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr struct (v8, v12) v13
    let v15 : string = "$0.display()"
    let v16 : std_path_Display = Fable.Core.RustInterop.emitRustExpr v14 v15
    let v17 : bool = true
    let mutable _v17 : std_string_String option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v18 : string = "format!(\"{}\", $0)"
    let v19 : std_string_String = Fable.Core.RustInterop.emitRustExpr v16 v18
    v19 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v20 : string = "format!(\"{}\", $0)"
    let v21 : std_string_String = Fable.Core.RustInterop.emitRustExpr v16 v20
    v21 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v22 : string = "format!(\"{}\", $0)"
    let v23 : std_string_String = Fable.Core.RustInterop.emitRustExpr v16 v22
    v23 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v24 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
    v24 
    #endif
#if FABLE_COMPILER_PYTHON
    let v25 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
    v25 
    #endif
#else
    let v26 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
    v26 
    #endif
    |&gt; fun x -&gt; _v17 &lt;- Some x
    let v27 : std_string_String = _v17.Value
    let v28 : string = "fable_library_rust::String_::fromString($0)"
    let v29 : string = Fable.Core.RustInterop.emitRustExpr v27 v28
    v29 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v30 : string = null |&gt; unbox&lt;string&gt;
    v30 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v31 : string = null |&gt; unbox&lt;string&gt;
    v31 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v32 : string = "path"
    let v33 : IPathJoin = Fable.Core.JsInterop.importAll v32
    let v34 : string = method12(v0)
    let v35 : string = method13(v1)
    let v36 : string = "v33.join(v34, v35)"
    let v37 : string = Fable.Core.JsInterop.emitJsExpr () v36
    v37 
    #endif
#if FABLE_COMPILER_PYTHON
    let v38 : string = null |&gt; unbox&lt;string&gt;
    v38 
    #endif
#else
    let v39 : string = System.IO.Path.Combine (v0, v1)
    v39 
    #endif
    |&gt; fun x -&gt; _v2 &lt;- Some x
    let v40 : string = _v2.Value
    v40
and closure8 () (v0 : string) : string option =
    let v1 : bool = true
    let mutable _v1 : US3 option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v2 : string = "&amp;*$0"
    let v3 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v0 v2
    let v4 : string = "String::from($0)"
    let v5 : std_string_String = Fable.Core.RustInterop.emitRustExpr v3 v4
    let v6 : string = "std::path::PathBuf::from($0)"
    let v7 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v5 v6
    let v8 : string = "$0.parent().map(std::path::PathBuf::from)"
    let v9 : std_path_PathBuf option = Fable.Core.RustInterop.emitRustExpr v7 v8
    let v10 : string = "$0?"
    let v11 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v9 v10
    let v12 : string = "$0.display()"
    let v13 : std_path_Display = Fable.Core.RustInterop.emitRustExpr v11 v12
    let v14 : bool = true
    let mutable _v14 : std_string_String option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v15 : string = "format!(\"{}\", $0)"
    let v16 : std_string_String = Fable.Core.RustInterop.emitRustExpr v13 v15
    v16 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v17 : string = "format!(\"{}\", $0)"
    let v18 : std_string_String = Fable.Core.RustInterop.emitRustExpr v13 v17
    v18 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v19 : string = "format!(\"{}\", $0)"
    let v20 : std_string_String = Fable.Core.RustInterop.emitRustExpr v13 v19
    v20 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v21 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
    v21 
    #endif
#if FABLE_COMPILER_PYTHON
    let v22 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
    v22 
    #endif
#else
    let v23 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
    v23 
    #endif
    |&gt; fun x -&gt; _v14 &lt;- Some x
    let v24 : std_string_String = _v14.Value
    let v25 : string = "fable_library_rust::String_::fromString($0)"
    let v26 : string = Fable.Core.RustInterop.emitRustExpr v24 v25
    let v27 : US3 = US3_0(v26)
    v27 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v28 : US3 = null |&gt; unbox&lt;US3&gt;
    v28 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v29 : US3 = null |&gt; unbox&lt;US3&gt;
    v29 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v30 : string = "path"
    let v31 : IPathDirname = Fable.Core.JsInterop.importAll v30
    let v32 : string = "v31.dirname($0)"
    let v33 : string = Fable.Core.JsInterop.emitJsExpr v0 v32
    let v34 : US3 = US3_0(v33)
    v34 
    #endif
#if FABLE_COMPILER_PYTHON
    let v35 : US3 = null |&gt; unbox&lt;US3&gt;
    v35 
    #endif
#else
    let v36 : (string -&gt; System.IO.DirectoryInfo) = System.IO.Directory.GetParent
    let v37 : System.IO.DirectoryInfo = v36 v0
    let v38 : System.IO.DirectoryInfo = null |&gt; unbox&lt;System.IO.DirectoryInfo&gt;
    let v39 : bool = v37 = v38
    let v50 : US3 =
        if v39 then
            US3_1
        else
            let v41 : bool = true
            let mutable _v41 : string option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v42 : string = null |&gt; unbox&lt;string&gt;
            v42 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v43 : string = null |&gt; unbox&lt;string&gt;
            v43 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v44 : string = null |&gt; unbox&lt;string&gt;
            v44 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v45 : string = null |&gt; unbox&lt;string&gt;
            v45 
            #endif
#if FABLE_COMPILER_PYTHON
            let v46 : string = null |&gt; unbox&lt;string&gt;
            v46 
            #endif
#else
            let v47 : string = v37.FullName
            v47 
            #endif
            |&gt; fun x -&gt; _v41 &lt;- Some x
            let v48 : string = _v41.Value
            US3_0(v48)
    v50 
    #endif
    |&gt; fun x -&gt; _v1 &lt;- Some x
    let v51 : US3 = _v1.Value
    match v51 with
    | US3_1 -&gt; (* None *)
        let v54 : string option = None
        v54
    | US3_0(v52) -&gt; (* Some *)
        let v53 : string option = Some v52 
        v53
and method15 () : (string -&gt; string option) =
    closure8()
and method16 (v0 : string, v1 : string, v2 : string) : string =
    let v3 : string = method11(v2, v0)
    let v4 : bool = true
    let mutable _v4 : bool option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v5 : string = "&amp;*$0"
    let v6 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v3 v5
    let v7 : string = "String::from($0)"
    let v8 : std_string_String = Fable.Core.RustInterop.emitRustExpr v6 v7
    let v9 : string = "std::path::PathBuf::from($0)"
    let v10 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v8 v9
    let v11 : string = "$0.exists()"
    let v12 : bool = Fable.Core.RustInterop.emitRustExpr v10 v11
    let v15 : bool =
        if v12 then
            let v13 : string = "$0.is_dir()"
            let v14 : bool = Fable.Core.RustInterop.emitRustExpr v10 v13
            v14
        else
            false
    v15 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v16 : bool = null |&gt; unbox&lt;bool&gt;
    v16 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v17 : bool = null |&gt; unbox&lt;bool&gt;
    v17 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v18 : string = "fs"
    let v19 : IFsExistsSync = Fable.Core.JsInterop.importAll v18
    let v20 : string = "$0.existsSync($1)"
    let v21 : bool = Fable.Core.JsInterop.emitJsExpr struct (v19, v3) v20
    v21 
    #endif
#if FABLE_COMPILER_PYTHON
    let v22 : bool = null |&gt; unbox&lt;bool&gt;
    v22 
    #endif
#else
    let v23 : (string -&gt; bool) = System.IO.Directory.Exists
    let v24 : bool = v23 v3
    v24 
    #endif
    |&gt; fun x -&gt; _v4 &lt;- Some x
    let v25 : bool = _v4.Value
    if v25 then
        v2
    else
        let v26 : (string -&gt; string option) = method15()
        let v27 : string option = v26 v2
        let v28 : US3 option = None
        let _v28 = ref v28 
        match v27 with
        | Some x -&gt; (
        (fun () -&gt;
        (fun () -&gt;
        let v29 : string = x
        let v30 : US3 = US3_0(v29)
        v30 
        )
        |&gt; fun x -&gt; x () |&gt; Some
        ) () ) | None -&gt; None
        |&gt; fun x -&gt; _v28.Value &lt;- x
        let v31 : US3 option = _v28.Value 
        let v32 : US3 = US3_1
        let v33 : US3 = v31 |&gt; Option.defaultValue v32 
        match v33 with
        | US3_1 -&gt; (* None *)
            let v36 : string = $"""No parent for {if false then "file" else "dir"} '{v0}' at '{v1}' (until '{v2}')"""
            failwith&lt;string&gt; v36
        | US3_0(v34) -&gt; (* Some *)
            method16(v0, v1, v34)
and method14 (v0 : string, v1 : string) : string =
    let v2 : string = method11(v1, v0)
    let v3 : bool = true
    let mutable _v3 : bool option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v4 : string = "&amp;*$0"
    let v5 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v2 v4
    let v6 : string = "String::from($0)"
    let v7 : std_string_String = Fable.Core.RustInterop.emitRustExpr v5 v6
    let v8 : string = "std::path::PathBuf::from($0)"
    let v9 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v7 v8
    let v10 : string = "$0.exists()"
    let v11 : bool = Fable.Core.RustInterop.emitRustExpr v9 v10
    let v14 : bool =
        if v11 then
            let v12 : string = "$0.is_dir()"
            let v13 : bool = Fable.Core.RustInterop.emitRustExpr v9 v12
            v13
        else
            false
    v14 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v15 : bool = null |&gt; unbox&lt;bool&gt;
    v15 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v16 : bool = null |&gt; unbox&lt;bool&gt;
    v16 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v17 : string = "fs"
    let v18 : IFsExistsSync = Fable.Core.JsInterop.importAll v17
    let v19 : string = "$0.existsSync($1)"
    let v20 : bool = Fable.Core.JsInterop.emitJsExpr struct (v18, v2) v19
    v20 
    #endif
#if FABLE_COMPILER_PYTHON
    let v21 : bool = null |&gt; unbox&lt;bool&gt;
    v21 
    #endif
#else
    let v22 : (string -&gt; bool) = System.IO.Directory.Exists
    let v23 : bool = v22 v2
    v23 
    #endif
    |&gt; fun x -&gt; _v3 &lt;- Some x
    let v24 : bool = _v3.Value
    if v24 then
        v1
    else
        let v25 : (string -&gt; string option) = method15()
        let v26 : string option = v25 v1
        let v27 : US3 option = None
        let _v27 = ref v27 
        match v26 with
        | Some x -&gt; (
        (fun () -&gt;
        (fun () -&gt;
        let v28 : string = x
        let v29 : US3 = US3_0(v28)
        v29 
        )
        |&gt; fun x -&gt; x () |&gt; Some
        ) () ) | None -&gt; None
        |&gt; fun x -&gt; _v27.Value &lt;- x
        let v30 : US3 option = _v27.Value 
        let v31 : US3 = US3_1
        let v32 : US3 = v30 |&gt; Option.defaultValue v31 
        match v32 with
        | US3_1 -&gt; (* None *)
            let v35 : string = $"""No parent for {if false then "file" else "dir"} '{v0}' at '{v1}' (until '{v1}')"""
            failwith&lt;string&gt; v35
        | US3_0(v33) -&gt; (* Some *)
            method16(v0, v1, v33)
and method17 (v0 : string) : string =
    v0
and method18 (v0 : string) : string =
    v0
and method19 () : string =
    let v0 : string = ""
    v0
and method20 () : string =
    let v0 : string = "^\\\\\\\\\\?\\\\"
    v0
and method21 () : string =
    let v0 : string = ""
    v0
and method22 (v0 : int32, v1 : Mut4) : bool =
    let v2 : int32 = v1.l0
    let v3 : bool = v2 &lt; v0
    v3
and method23 (v0 : int32, v1 : Mut5) : bool =
    let v2 : int32 = v1.l0
    let v3 : bool = v2 &lt; v0
    v3
and method24 (v0 : string) : string =
    v0
and method25 (v0 : string) : string =
    v0
and closure9 () () : string =
    let v0 : string = "documents.run"
    v0
and closure10 (v0 : string, v1 : string, v2 : string, v3 : string) () : string =
    let v4 : (unit -&gt; string) = closure6()
    let v5 : string = $"source_dir: {v1} / dist_dir: {v2} / cache_dir: {v3} / hangul_spec: %A{v0} / {v4 ()}"
    v5
and method28 (v0 : async_walkdir_DirEntry) : async_walkdir_DirEntry =
    v0
and closure12 () (v0 : std_io_Error) : std_string_String =
    let v1 : bool = true
    let mutable _v1 : std_string_String option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v2 : string = "format!(\"{}\", $0)"
    let v3 : std_string_String = Fable.Core.RustInterop.emitRustExpr v0 v2
    v3 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v4 : string = "format!(\"{}\", $0)"
    let v5 : std_string_String = Fable.Core.RustInterop.emitRustExpr v0 v4
    v5 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v6 : string = "format!(\"{}\", $0)"
    let v7 : std_string_String = Fable.Core.RustInterop.emitRustExpr v0 v6
    v7 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v8 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
    v8 
    #endif
#if FABLE_COMPILER_PYTHON
    let v9 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
    v9 
    #endif
#else
    let v10 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
    v10 
    #endif
    |&gt; fun x -&gt; _v1 &lt;- Some x
    let v11 : std_string_String = _v1.Value
    v11
and method29 () : (std_io_Error -&gt; std_string_String) =
    closure12()
and closure13 () (v0 : std_fs_FileType) : US5 =
    US5_0(v0)
and closure14 () (v0 : std_string_String) : US5 =
    US5_1(v0)
and method30 (v0 : std_fs_FileType) : std_fs_FileType =
    v0
and method31 (v0 : US4) : US4 =
    v0
and method27 (v0 : async_walkdir_DirEntry) : std_pin_Pin&lt;Box&lt;Send&lt;Dyn&lt;std_future_Future&lt;US4&gt;&gt;&gt;&gt;&gt; =
    let v1 : string = "let __result = Box::pin(async move { //"
    Fable.Core.RustInterop.emitRustExpr () v1
    let v2 : async_walkdir_DirEntry = method28(v0)
    let v3 : string = "Box::pin(async_walkdir::DirEntry::file_type(&amp;v2))"
    let v4 : std_pin_Pin&lt;Box&lt;Send&lt;Dyn&lt;std_future_Future&lt;Result&lt;std_fs_FileType, std_io_Error&gt;&gt;&gt;&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v3
    let v5 : string = "v4.await"
    let v6 : Result&lt;std_fs_FileType, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr () v5
    let v7 : (std_io_Error -&gt; std_string_String) = method29()
    let v8 : string = "$0.map_err(|x| $1(x))"
    let v9 : Result&lt;std_fs_FileType, std_string_String&gt; = Fable.Core.RustInterop.emitRustExpr struct (v6, v7) v8
    let v10 : (std_fs_FileType -&gt; US5) = closure13()
    let v11 : (std_string_String -&gt; US5) = closure14()
    let v12 : US5 = match v9 with Ok x -&gt; v10 x | Error x -&gt; v11 x
    let v71 : US4 =
        match v12 with
        | US5_0(v13) -&gt; (* Ok *)
            let v14 : std_fs_FileType = method30(v13)
            let v15 : string = "std::fs::FileType::is_dir(&amp;v14)"
            let v16 : bool = Fable.Core.RustInterop.emitRustExpr () v15
            if v16 then
                US4_0
            else
                let v18 : string = "async_walkdir::DirEntry::path(&amp;$0)"
                let v19 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v0 v18
                let v20 : string = "$0.display()"
                let v21 : std_path_Display = Fable.Core.RustInterop.emitRustExpr v19 v20
                let v22 : bool = true
                let mutable _v22 : std_string_String option = None 
                
#if FABLE_COMPILER || WASM || CONTRACT
                
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                let v23 : string = "format!(\"{}\", $0)"
                let v24 : std_string_String = Fable.Core.RustInterop.emitRustExpr v21 v23
                v24 
                #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                let v25 : string = "format!(\"{}\", $0)"
                let v26 : std_string_String = Fable.Core.RustInterop.emitRustExpr v21 v25
                v26 
                #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                let v27 : string = "format!(\"{}\", $0)"
                let v28 : std_string_String = Fable.Core.RustInterop.emitRustExpr v21 v27
                v28 
                #endif
#if FABLE_COMPILER_TYPESCRIPT
                let v29 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
                v29 
                #endif
#if FABLE_COMPILER_PYTHON
                let v30 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
                v30 
                #endif
#else
                let v31 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
                v31 
                #endif
                |&gt; fun x -&gt; _v22 &lt;- Some x
                let v32 : std_string_String = _v22.Value
                let v33 : string = "fable_library_rust::String_::fromString($0)"
                let v34 : string = Fable.Core.RustInterop.emitRustExpr v32 v33
                let v35 : string = ".md"
                let v36 : bool = v34.EndsWith v35
                let v37 : bool = v36 = false
                let v40 : bool =
                    if v37 then
                        true
                    else
                        let v38 : string = ".hangul.md"
                        let v39 : bool = v34.EndsWith v38
                        v39
                if v40 then
                    US4_0
                else
                    US4_2
        | _ -&gt;
            let v45 : string = "async_walkdir::DirEntry::path(&amp;$0)"
            let v46 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v0 v45
            let v47 : string = "$0.display()"
            let v48 : std_path_Display = Fable.Core.RustInterop.emitRustExpr v46 v47
            let v49 : bool = true
            let mutable _v49 : std_string_String option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v50 : string = "format!(\"{}\", $0)"
            let v51 : std_string_String = Fable.Core.RustInterop.emitRustExpr v48 v50
            v51 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v52 : string = "format!(\"{}\", $0)"
            let v53 : std_string_String = Fable.Core.RustInterop.emitRustExpr v48 v52
            v53 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v54 : string = "format!(\"{}\", $0)"
            let v55 : std_string_String = Fable.Core.RustInterop.emitRustExpr v48 v54
            v55 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v56 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v56 
            #endif
#if FABLE_COMPILER_PYTHON
            let v57 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v57 
            #endif
#else
            let v58 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v58 
            #endif
            |&gt; fun x -&gt; _v49 &lt;- Some x
            let v59 : std_string_String = _v49.Value
            let v60 : string = "fable_library_rust::String_::fromString($0)"
            let v61 : string = Fable.Core.RustInterop.emitRustExpr v59 v60
            let v62 : string = ".md"
            let v63 : bool = v61.EndsWith v62
            let v64 : bool = v63 = false
            let v67 : bool =
                if v64 then
                    true
                else
                    let v65 : string = ".hangul.md"
                    let v66 : bool = v61.EndsWith v65
                    v66
            if v67 then
                US4_0
            else
                US4_2
    let v72 : US4 = method31(v71)
    let v73 : string = "v72 }})"
    Fable.Core.RustInterop.emitRustExpr () v73
    let v74 : string = "{ //"
    Fable.Core.RustInterop.emitRustExpr () v74
    let v75 : string = "__result"
    let v76 : std_pin_Pin&lt;Box&lt;Send&lt;Dyn&lt;std_future_Future&lt;US4&gt;&gt;&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v75
    v76
and method32 (v0 : async_walkdir_Filtering) : async_walkdir_Filtering =
    v0
and method26 (v0 : async_walkdir_DirEntry) : std_pin_Pin&lt;Box&lt;Send&lt;Dyn&lt;std_future_Future&lt;async_walkdir_Filtering&gt;&gt;&gt;&gt;&gt; =
    let v1 : string = "let __result = Box::pin(async { //"
    Fable.Core.RustInterop.emitRustExpr () v1
    let v2 : std_pin_Pin&lt;Box&lt;Send&lt;Dyn&lt;std_future_Future&lt;US4&gt;&gt;&gt;&gt;&gt; = method27(v0)
    let v3 : string = "v2.await"
    let v4 : US4 = Fable.Core.RustInterop.emitRustExpr () v3
    let v13 : async_walkdir_Filtering =
        match v4 with
        | US4_2 -&gt; (* Continue *)
            let v9 : string = "async_walkdir::Filtering::Continue"
            let v10 : async_walkdir_Filtering = Fable.Core.RustInterop.emitRustExpr () v9
            v10
        | US4_0 -&gt; (* Ignore *)
            let v5 : string = "async_walkdir::Filtering::Ignore"
            let v6 : async_walkdir_Filtering = Fable.Core.RustInterop.emitRustExpr () v5
            v6
        | US4_1 -&gt; (* IgnoreDir *)
            let v7 : string = "async_walkdir::Filtering::IgnoreDir"
            let v8 : async_walkdir_Filtering = Fable.Core.RustInterop.emitRustExpr () v7
            v8
    let v14 : async_walkdir_Filtering = method32(v13)
    let v15 : string = "v14 }})"
    Fable.Core.RustInterop.emitRustExpr () v15
    let v16 : string = "{ //"
    Fable.Core.RustInterop.emitRustExpr () v16
    let v17 : string = "__result"
    let v18 : std_pin_Pin&lt;Box&lt;Send&lt;Dyn&lt;std_future_Future&lt;async_walkdir_Filtering&gt;&gt;&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v17
    v18
and closure11 () (v0 : async_walkdir_DirEntry) : std_pin_Pin&lt;Box&lt;Send&lt;Dyn&lt;std_future_Future&lt;async_walkdir_Filtering&gt;&gt;&gt;&gt;&gt; =
    method26(v0)
and closure16 () (v0 : async_walkdir_DirEntry) : US6 =
    US6_0(v0)
and closure17 () (v0 : std_string_String) : US6 =
    US6_1(v0)
and closure18 () () : string =
    let v0 : string = "documents.run / stream_filter_map"
    v0
and closure19 (v0 : std_string_String) () : string =
    let v1 : (unit -&gt; string) = closure6()
    let v2 : string = $"error: {v0} / {v1 ()}"
    v2
and closure15 () (v0 : Result&lt;async_walkdir_DirEntry, std_io_Error&gt;) : string option =
    let v1 : (std_io_Error -&gt; std_string_String) = method29()
    let v2 : string = "$0.map_err(|x| $1(x))"
    let v3 : Result&lt;async_walkdir_DirEntry, std_string_String&gt; = Fable.Core.RustInterop.emitRustExpr struct (v0, v1) v2
    let v4 : (async_walkdir_DirEntry -&gt; US6) = closure16()
    let v5 : (std_string_String -&gt; US6) = closure17()
    let v6 : US6 = match v3 with Ok x -&gt; v4 x | Error x -&gt; v5 x
    let v32 : US3 =
        match v6 with
        | US6_1(v26) -&gt; (* Error *)
            let v27 : US0 = US0_4
            let v28 : (unit -&gt; string) = closure18()
            let v29 : (unit -&gt; string) = closure19(v26)
            method3(v27, v28, v29)
            US3_1
        | US6_0(v7) -&gt; (* Ok *)
            let v8 : string = "async_walkdir::DirEntry::path(&amp;$0)"
            let v9 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v7 v8
            let v10 : string = "$0.display()"
            let v11 : std_path_Display = Fable.Core.RustInterop.emitRustExpr v9 v10
            let v12 : bool = true
            let mutable _v12 : std_string_String option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v13 : string = "format!(\"{}\", $0)"
            let v14 : std_string_String = Fable.Core.RustInterop.emitRustExpr v11 v13
            v14 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v15 : string = "format!(\"{}\", $0)"
            let v16 : std_string_String = Fable.Core.RustInterop.emitRustExpr v11 v15
            v16 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v17 : string = "format!(\"{}\", $0)"
            let v18 : std_string_String = Fable.Core.RustInterop.emitRustExpr v11 v17
            v18 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v19 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v19 
            #endif
#if FABLE_COMPILER_PYTHON
            let v20 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v20 
            #endif
#else
            let v21 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v21 
            #endif
            |&gt; fun x -&gt; _v12 &lt;- Some x
            let v22 : std_string_String = _v12.Value
            let v23 : string = "fable_library_rust::String_::fromString($0)"
            let v24 : string = Fable.Core.RustInterop.emitRustExpr v22 v23
            US3_0(v24)
    match v32 with
    | US3_1 -&gt; (* None *)
        let v35 : string option = None
        v35
    | US3_0(v33) -&gt; (* Some *)
        let v34 : string option = Some v33 
        v34
and method33 () : (Result&lt;async_walkdir_DirEntry, std_io_Error&gt; -&gt; string option) =
    closure15()
and closure20 () () : string =
    let v0 : string = "documents.run"
    v0
and closure21 (v0 : Vec&lt;string&gt;) () : string =
    let v1 : string = "$0.len()"
    let v2 : unativeint = Fable.Core.RustInterop.emitRustExpr v0 v1
    let v3 : (unit -&gt; string) = closure6()
    let v4 : string = $"files_len: {v2} / {v3 ()}"
    v4
and method34 (v0 : string) : string =
    let v1 : bool = true
    let mutable _v1 : string option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v2 : string = method17(v0)
    let v3 : string = "&amp;*$0"
    let v4 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v2 v3
    let v5 : string = "String::from($0)"
    let v6 : std_string_String = Fable.Core.RustInterop.emitRustExpr v4 v5
    let v7 : string = "std::path::PathBuf::from($0)"
    let v8 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v6 v7
    let v9 : string = "$0.exists()"
    let v10 : bool = Fable.Core.RustInterop.emitRustExpr v8 v9
    let v11 : bool = v10 = false
    let v167 : string =
        if v11 then
            let v12 : bool = true
            let mutable _v12 : string option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v13 : string = "std::env::current_dir()"
            let v14 : Result&lt;std_path_PathBuf, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr () v13
            let v15 : string = "$0.unwrap()"
            let v16 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v14 v15
            let v17 : string = "$0.display()"
            let v18 : std_path_Display = Fable.Core.RustInterop.emitRustExpr v16 v17
            let v19 : bool = true
            let mutable _v19 : std_string_String option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v20 : string = "format!(\"{}\", $0)"
            let v21 : std_string_String = Fable.Core.RustInterop.emitRustExpr v18 v20
            v21 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v22 : string = "format!(\"{}\", $0)"
            let v23 : std_string_String = Fable.Core.RustInterop.emitRustExpr v18 v22
            v23 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v24 : string = "format!(\"{}\", $0)"
            let v25 : std_string_String = Fable.Core.RustInterop.emitRustExpr v18 v24
            v25 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v26 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v26 
            #endif
#if FABLE_COMPILER_PYTHON
            let v27 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v27 
            #endif
#else
            let v28 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v28 
            #endif
            |&gt; fun x -&gt; _v19 &lt;- Some x
            let v29 : std_string_String = _v19.Value
            let v30 : string = "fable_library_rust::String_::fromString($0)"
            let v31 : string = Fable.Core.RustInterop.emitRustExpr v29 v30
            v31 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v32 : string = null |&gt; unbox&lt;string&gt;
            v32 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v33 : string = null |&gt; unbox&lt;string&gt;
            v33 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v34 : string = null |&gt; unbox&lt;string&gt;
            v34 
            #endif
#if FABLE_COMPILER_PYTHON
            let v35 : string = null |&gt; unbox&lt;string&gt;
            v35 
            #endif
#else
            let v36 : (unit -&gt; string) = System.IO.Directory.GetCurrentDirectory
            let v37 : string = v36 ()
            v37 
            #endif
            |&gt; fun x -&gt; _v12 &lt;- Some x
            let v38 : string = _v12.Value
            let v39 : string = method11(v38, v2)
            let v40 : bool = true
            let mutable _v40 : string option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v41 : string = method18(v39)
            let v42 : string = method19()
            let v43 : bool = true
            let mutable _v43 : Result&lt;regex_Regex, regex_Error&gt; option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v44 : string = method20()
            let v45 : string = $"regex::Regex::new(&amp;$0)"
            let v46 : Result&lt;regex_Regex, regex_Error&gt; = Fable.Core.RustInterop.emitRustExpr v44 v45
            v46 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v47 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v47 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v48 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v48 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v49 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v49 
            #endif
#if FABLE_COMPILER_PYTHON
            let v50 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v50 
            #endif
#else
            let v51 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v51 
            #endif
            |&gt; fun x -&gt; _v43 &lt;- Some x
            let v52 : Result&lt;regex_Regex, regex_Error&gt; = _v43.Value
            let v53 : string = "$0.unwrap()"
            let v54 : regex_Regex = Fable.Core.RustInterop.emitRustExpr v52 v53
            let v55 : string = $"$0.replace_all(&amp;$1, &amp;*$2)"
            let v56 : std_borrow_Cow&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr struct (v54, v41, v42) v55
            let v57 : string = "String::from($0)"
            let v58 : std_string_String = Fable.Core.RustInterop.emitRustExpr v56 v57
            let v59 : string = "fable_library_rust::String_::fromString($0)"
            let v60 : string = Fable.Core.RustInterop.emitRustExpr v58 v59
            v60 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v61 : string = null |&gt; unbox&lt;string&gt;
            v61 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v62 : string = null |&gt; unbox&lt;string&gt;
            v62 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v63 : string = null |&gt; unbox&lt;string&gt;
            v63 
            #endif
#if FABLE_COMPILER_PYTHON
            let v64 : string = null |&gt; unbox&lt;string&gt;
            v64 
            #endif
#else
            let v65 : string = method21()
            let v66 : string = "^\\\\\\\\\\?\\\\"
            let v67 : string = System.Text.RegularExpressions.Regex.Replace (v39, v66, v65)
            v67 
            #endif
            |&gt; fun x -&gt; _v40 &lt;- Some x
            let v68 : string = _v40.Value
            let v69 : string = $"{v68.[0] |&gt; string |&gt; _.ToLower()}{v68.[1..]}"
            let v70 : string = "\\"
            let v71 : string = "/"
            let v72 : string = v69.Replace (v70, v71)
            let v73 : (string []) = v72.Split v71
            let v74 : (string []) = [||]
            let v75 : int32 = v73.Length
            let v76 : Mut4 = {l0 = 0; l1 = 0; l2 = v74} : Mut4
            while method22(v75, v76) do
                let v78 : int32 = v76.l0
                let v79 : int32 =  -v78
                let v80 : int32 = v79 + v75
                let v81 : int32 = v80 - 1
                let struct (v82 : int32, v83 : (string [])) = v76.l1, v76.l2
                let v84 : string = v73.[int v81]
                let v85 : bool = ".." = v84
                let struct (v127 : int32, v128 : (string [])) =
                    if v85 then
                        let v86 : int32 = v82 + 1
                        struct (v86, v83)
                    else
                        let v87 : bool = "." = v84
                        if v87 then
                            struct (v82, v83)
                        else
                            let v88 : bool = 0 = v82
                            if v88 then
                                let v89 : string = ":"
                                let v90 : bool = v84.EndsWith v89
                                if v90 then
                                    let v91 : string = $"{v38.[0]}:"
                                    let v92 : (string []) = [|v91|]
                                    let v93 : int32 = v92.Length
                                    let v94 : int32 = v83.Length
                                    let v95 : int32 = v93 + v94
                                    let v96 : (string []) = Array.zeroCreate&lt;string&gt; (v95)
                                    let v97 : Mut5 = {l0 = 0} : Mut5
                                    while method23(v95, v97) do
                                        let v99 : int32 = v97.l0
                                        let v100 : bool = v99 &lt; v93
                                        let v104 : string =
                                            if v100 then
                                                let v101 : string = v92.[int v99]
                                                v101
                                            else
                                                let v102 : int32 = v99 - v93
                                                let v103 : string = v83.[int v102]
                                                v103
                                        v96.[int v99] &lt;- v104
                                        let v105 : int32 = v99 + 1
                                        v97.l0 &lt;- v105
                                        ()
                                    struct (0, v96)
                                else
                                    let v106 : (string []) = [|v84|]
                                    let v107 : int32 = v106.Length
                                    let v108 : int32 = v83.Length
                                    let v109 : int32 = v107 + v108
                                    let v110 : (string []) = Array.zeroCreate&lt;string&gt; (v109)
                                    let v111 : Mut5 = {l0 = 0} : Mut5
                                    while method23(v109, v111) do
                                        let v113 : int32 = v111.l0
                                        let v114 : bool = v113 &lt; v107
                                        let v118 : string =
                                            if v114 then
                                                let v115 : string = v106.[int v113]
                                                v115
                                            else
                                                let v116 : int32 = v113 - v107
                                                let v117 : string = v83.[int v116]
                                                v117
                                        v110.[int v113] &lt;- v118
                                        let v119 : int32 = v113 + 1
                                        v111.l0 &lt;- v119
                                        ()
                                    struct (0, v110)
                            else
                                let v122 : int32 = v82 - 1
                                struct (v122, v83)
                let v129 : int32 = v78 + 1
                v76.l0 &lt;- v129
                v76.l1 &lt;- v127
                v76.l2 &lt;- v128
                ()
            let struct (v130 : int32, v131 : (string [])) = v76.l1, v76.l2
            let v132 : string seq = seq { for i = 0 to v131.Length - 1 do yield v131.[i] }
            let v133 : bool = true
            let mutable _v133 : char option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v134 : string = "std::path::MAIN_SEPARATOR"
            let v135 : char = Fable.Core.RustInterop.emitRustExpr () v134
            v135 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v136 : char = null |&gt; unbox&lt;char&gt;
            v136 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v137 : char = null |&gt; unbox&lt;char&gt;
            v137 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v138 : char = null |&gt; unbox&lt;char&gt;
            v138 
            #endif
#if FABLE_COMPILER_PYTHON
            let v139 : char = null |&gt; unbox&lt;char&gt;
            v139 
            #endif
#else
            let v140 : char = System.IO.Path.DirectorySeparatorChar
            v140 
            #endif
            |&gt; fun x -&gt; _v133 &lt;- Some x
            let v141 : char = _v133.Value
            let v142 : (char -&gt; string) = _.ToString()
            let v143 : string = v142 v141
            let v144 : string = method24(v143)
            let v145 : (string -&gt; (string seq -&gt; string)) = String.concat
            let v146 : (string seq -&gt; string) = v145 v144
            v146 v132
        else
            let v148 : string = "std::fs::canonicalize(&amp;*$0)"
            let v149 : Result&lt;std_path_PathBuf, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr v2 v148
            let v150 : string = "$0.unwrap()"
            let v151 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v149 v150
            let v152 : string = "$0.display()"
            let v153 : std_path_Display = Fable.Core.RustInterop.emitRustExpr v151 v152
            let v154 : bool = true
            let mutable _v154 : std_string_String option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v155 : string = "format!(\"{}\", $0)"
            let v156 : std_string_String = Fable.Core.RustInterop.emitRustExpr v153 v155
            v156 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v157 : string = "format!(\"{}\", $0)"
            let v158 : std_string_String = Fable.Core.RustInterop.emitRustExpr v153 v157
            v158 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v159 : string = "format!(\"{}\", $0)"
            let v160 : std_string_String = Fable.Core.RustInterop.emitRustExpr v153 v159
            v160 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v161 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v161 
            #endif
#if FABLE_COMPILER_PYTHON
            let v162 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v162 
            #endif
#else
            let v163 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v163 
            #endif
            |&gt; fun x -&gt; _v154 &lt;- Some x
            let v164 : std_string_String = _v154.Value
            let v165 : string = "fable_library_rust::String_::fromString($0)"
            let v166 : string = Fable.Core.RustInterop.emitRustExpr v164 v165
            v166
    v167 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v168 : string = null |&gt; unbox&lt;string&gt;
    v168 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v169 : string = null |&gt; unbox&lt;string&gt;
    v169 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v170 : string = null |&gt; unbox&lt;string&gt;
    v170 
    #endif
#if FABLE_COMPILER_PYTHON
    let v171 : string = null |&gt; unbox&lt;string&gt;
    v171 
    #endif
#else
    let v172 : string = method25(v0)
    let v173 : (string -&gt; string) = System.IO.Path.GetFullPath
    let v174 : string = v173 v172
    v174 
    #endif
    |&gt; fun x -&gt; _v1 &lt;- Some x
    let v175 : string = _v1.Value
    let v176 : bool = true
    let mutable _v176 : string option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v177 : string = method18(v175)
    let v178 : string = method19()
    let v179 : bool = true
    let mutable _v179 : Result&lt;regex_Regex, regex_Error&gt; option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v180 : string = method20()
    let v181 : string = $"regex::Regex::new(&amp;$0)"
    let v182 : Result&lt;regex_Regex, regex_Error&gt; = Fable.Core.RustInterop.emitRustExpr v180 v181
    v182 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v183 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
    v183 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v184 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
    v184 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v185 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
    v185 
    #endif
#if FABLE_COMPILER_PYTHON
    let v186 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
    v186 
    #endif
#else
    let v187 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
    v187 
    #endif
    |&gt; fun x -&gt; _v179 &lt;- Some x
    let v188 : Result&lt;regex_Regex, regex_Error&gt; = _v179.Value
    let v189 : string = "$0.unwrap()"
    let v190 : regex_Regex = Fable.Core.RustInterop.emitRustExpr v188 v189
    let v191 : string = $"$0.replace_all(&amp;$1, &amp;*$2)"
    let v192 : std_borrow_Cow&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr struct (v190, v177, v178) v191
    let v193 : string = "String::from($0)"
    let v194 : std_string_String = Fable.Core.RustInterop.emitRustExpr v192 v193
    let v195 : string = "fable_library_rust::String_::fromString($0)"
    let v196 : string = Fable.Core.RustInterop.emitRustExpr v194 v195
    v196 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v197 : string = null |&gt; unbox&lt;string&gt;
    v197 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v198 : string = null |&gt; unbox&lt;string&gt;
    v198 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v199 : string = null |&gt; unbox&lt;string&gt;
    v199 
    #endif
#if FABLE_COMPILER_PYTHON
    let v200 : string = null |&gt; unbox&lt;string&gt;
    v200 
    #endif
#else
    let v201 : string = method21()
    let v202 : string = "^\\\\\\\\\\?\\\\"
    let v203 : string = System.Text.RegularExpressions.Regex.Replace (v175, v202, v201)
    v203 
    #endif
    |&gt; fun x -&gt; _v176 &lt;- Some x
    let v204 : string = _v176.Value
    let v205 : string = $"{v204.[0] |&gt; string |&gt; _.ToLower()}{v204.[1..]}"
    let v206 : string = "\\"
    let v207 : string = "/"
    let v208 : string = v205.Replace (v206, v207)
    v208
and method36 (v0 : System.Threading.CancellationToken option, v1 : string, v2 : (struct (string * string) []), v3 : (struct (bool * string * int32) -&gt; Async&lt;unit&gt;) option, v4 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) option, v5 : string option) : string =
    v1
and method37 () : struct (string * string) =
    let v0 : string = ""
    struct (v0, v0)
and closure24 (v0 : char) (v1 : UH0) : UH0 =
    UH0_1(v0, v1)
and closure23 () (v0 : char) : (UH0 -&gt; UH0) =
    closure24(v0)
and method38 () : (char -&gt; (UH0 -&gt; UH0)) =
    closure23()
and method39 (v0 : string, v1 : string, v2 : UH0, v3 : US7) : struct (string * string) =
    match v2 with
    | UH0_1(v4, v5) -&gt; (* Cons *)
        let v6 : bool = '"' = v4
        if v6 then
            let v8 : bool = v1 = ""
            if v8 then
                let v9 : US8 = US8_0
                let v10 : US7 = US7_1(v9)
                method39(v0, v1, v5, v10)
            else
                match v3 with
                | US7_2 -&gt; (* Arguments *)
                    let v38 : string = $"{v0}{v4}"
                    let v39 : US7 = US7_2
                    method39(v38, v1, v5, v39)
                | US7_1(v13) -&gt; (* Path *)
                    match v13 with
                    | US8_0 -&gt; (* Quoted *)
                        let v14 : US8 = US8_1
                        let v15 : US7 = US7_1(v14)
                        method39(v0, v1, v5, v15)
                    | _ -&gt;
                        let v18 : bool = ' ' = v4
                        if v18 then
                            let v19 : US7 = US7_2
                            method39(v0, v1, v5, v19)
                        else
                            let v22 : string = $"{v1}{v4}"
                            method39(v0, v22, v5, v3)
                | US7_0 -&gt; (* Start *)
                    let v29 : bool = ' ' = v4
                    if v29 then
                        let v30 : US7 = US7_2
                        method39(v0, v1, v5, v30)
                    else
                        let v33 : string = $"{v1}{v4}"
                        method39(v0, v33, v5, v3)
        else
            let v50 : bool = ''' = v4
            if v50 then
                let v52 : bool = v1 = ""
                if v52 then
                    let v53 : US8 = US8_0
                    let v54 : US7 = US7_1(v53)
                    method39(v0, v1, v5, v54)
                else
                    match v3 with
                    | US7_2 -&gt; (* Arguments *)
                        let v82 : string = $"{v0}{v4}"
                        let v83 : US7 = US7_2
                        method39(v82, v1, v5, v83)
                    | US7_1(v57) -&gt; (* Path *)
                        match v57 with
                        | US8_0 -&gt; (* Quoted *)
                            let v58 : US8 = US8_1
                            let v59 : US7 = US7_1(v58)
                            method39(v0, v1, v5, v59)
                        | _ -&gt;
                            let v62 : bool = ' ' = v4
                            if v62 then
                                let v63 : US7 = US7_2
                                method39(v0, v1, v5, v63)
                            else
                                let v66 : string = $"{v1}{v4}"
                                method39(v0, v66, v5, v3)
                    | US7_0 -&gt; (* Start *)
                        let v73 : bool = ' ' = v4
                        if v73 then
                            let v74 : US7 = US7_2
                            method39(v0, v1, v5, v74)
                        else
                            let v77 : string = $"{v1}{v4}"
                            method39(v0, v77, v5, v3)
            else
                match v3 with
                | US7_2 -&gt; (* Arguments *)
                    let v126 : string = $"{v0}{v4}"
                    let v127 : US7 = US7_2
                    method39(v126, v1, v5, v127)
                | US7_1(v94) -&gt; (* Path *)
                    match v94 with
                    | US8_0 -&gt; (* Quoted *)
                        let v95 : bool = ' ' = v4
                        if v95 then
                            let v96 : string = $"{v1} "
                            let v97 : US8 = US8_0
                            let v98 : US7 = US7_1(v97)
                            method39(v0, v96, v5, v98)
                        else
                            let v101 : string = $"{v1}{v4}"
                            method39(v0, v101, v5, v3)
                    | _ -&gt;
                        let v106 : bool = ' ' = v4
                        if v106 then
                            let v107 : US7 = US7_2
                            method39(v0, v1, v5, v107)
                        else
                            let v110 : string = $"{v1}{v4}"
                            method39(v0, v110, v5, v3)
                | US7_0 -&gt; (* Start *)
                    let v117 : bool = ' ' = v4
                    if v117 then
                        let v118 : US7 = US7_2
                        method39(v0, v1, v5, v118)
                    else
                        let v121 : string = $"{v1}{v4}"
                        method39(v0, v121, v5, v3)
    | _ -&gt;
        match v3 with
        | US7_2 -&gt; (* Arguments *)
            let v152 : string = "\\"
            let v153 : string = "/"
            let v154 : string = v1.Replace (v152, v153)
            struct (v154, v0)
        | US7_1(v140) -&gt; (* Path *)
            match v140 with
            | US8_0 -&gt; (* Quoted *)
                let v141 : string = "\\"
                let v142 : string = "/"
                let v143 : string = v1.Replace (v141, v142)
                struct (v143, v0)
            | _ -&gt;
                let v144 : string = "\\"
                let v145 : string = "/"
                let v146 : string = v1.Replace (v144, v145)
                struct (v146, v0)
        | US7_0 -&gt; (* Start *)
            let v149 : string = "\\"
            let v150 : string = "/"
            let v151 : string = v1.Replace (v149, v150)
            struct (v151, v0)
and method43 (v0 : UH1, v1 : UH1) : UH1 =
    match v0 with
    | UH1_1(v2, v3) -&gt; (* Cons *)
        let v4 : UH1 = method43(v3, v1)
        UH1_1(v2, v4)
    | UH1_0 -&gt; (* Nil *)
        v1
and method42 (v0 : string, v1 : UH1, v2 : UH0, v3 : US9) : struct (UH1 * string) =
    match v3 with
    | US9_2(v51, v52) -&gt; (* Escaped *)
        match v2 with
        | UH0_1(v53, v54) -&gt; (* Cons *)
            let v55 : bool = '\\' = v53
            if v55 then
                let v56 : US9 = US9_1(v53)
                method41(v0, v1, v54, v3, v56)
            else
                let v59 : bool = '`' = v53
                if v59 then
                    let v60 : US9 = US9_1(v53)
                    method41(v0, v1, v54, v3, v60)
                else
                    let v63 : bool = 0uy = v51
                    if v63 then
                        let v64 : bool = '\\' = v52
                        if v64 then
                            let v65 : bool = '"' = v53
                            if v65 then
                                let v66 : string = $"{v0}{v52}\""
                                let v67 : US9 = US9_2(v51, v52)
                                method41(v66, v1, v54, v3, v67)
                            else
                                let v70 : bool = ' ' = v53
                                if v70 then
                                    let v71 : string = $"{v0} "
                                    method42(v71, v1, v54, v3)
                                else
                                    let v74 : bool = 1uy = v51
                                    if v74 then
                                        let v75 : bool = v3 &lt;&gt; v3
                                        if v75 then
                                            let v76 : string = $"{v0}\{v53}"
                                            method42(v76, v1, v54, v3)
                                        else
                                            let v79 : string = $"{v0}{v53}"
                                            method42(v79, v1, v54, v3)
                                    else
                                        let v84 : string = $"{v0}{v53}"
                                        method42(v84, v1, v54, v3)
                        else
                            let v93 : bool = '`' = v52
                            if v93 then
                                let v94 : bool = '"' = v53
                                if v94 then
                                    let v95 : string = $"{v0}{v52}\""
                                    let v96 : US9 = US9_2(v51, v52)
                                    method41(v95, v1, v54, v3, v96)
                                else
                                    let v99 : bool = ' ' = v53
                                    if v99 then
                                        let v100 : string = $"{v0} "
                                        method42(v100, v1, v54, v3)
                                    else
                                        let v103 : bool = 1uy = v51
                                        if v103 then
                                            let v104 : bool = v3 &lt;&gt; v3
                                            if v104 then
                                                let v105 : string = $"{v0}\{v53}"
                                                method42(v105, v1, v54, v3)
                                            else
                                                let v108 : string = $"{v0}{v53}"
                                                method42(v108, v1, v54, v3)
                                        else
                                            let v113 : string = $"{v0}{v53}"
                                            method42(v113, v1, v54, v3)
                            else
                                let v122 : bool = '"' = v53
                                if v122 then
                                    let v123 : string = $"{v0}{v52}\""
                                    let v124 : US9 = US9_2(v51, v52)
                                    method41(v123, v1, v54, v3, v124)
                                else
                                    let v127 : bool = ' ' = v53
                                    if v127 then
                                        let v128 : string = $"{v0} "
                                        method42(v128, v1, v54, v3)
                                    else
                                        let v131 : bool = 1uy = v51
                                        if v131 then
                                            let v132 : bool = v3 &lt;&gt; v3
                                            if v132 then
                                                let v133 : string = $"{v0}\{v53}"
                                                method42(v133, v1, v54, v3)
                                            else
                                                let v136 : string = $"{v0}{v53}"
                                                method42(v136, v1, v54, v3)
                                        else
                                            let v141 : string = $"{v0}{v53}"
                                            method42(v141, v1, v54, v3)
                    else
                        let v154 : bool = '"' = v53
                        if v154 then
                            let v155 : string = $"{v0}{v52}\""
                            let v156 : US9 = US9_2(v51, v52)
                            method41(v155, v1, v54, v3, v156)
                        else
                            let v159 : bool = ' ' = v53
                            if v159 then
                                let v160 : string = $"{v0} "
                                method42(v160, v1, v54, v3)
                            else
                                let v163 : bool = 1uy = v51
                                if v163 then
                                    let v164 : bool = v3 &lt;&gt; v3
                                    if v164 then
                                        let v165 : string = $"{v0}\{v53}"
                                        method42(v165, v1, v54, v3)
                                    else
                                        let v168 : string = $"{v0}{v53}"
                                        method42(v168, v1, v54, v3)
                                else
                                    let v173 : string = $"{v0}{v53}"
                                    method42(v173, v1, v54, v3)
        | _ -&gt;
            let v188 : bool = 0uy = v51
            if v188 then
                let v189 : bool = '\\' = v52
                if v189 then
                    let v190 : bool = 1uy = v51
                    if v190 then
                        let v192 : bool = v0 = ""
                        let v196 : UH1 =
                            if v192 then
                                v1
                            else
                                let v193 : UH1 = UH1_0
                                let v194 : UH1 = UH1_1(v0, v193)
                                method43(v1, v194)
                        struct (v196, v0)
                    else
                        let v198 : bool = v0 = ""
                        let v202 : UH1 =
                            if v198 then
                                v1
                            else
                                let v199 : UH1 = UH1_0
                                let v200 : UH1 = UH1_1(v0, v199)
                                method43(v1, v200)
                        struct (v202, v0)
                else
                    let v205 : bool = '`' = v52
                    if v205 then
                        let v206 : bool = 1uy = v51
                        if v206 then
                            let v208 : bool = v0 = ""
                            let v212 : UH1 =
                                if v208 then
                                    v1
                                else
                                    let v209 : UH1 = UH1_0
                                    let v210 : UH1 = UH1_1(v0, v209)
                                    method43(v1, v210)
                            struct (v212, v0)
                        else
                            let v214 : bool = v0 = ""
                            let v218 : UH1 =
                                if v214 then
                                    v1
                                else
                                    let v215 : UH1 = UH1_0
                                    let v216 : UH1 = UH1_1(v0, v215)
                                    method43(v1, v216)
                            struct (v218, v0)
                    else
                        let v221 : bool = 1uy = v51
                        if v221 then
                            let v223 : bool = v0 = ""
                            let v227 : UH1 =
                                if v223 then
                                    v1
                                else
                                    let v224 : UH1 = UH1_0
                                    let v225 : UH1 = UH1_1(v0, v224)
                                    method43(v1, v225)
                            struct (v227, v0)
                        else
                            let v229 : bool = v0 = ""
                            let v233 : UH1 =
                                if v229 then
                                    v1
                                else
                                    let v230 : UH1 = UH1_0
                                    let v231 : UH1 = UH1_1(v0, v230)
                                    method43(v1, v231)
                            struct (v233, v0)
            else
                let v240 : bool = 1uy = v51
                if v240 then
                    let v242 : bool = v0 = ""
                    let v246 : UH1 =
                        if v242 then
                            v1
                        else
                            let v243 : UH1 = UH1_0
                            let v244 : UH1 = UH1_1(v0, v243)
                            method43(v1, v244)
                    struct (v246, v0)
                else
                    let v248 : bool = v0 = ""
                    let v252 : UH1 =
                        if v248 then
                            v1
                        else
                            let v249 : UH1 = UH1_0
                            let v250 : UH1 = UH1_1(v0, v249)
                            method43(v1, v250)
                    struct (v252, v0)
    | US9_1(v259) -&gt; (* Quoted *)
        let v260 : bool = '"' = v259
        if v260 then
            match v2 with
            | UH0_1(v261, v262) -&gt; (* Cons *)
                let v263 : bool = '"' = v261
                if v263 then
                    let v264 : US9 = US9_0
                    method41(v0, v1, v262, v3, v264)
                else
                    let v267 : bool = '\\' = v259
                    if v267 then
                        let v268 : bool = '\\' = v261
                        if v268 then
                            let v269 : uint8 = 0uy
                            let v270 : US9 = US9_2(v269, v261)
                            method41(v0, v1, v262, v3, v270)
                        else
                            let v273 : bool = '`' = v261
                            if v273 then
                                let v274 : uint8 = 0uy
                                let v275 : US9 = US9_2(v274, v261)
                                method41(v0, v1, v262, v3, v275)
                            else
                                let v278 : bool = ' ' = v261
                                if v278 then
                                    let v279 : string = $"{v0} "
                                    method42(v279, v1, v262, v3)
                                else
                                    let v282 : string = $"{v0}{v261}"
                                    method42(v282, v1, v262, v3)
                    else
                        let v291 : bool = '`' = v259
                        if v291 then
                            let v292 : bool = '\\' = v261
                            if v292 then
                                let v293 : uint8 = 0uy
                                let v294 : US9 = US9_2(v293, v261)
                                method41(v0, v1, v262, v3, v294)
                            else
                                let v297 : bool = '`' = v261
                                if v297 then
                                    let v298 : uint8 = 0uy
                                    let v299 : US9 = US9_2(v298, v261)
                                    method41(v0, v1, v262, v3, v299)
                                else
                                    let v302 : bool = ' ' = v261
                                    if v302 then
                                        let v303 : string = $"{v0} "
                                        method42(v303, v1, v262, v3)
                                    else
                                        let v306 : string = $"{v0}{v261}"
                                        method42(v306, v1, v262, v3)
                        else
                            let v315 : bool = '\\' = v261
                            if v315 then
                                let v316 : uint8 = 0uy
                                let v317 : US9 = US9_2(v316, v261)
                                method41(v0, v1, v262, v3, v317)
                            else
                                let v320 : bool = '`' = v261
                                if v320 then
                                    let v321 : uint8 = 0uy
                                    let v322 : US9 = US9_2(v321, v261)
                                    method41(v0, v1, v262, v3, v322)
                                else
                                    let v325 : bool = ' ' = v261
                                    if v325 then
                                        let v326 : string = $"{v0} "
                                        method42(v326, v1, v262, v3)
                                    else
                                        let v329 : string = $"{v0}{v261}"
                                        method42(v329, v1, v262, v3)
            | _ -&gt;
                let v344 : bool = '\\' = v259
                if v344 then
                    let v346 : bool = v0 = ""
                    let v350 : UH1 =
                        if v346 then
                            v1
                        else
                            let v347 : UH1 = UH1_0
                            let v348 : UH1 = UH1_1(v0, v347)
                            method43(v1, v348)
                    struct (v350, v0)
                else
                    let v351 : bool = '`' = v259
                    if v351 then
                        let v353 : bool = v0 = ""
                        let v357 : UH1 =
                            if v353 then
                                v1
                            else
                                let v354 : UH1 = UH1_0
                                let v355 : UH1 = UH1_1(v0, v354)
                                method43(v1, v355)
                        struct (v357, v0)
                    else
                        let v359 : bool = v0 = ""
                        let v363 : UH1 =
                            if v359 then
                                v1
                            else
                                let v360 : UH1 = UH1_0
                                let v361 : UH1 = UH1_1(v0, v360)
                                method43(v1, v361)
                        struct (v363, v0)
        else
            let v370 : bool = '\\' = v259
            if v370 then
                match v2 with
                | UH0_1(v371, v372) -&gt; (* Cons *)
                    let v373 : bool = '"' = v371
                    if v373 then
                        let v374 : US9 = US9_2(0uy, '\\')
                        let v375 : bool = v3 &lt;&gt; v374
                        let v378 : bool =
                            if v375 then
                                let v376 : US9 = US9_2(0uy, '`')
                                let v377 : bool = v3 &lt;&gt; v376
                                v377
                            else
                                false
                        if v378 then
                            let v379 : string = $"{v0}{v259}\""
                            let v380 : char = '"'
                            let v381 : US9 = US9_1(v380)
                            method41(v379, v1, v372, v3, v381)
                        else
                            let v384 : string = $"{v0}{v259}\""
                            let v385 : char = '"'
                            let v386 : US9 = US9_1(v385)
                            method41(v384, v1, v372, v3, v386)
                    else
                        let v391 : bool = '\\' = v371
                        if v391 then
                            let v392 : uint8 = 0uy
                            let v393 : US9 = US9_2(v392, v371)
                            method41(v0, v1, v372, v3, v393)
                        else
                            let v396 : bool = '`' = v371
                            if v396 then
                                let v397 : uint8 = 0uy
                                let v398 : US9 = US9_2(v397, v371)
                                method41(v0, v1, v372, v3, v398)
                            else
                                let v401 : bool = ' ' = v371
                                if v401 then
                                    let v402 : string = $"{v0} "
                                    method42(v402, v1, v372, v3)
                                else
                                    let v405 : string = $"{v0}{v371}"
                                    method42(v405, v1, v372, v3)
                | _ -&gt;
                    let v417 : bool = v0 = ""
                    let v421 : UH1 =
                        if v417 then
                            v1
                        else
                            let v418 : UH1 = UH1_0
                            let v419 : UH1 = UH1_1(v0, v418)
                            method43(v1, v419)
                    struct (v421, v0)
            else
                let v424 : bool = '`' = v259
                if v424 then
                    match v2 with
                    | UH0_1(v425, v426) -&gt; (* Cons *)
                        let v427 : bool = '"' = v425
                        if v427 then
                            let v428 : US9 = US9_2(0uy, '\\')
                            let v429 : bool = v3 &lt;&gt; v428
                            let v432 : bool =
                                if v429 then
                                    let v430 : US9 = US9_2(0uy, '`')
                                    let v431 : bool = v3 &lt;&gt; v430
                                    v431
                                else
                                    false
                            if v432 then
                                let v433 : string = $"{v0}{v259}\""
                                let v434 : char = '"'
                                let v435 : US9 = US9_1(v434)
                                method41(v433, v1, v426, v3, v435)
                            else
                                let v438 : string = $"{v0}{v259}\""
                                let v439 : char = '"'
                                let v440 : US9 = US9_1(v439)
                                method41(v438, v1, v426, v3, v440)
                        else
                            let v445 : bool = '\\' = v425
                            if v445 then
                                let v446 : uint8 = 0uy
                                let v447 : US9 = US9_2(v446, v425)
                                method41(v0, v1, v426, v3, v447)
                            else
                                let v450 : bool = '`' = v425
                                if v450 then
                                    let v451 : uint8 = 0uy
                                    let v452 : US9 = US9_2(v451, v425)
                                    method41(v0, v1, v426, v3, v452)
                                else
                                    let v455 : bool = ' ' = v425
                                    if v455 then
                                        let v456 : string = $"{v0} "
                                        method42(v456, v1, v426, v3)
                                    else
                                        let v459 : string = $"{v0}{v425}"
                                        method42(v459, v1, v426, v3)
                    | _ -&gt;
                        let v471 : bool = v0 = ""
                        let v475 : UH1 =
                            if v471 then
                                v1
                            else
                                let v472 : UH1 = UH1_0
                                let v473 : UH1 = UH1_1(v0, v472)
                                method43(v1, v473)
                        struct (v475, v0)
                else
                    match v2 with
                    | UH0_1(v478, v479) -&gt; (* Cons *)
                        let v480 : bool = '\\' = v478
                        if v480 then
                            let v481 : uint8 = 0uy
                            let v482 : US9 = US9_2(v481, v478)
                            method41(v0, v1, v479, v3, v482)
                        else
                            let v485 : bool = '`' = v478
                            if v485 then
                                let v486 : uint8 = 0uy
                                let v487 : US9 = US9_2(v486, v478)
                                method41(v0, v1, v479, v3, v487)
                            else
                                let v490 : bool = '"' = v478
                                if v490 then
                                    let v491 : UH1 = UH1_0
                                    let v492 : UH1 = UH1_1(v0, v491)
                                    let v493 : UH1 = method43(v1, v492)
                                    let v494 : string = ""
                                    let v495 : US9 = US9_0
                                    method41(v494, v493, v479, v3, v495)
                                else
                                    let v498 : bool = ' ' = v478
                                    if v498 then
                                        let v499 : string = $"{v0} "
                                        method42(v499, v1, v479, v3)
                                    else
                                        let v502 : string = $"{v0}{v478}"
                                        method42(v502, v1, v479, v3)
                    | _ -&gt;
                        let v514 : bool = v0 = ""
                        let v518 : UH1 =
                            if v514 then
                                v1
                            else
                                let v515 : UH1 = UH1_0
                                let v516 : UH1 = UH1_1(v0, v515)
                                method43(v1, v516)
                        struct (v518, v0)
    | US9_0 -&gt; (* Start *)
        match v2 with
        | UH0_1(v4, v5) -&gt; (* Cons *)
            let v6 : bool = '"' = v4
            if v6 then
                let v7 : string = ""
                let v8 : char = '"'
                let v9 : US9 = US9_1(v8)
                method41(v7, v1, v5, v3, v9)
            else
                let v12 : bool = '\\' = v4
                if v12 then
                    let v13 : uint8 = 0uy
                    let v14 : US9 = US9_2(v13, v4)
                    method41(v0, v1, v5, v3, v14)
                else
                    let v17 : bool = '`' = v4
                    if v17 then
                        let v18 : uint8 = 0uy
                        let v19 : US9 = US9_2(v18, v4)
                        method41(v0, v1, v5, v3, v19)
                    else
                        let v22 : bool = ' ' = v4
                        if v22 then
                            let v24 : bool = v0 = ""
                            let v28 : UH1 =
                                if v24 then
                                    v1
                                else
                                    let v25 : UH1 = UH1_0
                                    let v26 : UH1 = UH1_1(v0, v25)
                                    method43(v1, v26)
                            let v29 : string = ""
                            method42(v29, v28, v5, v3)
                        else
                            let v32 : string = $"{v0}{v4}"
                            method42(v32, v1, v5, v3)
        | _ -&gt;
            let v44 : bool = v0 = ""
            let v48 : UH1 =
                if v44 then
                    v1
                else
                    let v45 : UH1 = UH1_0
                    let v46 : UH1 = UH1_1(v0, v45)
                    method43(v1, v46)
            struct (v48, v0)
and method41 (v0 : string, v1 : UH1, v2 : UH0, v3 : US9, v4 : US9) : struct (UH1 * string) =
    match v4 with
    | US9_2(v52, v53) -&gt; (* Escaped *)
        match v2 with
        | UH0_1(v54, v55) -&gt; (* Cons *)
            let v56 : bool = '\\' = v54
            if v56 then
                let v57 : US9 = US9_1(v54)
                method41(v0, v1, v55, v4, v57)
            else
                let v60 : bool = '`' = v54
                if v60 then
                    let v61 : US9 = US9_1(v54)
                    method41(v0, v1, v55, v4, v61)
                else
                    match v3 with
                    | US9_0 -&gt; (* Start *)
                        let v64 : bool = '"' = v54
                        if v64 then
                            method42(v0, v1, v55, v4)
                        else
                            let v67 : bool = 0uy = v52
                            if v67 then
                                let v68 : bool = '\\' = v53
                                if v68 then
                                    let v69 : bool = ' ' = v54
                                    if v69 then
                                        let v70 : string = $"{v0} "
                                        method42(v70, v1, v55, v4)
                                    else
                                        let v73 : bool = 1uy = v52
                                        if v73 then
                                            let v74 : bool = v3 &lt;&gt; v4
                                            if v74 then
                                                let v75 : string = $"{v0}\{v54}"
                                                method41(v75, v1, v55, v4, v3)
                                            else
                                                let v78 : string = $"{v0}{v54}"
                                                method42(v78, v1, v55, v4)
                                        else
                                            let v83 : string = $"{v0}{v54}"
                                            method42(v83, v1, v55, v4)
                                else
                                    let v90 : bool = '`' = v53
                                    if v90 then
                                        let v91 : bool = ' ' = v54
                                        if v91 then
                                            let v92 : string = $"{v0} "
                                            method42(v92, v1, v55, v4)
                                        else
                                            let v95 : bool = 1uy = v52
                                            if v95 then
                                                let v96 : bool = v3 &lt;&gt; v4
                                                if v96 then
                                                    let v97 : string = $"{v0}\{v54}"
                                                    method41(v97, v1, v55, v4, v3)
                                                else
                                                    let v100 : string = $"{v0}{v54}"
                                                    method42(v100, v1, v55, v4)
                                            else
                                                let v105 : string = $"{v0}{v54}"
                                                method42(v105, v1, v55, v4)
                                    else
                                        let v112 : bool = ' ' = v54
                                        if v112 then
                                            let v113 : string = $"{v0} "
                                            method42(v113, v1, v55, v4)
                                        else
                                            let v116 : bool = 1uy = v52
                                            if v116 then
                                                let v117 : bool = v3 &lt;&gt; v4
                                                if v117 then
                                                    let v118 : string = $"{v0}\{v54}"
                                                    method41(v118, v1, v55, v4, v3)
                                                else
                                                    let v121 : string = $"{v0}{v54}"
                                                    method42(v121, v1, v55, v4)
                                            else
                                                let v126 : string = $"{v0}{v54}"
                                                method42(v126, v1, v55, v4)
                            else
                                let v137 : bool = ' ' = v54
                                if v137 then
                                    let v138 : string = $"{v0} "
                                    method42(v138, v1, v55, v4)
                                else
                                    let v141 : bool = 1uy = v52
                                    if v141 then
                                        let v142 : bool = v3 &lt;&gt; v4
                                        if v142 then
                                            let v143 : string = $"{v0}\{v54}"
                                            method41(v143, v1, v55, v4, v3)
                                        else
                                            let v146 : string = $"{v0}{v54}"
                                            method42(v146, v1, v55, v4)
                                    else
                                        let v151 : string = $"{v0}{v54}"
                                        method42(v151, v1, v55, v4)
                    | _ -&gt;
                        let v162 : bool = 0uy = v52
                        if v162 then
                            let v163 : bool = '\\' = v53
                            if v163 then
                                match v3 with
                                | US9_1(v164) -&gt; (* Quoted *)
                                    let v165 : bool = '"' = v164
                                    if v165 then
                                        let v166 : string = $"{v0}{v53}{v54}"
                                        let v167 : char = '"'
                                        let v168 : US9 = US9_1(v167)
                                        method41(v166, v1, v55, v4, v168)
                                    else
                                        let v171 : bool = '"' = v54
                                        if v171 then
                                            let v172 : string = $"{v0}{v53}\""
                                            let v173 : US9 = US9_2(v52, v53)
                                            method41(v172, v1, v55, v4, v173)
                                        else
                                            let v176 : bool = ' ' = v54
                                            if v176 then
                                                let v177 : string = $"{v0} "
                                                method42(v177, v1, v55, v4)
                                            else
                                                let v180 : bool = 1uy = v52
                                                if v180 then
                                                    let v181 : bool = v3 &lt;&gt; v4
                                                    if v181 then
                                                        let v182 : string = $"{v0}\{v54}"
                                                        method41(v182, v1, v55, v4, v3)
                                                    else
                                                        let v185 : string = $"{v0}{v54}"
                                                        method42(v185, v1, v55, v4)
                                                else
                                                    let v190 : string = $"{v0}{v54}"
                                                    method42(v190, v1, v55, v4)
                                | _ -&gt;
                                    let v201 : bool = '"' = v54
                                    if v201 then
                                        let v202 : string = $"{v0}{v53}\""
                                        let v203 : US9 = US9_2(v52, v53)
                                        method41(v202, v1, v55, v4, v203)
                                    else
                                        let v206 : bool = ' ' = v54
                                        if v206 then
                                            let v207 : string = $"{v0} "
                                            method42(v207, v1, v55, v4)
                                        else
                                            let v210 : bool = 1uy = v52
                                            if v210 then
                                                let v211 : bool = v3 &lt;&gt; v4
                                                if v211 then
                                                    let v212 : string = $"{v0}\{v54}"
                                                    method41(v212, v1, v55, v4, v3)
                                                else
                                                    let v215 : string = $"{v0}{v54}"
                                                    method42(v215, v1, v55, v4)
                                            else
                                                let v220 : string = $"{v0}{v54}"
                                                method42(v220, v1, v55, v4)
                            else
                                let v231 : bool = '`' = v53
                                if v231 then
                                    match v3 with
                                    | US9_1(v232) -&gt; (* Quoted *)
                                        let v233 : bool = '"' = v232
                                        if v233 then
                                            let v234 : string = $"{v0}{v53}{v54}"
                                            let v235 : char = '"'
                                            let v236 : US9 = US9_1(v235)
                                            method41(v234, v1, v55, v4, v236)
                                        else
                                            let v239 : bool = '"' = v54
                                            if v239 then
                                                let v240 : string = $"{v0}{v53}\""
                                                let v241 : US9 = US9_2(v52, v53)
                                                method41(v240, v1, v55, v4, v241)
                                            else
                                                let v244 : bool = ' ' = v54
                                                if v244 then
                                                    let v245 : string = $"{v0} "
                                                    method42(v245, v1, v55, v4)
                                                else
                                                    let v248 : bool = 1uy = v52
                                                    if v248 then
                                                        let v249 : bool = v3 &lt;&gt; v4
                                                        if v249 then
                                                            let v250 : string = $"{v0}\{v54}"
                                                            method41(v250, v1, v55, v4, v3)
                                                        else
                                                            let v253 : string = $"{v0}{v54}"
                                                            method42(v253, v1, v55, v4)
                                                    else
                                                        let v258 : string = $"{v0}{v54}"
                                                        method42(v258, v1, v55, v4)
                                    | _ -&gt;
                                        let v269 : bool = '"' = v54
                                        if v269 then
                                            let v270 : string = $"{v0}{v53}\""
                                            let v271 : US9 = US9_2(v52, v53)
                                            method41(v270, v1, v55, v4, v271)
                                        else
                                            let v274 : bool = ' ' = v54
                                            if v274 then
                                                let v275 : string = $"{v0} "
                                                method42(v275, v1, v55, v4)
                                            else
                                                let v278 : bool = 1uy = v52
                                                if v278 then
                                                    let v279 : bool = v3 &lt;&gt; v4
                                                    if v279 then
                                                        let v280 : string = $"{v0}\{v54}"
                                                        method41(v280, v1, v55, v4, v3)
                                                    else
                                                        let v283 : string = $"{v0}{v54}"
                                                        method42(v283, v1, v55, v4)
                                                else
                                                    let v288 : string = $"{v0}{v54}"
                                                    method42(v288, v1, v55, v4)
                                else
                                    let v299 : bool = '"' = v54
                                    if v299 then
                                        let v300 : string = $"{v0}{v53}\""
                                        let v301 : US9 = US9_2(v52, v53)
                                        method41(v300, v1, v55, v4, v301)
                                    else
                                        let v304 : bool = ' ' = v54
                                        if v304 then
                                            let v305 : string = $"{v0} "
                                            method42(v305, v1, v55, v4)
                                        else
                                            let v308 : bool = 1uy = v52
                                            if v308 then
                                                let v309 : bool = v3 &lt;&gt; v4
                                                if v309 then
                                                    let v310 : string = $"{v0}\{v54}"
                                                    method41(v310, v1, v55, v4, v3)
                                                else
                                                    let v313 : string = $"{v0}{v54}"
                                                    method42(v313, v1, v55, v4)
                                            else
                                                let v318 : string = $"{v0}{v54}"
                                                method42(v318, v1, v55, v4)
                        else
                            let v331 : bool = '"' = v54
                            if v331 then
                                let v332 : string = $"{v0}{v53}\""
                                let v333 : US9 = US9_2(v52, v53)
                                method41(v332, v1, v55, v4, v333)
                            else
                                let v336 : bool = ' ' = v54
                                if v336 then
                                    let v337 : string = $"{v0} "
                                    method42(v337, v1, v55, v4)
                                else
                                    let v340 : bool = 1uy = v52
                                    if v340 then
                                        let v341 : bool = v3 &lt;&gt; v4
                                        if v341 then
                                            let v342 : string = $"{v0}\{v54}"
                                            method41(v342, v1, v55, v4, v3)
                                        else
                                            let v345 : string = $"{v0}{v54}"
                                            method42(v345, v1, v55, v4)
                                    else
                                        let v350 : string = $"{v0}{v54}"
                                        method42(v350, v1, v55, v4)
        | _ -&gt;
            match v3 with
            | US9_0 -&gt; (* Start *)
                let v367 : bool = 0uy = v52
                if v367 then
                    let v368 : bool = '\\' = v53
                    if v368 then
                        let v369 : bool = 1uy = v52
                        if v369 then
                            let v371 : bool = v0 = ""
                            let v375 : UH1 =
                                if v371 then
                                    v1
                                else
                                    let v372 : UH1 = UH1_0
                                    let v373 : UH1 = UH1_1(v0, v372)
                                    method43(v1, v373)
                            struct (v375, v0)
                        else
                            let v377 : bool = v0 = ""
                            let v381 : UH1 =
                                if v377 then
                                    v1
                                else
                                    let v378 : UH1 = UH1_0
                                    let v379 : UH1 = UH1_1(v0, v378)
                                    method43(v1, v379)
                            struct (v381, v0)
                    else
                        let v384 : bool = '`' = v53
                        if v384 then
                            let v385 : bool = 1uy = v52
                            if v385 then
                                let v387 : bool = v0 = ""
                                let v391 : UH1 =
                                    if v387 then
                                        v1
                                    else
                                        let v388 : UH1 = UH1_0
                                        let v389 : UH1 = UH1_1(v0, v388)
                                        method43(v1, v389)
                                struct (v391, v0)
                            else
                                let v393 : bool = v0 = ""
                                let v397 : UH1 =
                                    if v393 then
                                        v1
                                    else
                                        let v394 : UH1 = UH1_0
                                        let v395 : UH1 = UH1_1(v0, v394)
                                        method43(v1, v395)
                                struct (v397, v0)
                        else
                            let v400 : bool = 1uy = v52
                            if v400 then
                                let v402 : bool = v0 = ""
                                let v406 : UH1 =
                                    if v402 then
                                        v1
                                    else
                                        let v403 : UH1 = UH1_0
                                        let v404 : UH1 = UH1_1(v0, v403)
                                        method43(v1, v404)
                                struct (v406, v0)
                            else
                                let v408 : bool = v0 = ""
                                let v412 : UH1 =
                                    if v408 then
                                        v1
                                    else
                                        let v409 : UH1 = UH1_0
                                        let v410 : UH1 = UH1_1(v0, v409)
                                        method43(v1, v410)
                                struct (v412, v0)
                else
                    let v419 : bool = 1uy = v52
                    if v419 then
                        let v421 : bool = v0 = ""
                        let v425 : UH1 =
                            if v421 then
                                v1
                            else
                                let v422 : UH1 = UH1_0
                                let v423 : UH1 = UH1_1(v0, v422)
                                method43(v1, v423)
                        struct (v425, v0)
                    else
                        let v427 : bool = v0 = ""
                        let v431 : UH1 =
                            if v427 then
                                v1
                            else
                                let v428 : UH1 = UH1_0
                                let v429 : UH1 = UH1_1(v0, v428)
                                method43(v1, v429)
                        struct (v431, v0)
            | _ -&gt;
                let v436 : bool = 0uy = v52
                if v436 then
                    let v437 : bool = '\\' = v53
                    if v437 then
                        match v3 with
                        | US9_1(v438) -&gt; (* Quoted *)
                            let v439 : bool = '"' = v438
                            if v439 then
                                let v440 : bool = 1uy = v52
                                if v440 then
                                    let v442 : bool = v0 = ""
                                    let v446 : UH1 =
                                        if v442 then
                                            v1
                                        else
                                            let v443 : UH1 = UH1_0
                                            let v444 : UH1 = UH1_1(v0, v443)
                                            method43(v1, v444)
                                    struct (v446, v0)
                                else
                                    let v448 : bool = v0 = ""
                                    let v452 : UH1 =
                                        if v448 then
                                            v1
                                        else
                                            let v449 : UH1 = UH1_0
                                            let v450 : UH1 = UH1_1(v0, v449)
                                            method43(v1, v450)
                                    struct (v452, v0)
                            else
                                let v455 : bool = 1uy = v52
                                if v455 then
                                    let v457 : bool = v0 = ""
                                    let v461 : UH1 =
                                        if v457 then
                                            v1
                                        else
                                            let v458 : UH1 = UH1_0
                                            let v459 : UH1 = UH1_1(v0, v458)
                                            method43(v1, v459)
                                    struct (v461, v0)
                                else
                                    let v463 : bool = v0 = ""
                                    let v467 : UH1 =
                                        if v463 then
                                            v1
                                        else
                                            let v464 : UH1 = UH1_0
                                            let v465 : UH1 = UH1_1(v0, v464)
                                            method43(v1, v465)
                                    struct (v467, v0)
                        | _ -&gt;
                            let v472 : bool = 1uy = v52
                            if v472 then
                                let v474 : bool = v0 = ""
                                let v478 : UH1 =
                                    if v474 then
                                        v1
                                    else
                                        let v475 : UH1 = UH1_0
                                        let v476 : UH1 = UH1_1(v0, v475)
                                        method43(v1, v476)
                                struct (v478, v0)
                            else
                                let v480 : bool = v0 = ""
                                let v484 : UH1 =
                                    if v480 then
                                        v1
                                    else
                                        let v481 : UH1 = UH1_0
                                        let v482 : UH1 = UH1_1(v0, v481)
                                        method43(v1, v482)
                                struct (v484, v0)
                    else
                        let v489 : bool = '`' = v53
                        if v489 then
                            match v3 with
                            | US9_1(v490) -&gt; (* Quoted *)
                                let v491 : bool = '"' = v490
                                if v491 then
                                    let v492 : bool = 1uy = v52
                                    if v492 then
                                        let v494 : bool = v0 = ""
                                        let v498 : UH1 =
                                            if v494 then
                                                v1
                                            else
                                                let v495 : UH1 = UH1_0
                                                let v496 : UH1 = UH1_1(v0, v495)
                                                method43(v1, v496)
                                        struct (v498, v0)
                                    else
                                        let v500 : bool = v0 = ""
                                        let v504 : UH1 =
                                            if v500 then
                                                v1
                                            else
                                                let v501 : UH1 = UH1_0
                                                let v502 : UH1 = UH1_1(v0, v501)
                                                method43(v1, v502)
                                        struct (v504, v0)
                                else
                                    let v507 : bool = 1uy = v52
                                    if v507 then
                                        let v509 : bool = v0 = ""
                                        let v513 : UH1 =
                                            if v509 then
                                                v1
                                            else
                                                let v510 : UH1 = UH1_0
                                                let v511 : UH1 = UH1_1(v0, v510)
                                                method43(v1, v511)
                                        struct (v513, v0)
                                    else
                                        let v515 : bool = v0 = ""
                                        let v519 : UH1 =
                                            if v515 then
                                                v1
                                            else
                                                let v516 : UH1 = UH1_0
                                                let v517 : UH1 = UH1_1(v0, v516)
                                                method43(v1, v517)
                                        struct (v519, v0)
                            | _ -&gt;
                                let v524 : bool = 1uy = v52
                                if v524 then
                                    let v526 : bool = v0 = ""
                                    let v530 : UH1 =
                                        if v526 then
                                            v1
                                        else
                                            let v527 : UH1 = UH1_0
                                            let v528 : UH1 = UH1_1(v0, v527)
                                            method43(v1, v528)
                                    struct (v530, v0)
                                else
                                    let v532 : bool = v0 = ""
                                    let v536 : UH1 =
                                        if v532 then
                                            v1
                                        else
                                            let v533 : UH1 = UH1_0
                                            let v534 : UH1 = UH1_1(v0, v533)
                                            method43(v1, v534)
                                    struct (v536, v0)
                        else
                            let v541 : bool = 1uy = v52
                            if v541 then
                                let v543 : bool = v0 = ""
                                let v547 : UH1 =
                                    if v543 then
                                        v1
                                    else
                                        let v544 : UH1 = UH1_0
                                        let v545 : UH1 = UH1_1(v0, v544)
                                        method43(v1, v545)
                                struct (v547, v0)
                            else
                                let v549 : bool = v0 = ""
                                let v553 : UH1 =
                                    if v549 then
                                        v1
                                    else
                                        let v550 : UH1 = UH1_0
                                        let v551 : UH1 = UH1_1(v0, v550)
                                        method43(v1, v551)
                                struct (v553, v0)
                else
                    let v560 : bool = 1uy = v52
                    if v560 then
                        let v562 : bool = v0 = ""
                        let v566 : UH1 =
                            if v562 then
                                v1
                            else
                                let v563 : UH1 = UH1_0
                                let v564 : UH1 = UH1_1(v0, v563)
                                method43(v1, v564)
                        struct (v566, v0)
                    else
                        let v568 : bool = v0 = ""
                        let v572 : UH1 =
                            if v568 then
                                v1
                            else
                                let v569 : UH1 = UH1_0
                                let v570 : UH1 = UH1_1(v0, v569)
                                method43(v1, v570)
                        struct (v572, v0)
    | US9_1(v581) -&gt; (* Quoted *)
        let v582 : bool = '"' = v581
        if v582 then
            match v3 with
            | US9_1(v583) -&gt; (* Quoted *)
                match v2 with
                | UH0_1(v584, v585) -&gt; (* Cons *)
                    let v586 : bool = '"' = v584
                    if v586 then
                        let v587 : US9 = US9_0
                        method41(v0, v1, v585, v4, v587)
                    else
                        let v590 : bool = '\\' = v581
                        if v590 then
                            let v591 : bool = '\\' = v584
                            if v591 then
                                let v592 : uint8 = 0uy
                                let v593 : US9 = US9_2(v592, v584)
                                method41(v0, v1, v585, v4, v593)
                            else
                                let v596 : bool = '`' = v584
                                if v596 then
                                    let v597 : uint8 = 0uy
                                    let v598 : US9 = US9_2(v597, v584)
                                    method41(v0, v1, v585, v4, v598)
                                else
                                    let v601 : bool = ' ' = v584
                                    if v601 then
                                        let v602 : string = $"{v0} "
                                        method42(v602, v1, v585, v4)
                                    else
                                        let v605 : string = $"{v0}{v584}"
                                        method42(v605, v1, v585, v4)
                        else
                            let v614 : bool = '`' = v581
                            if v614 then
                                let v615 : bool = '\\' = v584
                                if v615 then
                                    let v616 : uint8 = 0uy
                                    let v617 : US9 = US9_2(v616, v584)
                                    method41(v0, v1, v585, v4, v617)
                                else
                                    let v620 : bool = '`' = v584
                                    if v620 then
                                        let v621 : uint8 = 0uy
                                        let v622 : US9 = US9_2(v621, v584)
                                        method41(v0, v1, v585, v4, v622)
                                    else
                                        let v625 : bool = ' ' = v584
                                        if v625 then
                                            let v626 : string = $"{v0} "
                                            method42(v626, v1, v585, v4)
                                        else
                                            let v629 : string = $"{v0}{v584}"
                                            method42(v629, v1, v585, v4)
                            else
                                let v638 : bool = '\\' = v584
                                if v638 then
                                    let v639 : uint8 = 0uy
                                    let v640 : US9 = US9_2(v639, v584)
                                    method41(v0, v1, v585, v4, v640)
                                else
                                    let v643 : bool = '`' = v584
                                    if v643 then
                                        let v644 : uint8 = 0uy
                                        let v645 : US9 = US9_2(v644, v584)
                                        method41(v0, v1, v585, v4, v645)
                                    else
                                        let v648 : bool = ' ' = v584
                                        if v648 then
                                            let v649 : string = $"{v0} "
                                            method42(v649, v1, v585, v4)
                                        else
                                            let v652 : string = $"{v0}{v584}"
                                            method42(v652, v1, v585, v4)
                | _ -&gt;
                    let v667 : bool = '\\' = v581
                    if v667 then
                        let v669 : bool = v0 = ""
                        let v673 : UH1 =
                            if v669 then
                                v1
                            else
                                let v670 : UH1 = UH1_0
                                let v671 : UH1 = UH1_1(v0, v670)
                                method43(v1, v671)
                        struct (v673, v0)
                    else
                        let v674 : bool = '`' = v581
                        if v674 then
                            let v676 : bool = v0 = ""
                            let v680 : UH1 =
                                if v676 then
                                    v1
                                else
                                    let v677 : UH1 = UH1_0
                                    let v678 : UH1 = UH1_1(v0, v677)
                                    method43(v1, v678)
                            struct (v680, v0)
                        else
                            let v682 : bool = v0 = ""
                            let v686 : UH1 =
                                if v682 then
                                    v1
                                else
                                    let v683 : UH1 = UH1_0
                                    let v684 : UH1 = UH1_1(v0, v683)
                                    method43(v1, v684)
                            struct (v686, v0)
            | _ -&gt;
                let v693 : bool = '\\' = v581
                if v693 then
                    match v2 with
                    | UH0_1(v694, v695) -&gt; (* Cons *)
                        let v696 : bool = '"' = v694
                        if v696 then
                            let v697 : US9 = US9_2(0uy, '\\')
                            let v698 : bool = v3 &lt;&gt; v697
                            let v701 : bool =
                                if v698 then
                                    let v699 : US9 = US9_2(0uy, '`')
                                    let v700 : bool = v3 &lt;&gt; v699
                                    v700
                                else
                                    false
                            if v701 then
                                let v702 : string = $"{v0}{v581}\""
                                let v703 : char = '"'
                                let v704 : US9 = US9_1(v703)
                                method41(v702, v1, v695, v4, v704)
                            else
                                let v707 : US9 = US9_0
                                method41(v0, v1, v695, v4, v707)
                        else
                            let v712 : bool = '\\' = v694
                            if v712 then
                                let v713 : uint8 = 1uy
                                let v714 : US9 = US9_2(v713, v694)
                                method41(v0, v1, v695, v4, v714)
                            else
                                let v717 : bool = '`' = v694
                                if v717 then
                                    let v718 : uint8 = 1uy
                                    let v719 : US9 = US9_2(v718, v694)
                                    method41(v0, v1, v695, v4, v719)
                                else
                                    match v3 with
                                    | US9_2(v722, v723) -&gt; (* Escaped *)
                                        let v724 : bool = 0uy = v722
                                        if v724 then
                                            let v725 : bool = ' ' = v694
                                            if v725 then
                                                let v726 : string = $"{v0} "
                                                method42(v726, v1, v695, v4)
                                            else
                                                let v729 : string = $"{v0}{v694}"
                                                method42(v729, v1, v695, v4)
                                        else
                                            let v734 : bool = ' ' = v694
                                            if v734 then
                                                let v735 : string = $"{v0} "
                                                method42(v735, v1, v695, v4)
                                            else
                                                let v738 : string = $"{v0}{v694}"
                                                method42(v738, v1, v695, v4)
                                    | _ -&gt;
                                        let v745 : bool = ' ' = v694
                                        if v745 then
                                            let v746 : string = $"{v0} "
                                            method42(v746, v1, v695, v4)
                                        else
                                            let v749 : string = $"{v0}{v694}"
                                            method42(v749, v1, v695, v4)
                    | _ -&gt;
                        match v3 with
                        | US9_2(v762, v763) -&gt; (* Escaped *)
                            let v764 : bool = 0uy = v762
                            if v764 then
                                let v766 : bool = v0 = ""
                                let v770 : UH1 =
                                    if v766 then
                                        v1
                                    else
                                        let v767 : UH1 = UH1_0
                                        let v768 : UH1 = UH1_1(v0, v767)
                                        method43(v1, v768)
                                struct (v770, v0)
                            else
                                let v772 : bool = v0 = ""
                                let v776 : UH1 =
                                    if v772 then
                                        v1
                                    else
                                        let v773 : UH1 = UH1_0
                                        let v774 : UH1 = UH1_1(v0, v773)
                                        method43(v1, v774)
                                struct (v776, v0)
                        | _ -&gt;
                            let v780 : bool = v0 = ""
                            let v784 : UH1 =
                                if v780 then
                                    v1
                                else
                                    let v781 : UH1 = UH1_0
                                    let v782 : UH1 = UH1_1(v0, v781)
                                    method43(v1, v782)
                            struct (v784, v0)
                else
                    let v789 : bool = '`' = v581
                    if v789 then
                        match v2 with
                        | UH0_1(v790, v791) -&gt; (* Cons *)
                            let v792 : bool = '"' = v790
                            if v792 then
                                let v793 : US9 = US9_2(0uy, '\\')
                                let v794 : bool = v3 &lt;&gt; v793
                                let v797 : bool =
                                    if v794 then
                                        let v795 : US9 = US9_2(0uy, '`')
                                        let v796 : bool = v3 &lt;&gt; v795
                                        v796
                                    else
                                        false
                                if v797 then
                                    let v798 : string = $"{v0}{v581}\""
                                    let v799 : char = '"'
                                    let v800 : US9 = US9_1(v799)
                                    method41(v798, v1, v791, v4, v800)
                                else
                                    let v803 : US9 = US9_0
                                    method41(v0, v1, v791, v4, v803)
                            else
                                let v808 : bool = '\\' = v790
                                if v808 then
                                    let v809 : uint8 = 1uy
                                    let v810 : US9 = US9_2(v809, v790)
                                    method41(v0, v1, v791, v4, v810)
                                else
                                    let v813 : bool = '`' = v790
                                    if v813 then
                                        let v814 : uint8 = 1uy
                                        let v815 : US9 = US9_2(v814, v790)
                                        method41(v0, v1, v791, v4, v815)
                                    else
                                        match v3 with
                                        | US9_2(v818, v819) -&gt; (* Escaped *)
                                            let v820 : bool = 0uy = v818
                                            if v820 then
                                                let v821 : bool = ' ' = v790
                                                if v821 then
                                                    let v822 : string = $"{v0} "
                                                    method42(v822, v1, v791, v4)
                                                else
                                                    let v825 : string = $"{v0}{v790}"
                                                    method42(v825, v1, v791, v4)
                                            else
                                                let v830 : bool = ' ' = v790
                                                if v830 then
                                                    let v831 : string = $"{v0} "
                                                    method42(v831, v1, v791, v4)
                                                else
                                                    let v834 : string = $"{v0}{v790}"
                                                    method42(v834, v1, v791, v4)
                                        | _ -&gt;
                                            let v841 : bool = ' ' = v790
                                            if v841 then
                                                let v842 : string = $"{v0} "
                                                method42(v842, v1, v791, v4)
                                            else
                                                let v845 : string = $"{v0}{v790}"
                                                method42(v845, v1, v791, v4)
                        | _ -&gt;
                            match v3 with
                            | US9_2(v858, v859) -&gt; (* Escaped *)
                                let v860 : bool = 0uy = v858
                                if v860 then
                                    let v862 : bool = v0 = ""
                                    let v866 : UH1 =
                                        if v862 then
                                            v1
                                        else
                                            let v863 : UH1 = UH1_0
                                            let v864 : UH1 = UH1_1(v0, v863)
                                            method43(v1, v864)
                                    struct (v866, v0)
                                else
                                    let v868 : bool = v0 = ""
                                    let v872 : UH1 =
                                        if v868 then
                                            v1
                                        else
                                            let v869 : UH1 = UH1_0
                                            let v870 : UH1 = UH1_1(v0, v869)
                                            method43(v1, v870)
                                    struct (v872, v0)
                            | _ -&gt;
                                let v876 : bool = v0 = ""
                                let v880 : UH1 =
                                    if v876 then
                                        v1
                                    else
                                        let v877 : UH1 = UH1_0
                                        let v878 : UH1 = UH1_1(v0, v877)
                                        method43(v1, v878)
                                struct (v880, v0)
                    else
                        match v2 with
                        | UH0_1(v885, v886) -&gt; (* Cons *)
                            let v887 : bool = '\\' = v885
                            if v887 then
                                let v888 : uint8 = 1uy
                                let v889 : US9 = US9_2(v888, v885)
                                method41(v0, v1, v886, v4, v889)
                            else
                                let v892 : bool = '`' = v885
                                if v892 then
                                    let v893 : uint8 = 1uy
                                    let v894 : US9 = US9_2(v893, v885)
                                    method41(v0, v1, v886, v4, v894)
                                else
                                    match v3 with
                                    | US9_2(v897, v898) -&gt; (* Escaped *)
                                        let v899 : bool = 0uy = v897
                                        if v899 then
                                            let v900 : bool = '"' = v885
                                            if v900 then
                                                let v901 : string = $"{v0}"
                                                let v902 : char = '"'
                                                let v903 : US9 = US9_1(v902)
                                                method41(v901, v1, v886, v4, v903)
                                            else
                                                let v906 : bool = ' ' = v885
                                                if v906 then
                                                    let v907 : string = $"{v0} "
                                                    method42(v907, v1, v886, v4)
                                                else
                                                    let v910 : string = $"{v0}{v885}"
                                                    method42(v910, v1, v886, v4)
                                        else
                                            let v917 : bool = '"' = v885
                                            if v917 then
                                                let v918 : UH1 = UH1_0
                                                let v919 : UH1 = UH1_1(v0, v918)
                                                let v920 : UH1 = method43(v1, v919)
                                                let v921 : string = ""
                                                let v922 : US9 = US9_0
                                                method41(v921, v920, v886, v4, v922)
                                            else
                                                let v925 : bool = ' ' = v885
                                                if v925 then
                                                    let v926 : string = $"{v0} "
                                                    method42(v926, v1, v886, v4)
                                                else
                                                    let v929 : string = $"{v0}{v885}"
                                                    method42(v929, v1, v886, v4)
                                    | _ -&gt;
                                        let v938 : bool = '"' = v885
                                        if v938 then
                                            let v939 : UH1 = UH1_0
                                            let v940 : UH1 = UH1_1(v0, v939)
                                            let v941 : UH1 = method43(v1, v940)
                                            let v942 : string = ""
                                            let v943 : US9 = US9_0
                                            method41(v942, v941, v886, v4, v943)
                                        else
                                            let v946 : bool = ' ' = v885
                                            if v946 then
                                                let v947 : string = $"{v0} "
                                                method42(v947, v1, v886, v4)
                                            else
                                                let v950 : string = $"{v0}{v885}"
                                                method42(v950, v1, v886, v4)
                        | _ -&gt;
                            match v3 with
                            | US9_2(v963, v964) -&gt; (* Escaped *)
                                let v965 : bool = 0uy = v963
                                if v965 then
                                    let v967 : bool = v0 = ""
                                    let v971 : UH1 =
                                        if v967 then
                                            v1
                                        else
                                            let v968 : UH1 = UH1_0
                                            let v969 : UH1 = UH1_1(v0, v968)
                                            method43(v1, v969)
                                    struct (v971, v0)
                                else
                                    let v973 : bool = v0 = ""
                                    let v977 : UH1 =
                                        if v973 then
                                            v1
                                        else
                                            let v974 : UH1 = UH1_0
                                            let v975 : UH1 = UH1_1(v0, v974)
                                            method43(v1, v975)
                                    struct (v977, v0)
                            | _ -&gt;
                                let v981 : bool = v0 = ""
                                let v985 : UH1 =
                                    if v981 then
                                        v1
                                    else
                                        let v982 : UH1 = UH1_0
                                        let v983 : UH1 = UH1_1(v0, v982)
                                        method43(v1, v983)
                                struct (v985, v0)
        else
            let v996 : bool = '\\' = v581
            if v996 then
                match v2 with
                | UH0_1(v997, v998) -&gt; (* Cons *)
                    let v999 : bool = '"' = v997
                    if v999 then
                        let v1000 : US9 = US9_2(0uy, '\\')
                        let v1001 : bool = v3 &lt;&gt; v1000
                        let v1004 : bool =
                            if v1001 then
                                let v1002 : US9 = US9_2(0uy, '`')
                                let v1003 : bool = v3 &lt;&gt; v1002
                                v1003
                            else
                                false
                        if v1004 then
                            let v1005 : string = $"{v0}{v581}\""
                            let v1006 : char = '"'
                            let v1007 : US9 = US9_1(v1006)
                            method41(v1005, v1, v998, v4, v1007)
                        else
                            match v3 with
                            | US9_1(v1010) -&gt; (* Quoted *)
                                let v1011 : string = $"{v0}{v581}\""
                                let v1012 : char = '"'
                                let v1013 : US9 = US9_1(v1012)
                                method41(v1011, v1, v998, v4, v1013)
                            | _ -&gt;
                                let v1016 : US9 = US9_0
                                method41(v0, v1, v998, v4, v1016)
                    else
                        match v3 with
                        | US9_1(v1023) -&gt; (* Quoted *)
                            let v1024 : bool = '\\' = v997
                            if v1024 then
                                let v1025 : uint8 = 0uy
                                let v1026 : US9 = US9_2(v1025, v997)
                                method41(v0, v1, v998, v4, v1026)
                            else
                                let v1029 : bool = '`' = v997
                                if v1029 then
                                    let v1030 : uint8 = 0uy
                                    let v1031 : US9 = US9_2(v1030, v997)
                                    method41(v0, v1, v998, v4, v1031)
                                else
                                    let v1034 : bool = ' ' = v997
                                    if v1034 then
                                        let v1035 : string = $"{v0} "
                                        method42(v1035, v1, v998, v4)
                                    else
                                        let v1038 : string = $"{v0}{v997}"
                                        method42(v1038, v1, v998, v4)
                        | _ -&gt;
                            let v1047 : bool = '\\' = v997
                            if v1047 then
                                let v1048 : uint8 = 1uy
                                let v1049 : US9 = US9_2(v1048, v997)
                                method41(v0, v1, v998, v4, v1049)
                            else
                                let v1052 : bool = '`' = v997
                                if v1052 then
                                    let v1053 : uint8 = 1uy
                                    let v1054 : US9 = US9_2(v1053, v997)
                                    method41(v0, v1, v998, v4, v1054)
                                else
                                    match v3 with
                                    | US9_2(v1057, v1058) -&gt; (* Escaped *)
                                        let v1059 : bool = 0uy = v1057
                                        if v1059 then
                                            let v1060 : bool = ' ' = v997
                                            if v1060 then
                                                let v1061 : string = $"{v0} "
                                                method42(v1061, v1, v998, v4)
                                            else
                                                let v1064 : string = $"{v0}{v997}"
                                                method42(v1064, v1, v998, v4)
                                        else
                                            let v1069 : bool = ' ' = v997
                                            if v1069 then
                                                let v1070 : string = $"{v0} "
                                                method42(v1070, v1, v998, v4)
                                            else
                                                let v1073 : string = $"{v0}{v997}"
                                                method42(v1073, v1, v998, v4)
                                    | _ -&gt;
                                        let v1080 : bool = ' ' = v997
                                        if v1080 then
                                            let v1081 : string = $"{v0} "
                                            method42(v1081, v1, v998, v4)
                                        else
                                            let v1084 : string = $"{v0}{v997}"
                                            method42(v1084, v1, v998, v4)
                | _ -&gt;
                    match v3 with
                    | US9_2(v1106, v1107) -&gt; (* Escaped *)
                        let v1108 : bool = 0uy = v1106
                        if v1108 then
                            let v1110 : bool = v0 = ""
                            let v1114 : UH1 =
                                if v1110 then
                                    v1
                                else
                                    let v1111 : UH1 = UH1_0
                                    let v1112 : UH1 = UH1_1(v0, v1111)
                                    method43(v1, v1112)
                            struct (v1114, v0)
                        else
                            let v1116 : bool = v0 = ""
                            let v1120 : UH1 =
                                if v1116 then
                                    v1
                                else
                                    let v1117 : UH1 = UH1_0
                                    let v1118 : UH1 = UH1_1(v0, v1117)
                                    method43(v1, v1118)
                            struct (v1120, v0)
                    | US9_1(v1099) -&gt; (* Quoted *)
                        let v1101 : bool = v0 = ""
                        let v1105 : UH1 =
                            if v1101 then
                                v1
                            else
                                let v1102 : UH1 = UH1_0
                                let v1103 : UH1 = UH1_1(v0, v1102)
                                method43(v1, v1103)
                        struct (v1105, v0)
                    | _ -&gt;
                        let v1124 : bool = v0 = ""
                        let v1128 : UH1 =
                            if v1124 then
                                v1
                            else
                                let v1125 : UH1 = UH1_0
                                let v1126 : UH1 = UH1_1(v0, v1125)
                                method43(v1, v1126)
                        struct (v1128, v0)
            else
                let v1135 : bool = '`' = v581
                if v1135 then
                    match v2 with
                    | UH0_1(v1136, v1137) -&gt; (* Cons *)
                        let v1138 : bool = '"' = v1136
                        if v1138 then
                            let v1139 : US9 = US9_2(0uy, '\\')
                            let v1140 : bool = v3 &lt;&gt; v1139
                            let v1143 : bool =
                                if v1140 then
                                    let v1141 : US9 = US9_2(0uy, '`')
                                    let v1142 : bool = v3 &lt;&gt; v1141
                                    v1142
                                else
                                    false
                            if v1143 then
                                let v1144 : string = $"{v0}{v581}\""
                                let v1145 : char = '"'
                                let v1146 : US9 = US9_1(v1145)
                                method41(v1144, v1, v1137, v4, v1146)
                            else
                                match v3 with
                                | US9_1(v1149) -&gt; (* Quoted *)
                                    let v1150 : string = $"{v0}{v581}\""
                                    let v1151 : char = '"'
                                    let v1152 : US9 = US9_1(v1151)
                                    method41(v1150, v1, v1137, v4, v1152)
                                | _ -&gt;
                                    let v1155 : US9 = US9_0
                                    method41(v0, v1, v1137, v4, v1155)
                        else
                            match v3 with
                            | US9_1(v1162) -&gt; (* Quoted *)
                                let v1163 : bool = '\\' = v1136
                                if v1163 then
                                    let v1164 : uint8 = 0uy
                                    let v1165 : US9 = US9_2(v1164, v1136)
                                    method41(v0, v1, v1137, v4, v1165)
                                else
                                    let v1168 : bool = '`' = v1136
                                    if v1168 then
                                        let v1169 : uint8 = 0uy
                                        let v1170 : US9 = US9_2(v1169, v1136)
                                        method41(v0, v1, v1137, v4, v1170)
                                    else
                                        let v1173 : bool = ' ' = v1136
                                        if v1173 then
                                            let v1174 : string = $"{v0} "
                                            method42(v1174, v1, v1137, v4)
                                        else
                                            let v1177 : string = $"{v0}{v1136}"
                                            method42(v1177, v1, v1137, v4)
                            | _ -&gt;
                                let v1186 : bool = '\\' = v1136
                                if v1186 then
                                    let v1187 : uint8 = 1uy
                                    let v1188 : US9 = US9_2(v1187, v1136)
                                    method41(v0, v1, v1137, v4, v1188)
                                else
                                    let v1191 : bool = '`' = v1136
                                    if v1191 then
                                        let v1192 : uint8 = 1uy
                                        let v1193 : US9 = US9_2(v1192, v1136)
                                        method41(v0, v1, v1137, v4, v1193)
                                    else
                                        match v3 with
                                        | US9_2(v1196, v1197) -&gt; (* Escaped *)
                                            let v1198 : bool = 0uy = v1196
                                            if v1198 then
                                                let v1199 : bool = ' ' = v1136
                                                if v1199 then
                                                    let v1200 : string = $"{v0} "
                                                    method42(v1200, v1, v1137, v4)
                                                else
                                                    let v1203 : string = $"{v0}{v1136}"
                                                    method42(v1203, v1, v1137, v4)
                                            else
                                                let v1208 : bool = ' ' = v1136
                                                if v1208 then
                                                    let v1209 : string = $"{v0} "
                                                    method42(v1209, v1, v1137, v4)
                                                else
                                                    let v1212 : string = $"{v0}{v1136}"
                                                    method42(v1212, v1, v1137, v4)
                                        | _ -&gt;
                                            let v1219 : bool = ' ' = v1136
                                            if v1219 then
                                                let v1220 : string = $"{v0} "
                                                method42(v1220, v1, v1137, v4)
                                            else
                                                let v1223 : string = $"{v0}{v1136}"
                                                method42(v1223, v1, v1137, v4)
                    | _ -&gt;
                        match v3 with
                        | US9_2(v1245, v1246) -&gt; (* Escaped *)
                            let v1247 : bool = 0uy = v1245
                            if v1247 then
                                let v1249 : bool = v0 = ""
                                let v1253 : UH1 =
                                    if v1249 then
                                        v1
                                    else
                                        let v1250 : UH1 = UH1_0
                                        let v1251 : UH1 = UH1_1(v0, v1250)
                                        method43(v1, v1251)
                                struct (v1253, v0)
                            else
                                let v1255 : bool = v0 = ""
                                let v1259 : UH1 =
                                    if v1255 then
                                        v1
                                    else
                                        let v1256 : UH1 = UH1_0
                                        let v1257 : UH1 = UH1_1(v0, v1256)
                                        method43(v1, v1257)
                                struct (v1259, v0)
                        | US9_1(v1238) -&gt; (* Quoted *)
                            let v1240 : bool = v0 = ""
                            let v1244 : UH1 =
                                if v1240 then
                                    v1
                                else
                                    let v1241 : UH1 = UH1_0
                                    let v1242 : UH1 = UH1_1(v0, v1241)
                                    method43(v1, v1242)
                            struct (v1244, v0)
                        | _ -&gt;
                            let v1263 : bool = v0 = ""
                            let v1267 : UH1 =
                                if v1263 then
                                    v1
                                else
                                    let v1264 : UH1 = UH1_0
                                    let v1265 : UH1 = UH1_1(v0, v1264)
                                    method43(v1, v1265)
                            struct (v1267, v0)
                else
                    match v3 with
                    | US9_1(v1274) -&gt; (* Quoted *)
                        match v2 with
                        | UH0_1(v1275, v1276) -&gt; (* Cons *)
                            let v1277 : bool = '\\' = v1275
                            if v1277 then
                                let v1278 : uint8 = 0uy
                                let v1279 : US9 = US9_2(v1278, v1275)
                                method41(v0, v1, v1276, v4, v1279)
                            else
                                let v1282 : bool = '`' = v1275
                                if v1282 then
                                    let v1283 : uint8 = 0uy
                                    let v1284 : US9 = US9_2(v1283, v1275)
                                    method41(v0, v1, v1276, v4, v1284)
                                else
                                    let v1287 : bool = '"' = v1275
                                    if v1287 then
                                        let v1288 : UH1 = UH1_0
                                        let v1289 : UH1 = UH1_1(v0, v1288)
                                        let v1290 : UH1 = method43(v1, v1289)
                                        let v1291 : string = ""
                                        let v1292 : US9 = US9_0
                                        method41(v1291, v1290, v1276, v4, v1292)
                                    else
                                        let v1295 : bool = ' ' = v1275
                                        if v1295 then
                                            let v1296 : string = $"{v0} "
                                            method42(v1296, v1, v1276, v4)
                                        else
                                            let v1299 : string = $"{v0}{v1275}"
                                            method42(v1299, v1, v1276, v4)
                        | _ -&gt;
                            let v1311 : bool = v0 = ""
                            let v1315 : UH1 =
                                if v1311 then
                                    v1
                                else
                                    let v1312 : UH1 = UH1_0
                                    let v1313 : UH1 = UH1_1(v0, v1312)
                                    method43(v1, v1313)
                            struct (v1315, v0)
                    | _ -&gt;
                        match v2 with
                        | UH0_1(v1318, v1319) -&gt; (* Cons *)
                            let v1320 : bool = '\\' = v1318
                            if v1320 then
                                let v1321 : uint8 = 1uy
                                let v1322 : US9 = US9_2(v1321, v1318)
                                method41(v0, v1, v1319, v4, v1322)
                            else
                                let v1325 : bool = '`' = v1318
                                if v1325 then
                                    let v1326 : uint8 = 1uy
                                    let v1327 : US9 = US9_2(v1326, v1318)
                                    method41(v0, v1, v1319, v4, v1327)
                                else
                                    match v3 with
                                    | US9_2(v1330, v1331) -&gt; (* Escaped *)
                                        let v1332 : bool = 0uy = v1330
                                        if v1332 then
                                            let v1333 : bool = '"' = v1318
                                            if v1333 then
                                                let v1334 : string = $"{v0}"
                                                let v1335 : char = '"'
                                                let v1336 : US9 = US9_1(v1335)
                                                method41(v1334, v1, v1319, v4, v1336)
                                            else
                                                let v1339 : bool = ' ' = v1318
                                                if v1339 then
                                                    let v1340 : string = $"{v0} "
                                                    method42(v1340, v1, v1319, v4)
                                                else
                                                    let v1343 : string = $"{v0}{v1318}"
                                                    method42(v1343, v1, v1319, v4)
                                        else
                                            let v1350 : bool = '"' = v1318
                                            if v1350 then
                                                let v1351 : UH1 = UH1_0
                                                let v1352 : UH1 = UH1_1(v0, v1351)
                                                let v1353 : UH1 = method43(v1, v1352)
                                                let v1354 : string = ""
                                                let v1355 : US9 = US9_0
                                                method41(v1354, v1353, v1319, v4, v1355)
                                            else
                                                let v1358 : bool = ' ' = v1318
                                                if v1358 then
                                                    let v1359 : string = $"{v0} "
                                                    method42(v1359, v1, v1319, v4)
                                                else
                                                    let v1362 : string = $"{v0}{v1318}"
                                                    method42(v1362, v1, v1319, v4)
                                    | _ -&gt;
                                        let v1371 : bool = '"' = v1318
                                        if v1371 then
                                            let v1372 : UH1 = UH1_0
                                            let v1373 : UH1 = UH1_1(v0, v1372)
                                            let v1374 : UH1 = method43(v1, v1373)
                                            let v1375 : string = ""
                                            let v1376 : US9 = US9_0
                                            method41(v1375, v1374, v1319, v4, v1376)
                                        else
                                            let v1379 : bool = ' ' = v1318
                                            if v1379 then
                                                let v1380 : string = $"{v0} "
                                                method42(v1380, v1, v1319, v4)
                                            else
                                                let v1383 : string = $"{v0}{v1318}"
                                                method42(v1383, v1, v1319, v4)
                        | _ -&gt;
                            match v3 with
                            | US9_2(v1396, v1397) -&gt; (* Escaped *)
                                let v1398 : bool = 0uy = v1396
                                if v1398 then
                                    let v1400 : bool = v0 = ""
                                    let v1404 : UH1 =
                                        if v1400 then
                                            v1
                                        else
                                            let v1401 : UH1 = UH1_0
                                            let v1402 : UH1 = UH1_1(v0, v1401)
                                            method43(v1, v1402)
                                    struct (v1404, v0)
                                else
                                    let v1406 : bool = v0 = ""
                                    let v1410 : UH1 =
                                        if v1406 then
                                            v1
                                        else
                                            let v1407 : UH1 = UH1_0
                                            let v1408 : UH1 = UH1_1(v0, v1407)
                                            method43(v1, v1408)
                                    struct (v1410, v0)
                            | _ -&gt;
                                let v1414 : bool = v0 = ""
                                let v1418 : UH1 =
                                    if v1414 then
                                        v1
                                    else
                                        let v1415 : UH1 = UH1_0
                                        let v1416 : UH1 = UH1_1(v0, v1415)
                                        method43(v1, v1416)
                                struct (v1418, v0)
    | US9_0 -&gt; (* Start *)
        match v2 with
        | UH0_1(v5, v6) -&gt; (* Cons *)
            let v7 : bool = '"' = v5
            if v7 then
                let v8 : string = ""
                let v9 : char = '"'
                let v10 : US9 = US9_1(v9)
                method41(v8, v1, v6, v4, v10)
            else
                let v13 : bool = '\\' = v5
                if v13 then
                    let v14 : uint8 = 0uy
                    let v15 : US9 = US9_2(v14, v5)
                    method41(v0, v1, v6, v4, v15)
                else
                    let v18 : bool = '`' = v5
                    if v18 then
                        let v19 : uint8 = 0uy
                        let v20 : US9 = US9_2(v19, v5)
                        method41(v0, v1, v6, v4, v20)
                    else
                        let v23 : bool = ' ' = v5
                        if v23 then
                            let v25 : bool = v0 = ""
                            let v29 : UH1 =
                                if v25 then
                                    v1
                                else
                                    let v26 : UH1 = UH1_0
                                    let v27 : UH1 = UH1_1(v0, v26)
                                    method43(v1, v27)
                            let v30 : string = ""
                            method42(v30, v29, v6, v4)
                        else
                            let v33 : string = $"{v0}{v5}"
                            method42(v33, v1, v6, v4)
        | _ -&gt;
            let v45 : bool = v0 = ""
            let v49 : UH1 =
                if v45 then
                    v1
                else
                    let v46 : UH1 = UH1_0
                    let v47 : UH1 = UH1_1(v0, v46)
                    method43(v1, v47)
            struct (v49, v0)
and method44 (v0 : UH1, v1 : string list) : string list =
    match v0 with
    | UH1_1(v2, v3) -&gt; (* Cons *)
        let v4 : string list = method44(v3, v1)
        let v5 : string list = v2 :: v4 
        v5
    | UH1_0 -&gt; (* Nil *)
        v1
and method40 (v0 : string) : (string []) =
    let v1 : UH1 = UH1_0
    let v2 : string = ""
    let mutable _v0 = None
    #if !FABLE_COMPILER &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v3 : (string -&gt; string option) = Option.ofObj
    let v4 : string option = v3 v0
    v4 
    #else
    Some v0 
    #endif
    |&gt; fun x -&gt; _v0 &lt;- Some x
    let v5 : string option = _v0.Value
    let v6 : US3 option = None
    let _v6 = ref v6 
    match v5 with
    | Some x -&gt; (
    (fun () -&gt;
    (fun () -&gt;
    let v7 : string = x
    let v8 : US3 = US3_0(v7)
    v8 
    )
    |&gt; fun x -&gt; x () |&gt; Some
    ) () ) | None -&gt; None
    |&gt; fun x -&gt; _v6.Value &lt;- x
    let v9 : US3 option = _v6.Value 
    let v10 : US3 = US3_1
    let v11 : US3 = v9 |&gt; Option.defaultValue v10 
    let v14 : string =
        match v11 with
        | US3_1 -&gt; (* None *)
            v2
        | US3_0(v12) -&gt; (* Some *)
            v12
    let v15 : int32 = v14.Length
    let v16 : (char []) = Array.zeroCreate&lt;char&gt; (v15)
    let v17 : Mut5 = {l0 = 0} : Mut5
    while method23(v15, v17) do
        let v19 : int32 = v17.l0
        let v20 : char = v14.[int v19]
        v16.[int v19] &lt;- v20
        let v21 : int32 = v19 + 1
        v17.l0 &lt;- v21
        ()
    let v22 : ((char []) -&gt; char list) = Array.toList
    let v23 : char list = v22 v16
    let v24 : ((char -&gt; (UH0 -&gt; UH0)) -&gt; (char list -&gt; (UH0 -&gt; UH0))) = List.foldBack
    let v25 : (char -&gt; (UH0 -&gt; UH0)) = method38()
    let v26 : (char list -&gt; (UH0 -&gt; UH0)) = v24 v25
    let v27 : (UH0 -&gt; UH0) = v26 v23
    let v28 : UH0 = UH0_0
    let v29 : UH0 = v27 v28
    let v30 : US9 = US9_0
    let v31 : US9 = US9_0
    let struct (v32 : UH1, v33 : string) = method41(v2, v1, v29, v31, v30)
    let v34 : string list = []
    let v35 : string list = method44(v32, v34)
    let v36 : (string list -&gt; (string [])) = List.toArray
    let v37 : (string []) = v36 v35
    v37
and closure25 () () : string =
    let v0 : string = $"runtime.execute_with_options"
    v0
and closure26 (v0 : System.Threading.CancellationToken option, v1 : string, v2 : (struct (string * string) []), v3 : (struct (bool * string * int32) -&gt; Async&lt;unit&gt;) option, v4 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) option, v5 : string option, v6 : string, v7 : Vec&lt;std_string_String&gt;) () : string =
    let v8 : (unit -&gt; string) = closure6()
    let v9 : string = $"file_name: {v6} / arguments: %A{v7} / options: %A{struct (v0, v1, v2, v3, v4, v5)} / {v8 ()}"
    v9
and closure27 () (v0 : std_sync_Arc&lt;std_sync_Mutex&lt;std_process_Child option&gt;&gt;) : US10 =
    US10_0(v0)
and closure28 () (v0 : std_string_String) : US10 =
    US10_1(v0)
and closure29 () () : string =
    let v0 : string = $"runtime.execute_with_options / child error"
    v0
and closure30 (v0 : std_string_String) () : string =
    let v1 : (unit -&gt; string) = closure6()
    let v2 : string = $"error: {v0} / {v1 ()}"
    v2
and method45 (v0 : std_sync_Arc&lt;std_sync_mpsc_Receiver&lt;std_string_String&gt;&gt;) : std_sync_Arc&lt;std_sync_mpsc_Receiver&lt;std_string_String&gt;&gt; =
    v0
and closure32 () (v0 : std_string_String) : US12 =
    US12_0(v0)
and closure33 () (v0 : std_string_String) : US12 =
    US12_1(v0)
and closure34 () () : string =
    let v0 : string = $"runtime.std_line"
    v0
and closure35 (v0 : std_string_String) () : string =
    let v1 : (unit -&gt; string) = closure6()
    let v2 : string = $"e: {v0} / {v1 ()}"
    v2
and closure36 (v0 : string) () : string =
    let v1 : string = $"&gt; {v0}"
    v1
and closure31 (v0 : std_sync_Arc&lt;std_sync_Mutex&lt;std_sync_mpsc_Sender&lt;std_string_String&gt;&gt;&gt;) (v1 : Result&lt;std_string_String, std_io_Error&gt;) : unit =
    let v2 : bool = true
    let mutable _v2 : unit option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v3 : (std_io_Error -&gt; std_string_String) = method29()
    let v4 : string = "$0.map_err(|x| $1(x))"
    let v5 : Result&lt;std_string_String, std_string_String&gt; = Fable.Core.RustInterop.emitRustExpr struct (v1, v3) v4
    let v6 : (std_string_String -&gt; US12) = closure32()
    let v7 : (std_string_String -&gt; US12) = closure33()
    let v8 : US12 = match v5 with Ok x -&gt; v6 x | Error x -&gt; v7 x
    let v39 : std_string_String =
        match v8 with
        | US12_1(v29) -&gt; (* Error *)
            let v30 : US0 = US0_4
            let v31 : (unit -&gt; string) = closure34()
            let v32 : (unit -&gt; string) = closure35(v29)
            method3(v30, v31, v32)
            let v33 : string = $"\e[4;7m{v29}\e[0m"
            let v34 : string = "&amp;*$0"
            let v35 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v33 v34
            let v36 : string = "String::from($0)"
            let v37 : std_string_String = Fable.Core.RustInterop.emitRustExpr v35 v36
            v37
        | US12_0(v9) -&gt; (* Ok *)
            let v10 : string = "fable_library_rust::String_::fromString($0)"
            let v11 : string = Fable.Core.RustInterop.emitRustExpr v9 v10
            let v12 : string = "encoding_rs::UTF_8"
            let v13 : Ref&lt;encoding_rs_Encoding&gt; = Fable.Core.RustInterop.emitRustExpr () v12
            let v14 : string = "$0.encode(&amp;*$1).0"
            let v15 : std_borrow_Cow&lt;Slice&lt;uint8&gt;&gt; = Fable.Core.RustInterop.emitRustExpr struct (v13, v11) v14
            let v16 : string = "$0.as_ref()"
            let v17 : Ref&lt;Slice&lt;uint8&gt;&gt; = Fable.Core.RustInterop.emitRustExpr v15 v16
            let v18 : string = "std::str::from_utf8(v17)"
            let v19 : Result&lt;Ref&lt;Str&gt;, std_str_Utf8Error&gt; = Fable.Core.RustInterop.emitRustExpr () v18
            let v20 : string = "$0.unwrap()"
            let v21 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v19 v20
            let v22 : string = "String::from($0)"
            let v23 : std_string_String = Fable.Core.RustInterop.emitRustExpr v21 v22
            let v24 : string = "fable_library_rust::String_::fromString($0)"
            let v25 : string = Fable.Core.RustInterop.emitRustExpr v23 v24
            let v26 : US0 = US0_0
            let v27 : (unit -&gt; string) = closure36(v25)
            let v28 : (unit -&gt; string) = closure6()
            method3(v26, v27, v28)
            v23
    let v40 : string = "true; $0.lock().unwrap().send($1).unwrap()"
    let v41 : bool = Fable.Core.RustInterop.emitRustExpr struct (v0, v39) v40
    () 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    null |&gt; unbox&lt;unit&gt;
    () 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    null |&gt; unbox&lt;unit&gt;
    () 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    null |&gt; unbox&lt;unit&gt;
    () 
    #endif
#if FABLE_COMPILER_PYTHON
    null |&gt; unbox&lt;unit&gt;
    () 
    #endif
#else
    null |&gt; unbox&lt;unit&gt;
    () 
    #endif
    |&gt; fun x -&gt; _v2 &lt;- Some x
    _v2.Value
    ()
and method46 (v0 : std_sync_MutexGuard&lt;std_process_ChildStdin&gt;) : std_sync_MutexGuard&lt;std_process_ChildStdin&gt; =
    v0
and closure37 () (v0 : std_process_Output) : US15 =
    US15_0(v0)
and closure38 () (v0 : std_string_String) : US15 =
    US15_1(v0)
and closure39 () () : string =
    let v0 : string = $"runtime.execute_with_options / output error"
    v0
and closure40 (v0 : std_string_String) () : string =
    let v1 : (unit -&gt; string) = closure6()
    let v2 : string = $"error: {v0} / {v1 ()}"
    v2
and closure41 () () : string =
    let v0 : string = $"runtime.execute_with_options / result"
    v0
and closure42 (v0 : int32, v1 : string) () : string =
    let v2 : (unit -&gt; string) = closure6()
    let v3 : string = $"exit_code: {v0} / std_trace.Length: {v1.Length} / {v2 ()}"
    v3
and method47 (v0 : (int32 * string)) : (int32 * string) =
    v0
and closure43 (v0 : System.Threading.CancellationToken option, v1 : string, v2 : (struct (string * string) []), v3 : (struct (bool * string * int32) -&gt; Async&lt;unit&gt;) option, v4 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) option, v5 : string option) () : string =
    let v6 : string = $"execute_with_options_async / options: %A{struct (v0, v1, v2, v3, v4, v5)}"
    v6
and method49 () : (unit -&gt; string) =
    closure6()
and closure45 (v0 : string) () : string =
    let v1 : string = $"&gt; {v0}"
    v1
and closure44 (v0 : System.Threading.CancellationToken option, v1 : string, v2 : (struct (string * string) []), v3 : (struct (bool * string * int32) -&gt; Async&lt;unit&gt;) option, v4 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) option, v5 : string option, v6 : System.Diagnostics.Process, v7 : System.Collections.Concurrent.ConcurrentStack&lt;string&gt;) (v8 : System.Diagnostics.DataReceivedEventArgs) : unit =
    let v9 : bool = true
    let mutable _v9 : Async&lt;unit&gt; option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v10 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v10 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v11 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v11 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v12 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v12 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v13 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v13 
    #endif
#if FABLE_COMPILER_PYTHON
    let v14 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v14 
    #endif
#else
    let v15 : Async&lt;unit&gt; option = None
    let mutable _v15 = v15
    async {
    let v16 : string = v8.Data
    let v17 : string = null |&gt; unbox&lt;string&gt;
    let v18 : bool = v16 = v17
    let v19 : bool = v18 &lt;&gt; true
    if v19 then
        let v20 : US16 option = None
        let _v20 = ref v20 
        match v3 with
        | Some x -&gt; (
        (fun () -&gt;
        (fun () -&gt;
        let v21 : (struct (bool * string * int32) -&gt; Async&lt;unit&gt;) = x
        let v22 : US16 = US16_0(v21)
        v22 
        )
        |&gt; fun x -&gt; x () |&gt; Some
        ) () ) | None -&gt; None
        |&gt; fun x -&gt; _v20.Value &lt;- x
        let v23 : US16 option = _v20.Value 
        let v24 : US16 = US16_1
        let v25 : US16 = v23 |&gt; Option.defaultValue v24 
        match v25 with
        | US16_1 -&gt; (* None *)
            ()
        | US16_0(v26) -&gt; (* Some *)
            let v27 : int32 = v6.Id
            let v28 : Async&lt;unit&gt; = v26 struct (false, v16, v27)
            do! v28 
            ()
        let v29 : US0 = US0_0
        let v30 : (unit -&gt; string) = closure45(v16)
        let v31 : (unit -&gt; string) = closure6()
        method3(v29, v30, v31)
        let v32 : string = ""
        let v33 : string = $"{v32}{v16}{v32}"
        let v34 : (string -&gt; unit) = v7.Push
        v34 v33
    }
    |&gt; fun x -&gt; _v15 &lt;- Some x
    let v35 : Async&lt;unit&gt; = _v15 |&gt; Option.get
    v35 
    #endif
    |&gt; fun x -&gt; _v9 &lt;- Some x
    let v36 : Async&lt;unit&gt; = _v9.Value
    let v37 : bool = true
    let mutable _v37 : unit option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    null |&gt; unbox&lt;unit&gt;
    () 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    null |&gt; unbox&lt;unit&gt;
    () 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    null |&gt; unbox&lt;unit&gt;
    () 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    null |&gt; unbox&lt;unit&gt;
    () 
    #endif
#if FABLE_COMPILER_PYTHON
    null |&gt; unbox&lt;unit&gt;
    () 
    #endif
#else
    let v38 : (Async&lt;unit&gt; -&gt; unit) = Async.StartImmediate
    v38 v36
    () 
    #endif
    |&gt; fun x -&gt; _v37 &lt;- Some x
    _v37.Value
    ()
and closure46 (v0 : System.Threading.CancellationToken option, v1 : string, v2 : (struct (string * string) []), v3 : (struct (bool * string * int32) -&gt; Async&lt;unit&gt;) option, v4 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) option, v5 : string option, v6 : System.Diagnostics.Process, v7 : System.Collections.Concurrent.ConcurrentStack&lt;string&gt;) (v8 : System.Diagnostics.DataReceivedEventArgs) : unit =
    let v9 : bool = true
    let mutable _v9 : Async&lt;unit&gt; option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v10 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v10 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v11 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v11 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v12 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v12 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v13 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v13 
    #endif
#if FABLE_COMPILER_PYTHON
    let v14 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v14 
    #endif
#else
    let v15 : Async&lt;unit&gt; option = None
    let mutable _v15 = v15
    async {
    let v16 : string = v8.Data
    let v17 : string = null |&gt; unbox&lt;string&gt;
    let v18 : bool = v16 = v17
    let v19 : bool = v18 &lt;&gt; true
    if v19 then
        let v20 : US16 option = None
        let _v20 = ref v20 
        match v3 with
        | Some x -&gt; (
        (fun () -&gt;
        (fun () -&gt;
        let v21 : (struct (bool * string * int32) -&gt; Async&lt;unit&gt;) = x
        let v22 : US16 = US16_0(v21)
        v22 
        )
        |&gt; fun x -&gt; x () |&gt; Some
        ) () ) | None -&gt; None
        |&gt; fun x -&gt; _v20.Value &lt;- x
        let v23 : US16 option = _v20.Value 
        let v24 : US16 = US16_1
        let v25 : US16 = v23 |&gt; Option.defaultValue v24 
        match v25 with
        | US16_1 -&gt; (* None *)
            ()
        | US16_0(v26) -&gt; (* Some *)
            let v27 : int32 = v6.Id
            let v28 : Async&lt;unit&gt; = v26 struct (true, v16, v27)
            do! v28 
            ()
        let v29 : US0 = US0_0
        let v30 : (unit -&gt; string) = closure45(v16)
        let v31 : (unit -&gt; string) = closure6()
        method3(v29, v30, v31)
        let v32 : string = "["
        let v33 : string = "]"
        let v34 : string = $"{v32}{v16}{v33}"
        let v35 : (string -&gt; unit) = v7.Push
        v35 v34
    }
    |&gt; fun x -&gt; _v15 &lt;- Some x
    let v36 : Async&lt;unit&gt; = _v15 |&gt; Option.get
    v36 
    #endif
    |&gt; fun x -&gt; _v9 &lt;- Some x
    let v37 : Async&lt;unit&gt; = _v9.Value
    let v38 : bool = true
    let mutable _v38 : unit option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    null |&gt; unbox&lt;unit&gt;
    () 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    null |&gt; unbox&lt;unit&gt;
    () 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    null |&gt; unbox&lt;unit&gt;
    () 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    null |&gt; unbox&lt;unit&gt;
    () 
    #endif
#if FABLE_COMPILER_PYTHON
    null |&gt; unbox&lt;unit&gt;
    () 
    #endif
#else
    let v39 : (Async&lt;unit&gt; -&gt; unit) = Async.StartImmediate
    v39 v37
    () 
    #endif
    |&gt; fun x -&gt; _v38 &lt;- Some x
    _v38.Value
    ()
and closure47 (v0 : System.Diagnostics.Process) () : unit =
    let v1 : bool = true
    let mutable _v1 : bool option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v2 : bool = null |&gt; unbox&lt;bool&gt;
    v2 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v3 : bool = null |&gt; unbox&lt;bool&gt;
    v3 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v4 : bool = null |&gt; unbox&lt;bool&gt;
    v4 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v5 : bool = null |&gt; unbox&lt;bool&gt;
    v5 
    #endif
#if FABLE_COMPILER_PYTHON
    let v6 : bool = null |&gt; unbox&lt;bool&gt;
    v6 
    #endif
#else
    let v7 : bool = v0.HasExited
    v7 
    #endif
    |&gt; fun x -&gt; _v1 &lt;- Some x
    let v8 : bool = _v1.Value
    let v9 : bool = v8 = false
    if v9 then
        let v10 : bool = true
        let mutable _v10 : unit option = None 
        
#if FABLE_COMPILER || WASM || CONTRACT
        
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
        null |&gt; unbox&lt;unit&gt;
        () 
        #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
        null |&gt; unbox&lt;unit&gt;
        () 
        #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
        null |&gt; unbox&lt;unit&gt;
        () 
        #endif
#if FABLE_COMPILER_TYPESCRIPT
        null |&gt; unbox&lt;unit&gt;
        () 
        #endif
#if FABLE_COMPILER_PYTHON
        null |&gt; unbox&lt;unit&gt;
        () 
        #endif
#else
        let v11 : (unit -&gt; unit) = v0.Kill
        v11 ()
        () 
        #endif
        |&gt; fun x -&gt; _v10 &lt;- Some x
        _v10.Value
        ()
and closure48 (v0 : System.Threading.Tasks.TaskCanceledException) () : string =
    let v1 : string = $"execute_with_options_async / WaitForExitAsync / ex: %A{v0}"
    v1
and method50 () : string =
    let v0 : string = "\n"
    v0
and closure49 (v0 : int32, v1 : string) () : string =
    let v2 : string = $"execute_with_options_async / exit_code: {v0} / output.Length: {v1.Length}"
    v2
and method48 (v0 : System.Threading.CancellationToken option, v1 : string, v2 : (struct (string * string) []), v3 : (struct (bool * string * int32) -&gt; Async&lt;unit&gt;) option, v4 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) option, v5 : string option) : Async&lt;struct (int32 * string)&gt; =
    let v6 : bool = true
    let mutable _v6 : Async&lt;struct (int32 * string)&gt; option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v7 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v7 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v8 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v8 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v9 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v9 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v10 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v10 
    #endif
#if FABLE_COMPILER_PYTHON
    let v11 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v11 
    #endif
#else
    let v12 : bool = true
    let mutable _v12 : Async&lt;struct (int32 * string)&gt; option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v13 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v13 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v14 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v14 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v15 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v15 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v16 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v16 
    #endif
#if FABLE_COMPILER_PYTHON
    let v17 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v17 
    #endif
#else
    let v18 : Async&lt;struct (int32 * string)&gt; option = None
    let mutable _v18 = v18
    async {
    let struct (v19 : string, v20 : string) = method37()
    let v21 : int32 = v1.Length
    let v22 : (char []) = Array.zeroCreate&lt;char&gt; (v21)
    let v23 : Mut5 = {l0 = 0} : Mut5
    while method23(v21, v23) do
        let v25 : int32 = v23.l0
        let v26 : char = v1.[int v25]
        v22.[int v25] &lt;- v26
        let v27 : int32 = v25 + 1
        v23.l0 &lt;- v27
        ()
    let v28 : ((char []) -&gt; char list) = Array.toList
    let v29 : char list = v28 v22
    let v30 : ((char -&gt; (UH0 -&gt; UH0)) -&gt; (char list -&gt; (UH0 -&gt; UH0))) = List.foldBack
    let v31 : (char -&gt; (UH0 -&gt; UH0)) = method38()
    let v32 : (char list -&gt; (UH0 -&gt; UH0)) = v30 v31
    let v33 : (UH0 -&gt; UH0) = v32 v29
    let v34 : UH0 = UH0_0
    let v35 : UH0 = v33 v34
    let v36 : US7 = US7_0
    let struct (v37 : string, v38 : string) = method39(v20, v19, v35, v36)
    let v39 : US3 option = None
    let _v39 = ref v39 
    match v5 with
    | Some x -&gt; (
    (fun () -&gt;
    (fun () -&gt;
    let v40 : string = x
    let v41 : US3 = US3_0(v40)
    v41 
    )
    |&gt; fun x -&gt; x () |&gt; Some
    ) () ) | None -&gt; None
    |&gt; fun x -&gt; _v39.Value &lt;- x
    let v42 : US3 option = _v39.Value 
    let v43 : US3 = US3_1
    let v44 : US3 = v42 |&gt; Option.defaultValue v43 
    let v48 : string =
        match v44 with
        | US3_1 -&gt; (* None *)
            let v46 : string = ""
            v46
        | US3_0(v45) -&gt; (* Some *)
            v45
    let v49 : US0 = US0_1
    let v50 : (unit -&gt; string) = closure43(v0, v1, v2, v3, v4, v5)
    let v51 : (unit -&gt; string) = method49()
    method3(v49, v50, v51)
    let v52 : System.Text.Encoding = System.Text.Encoding.UTF8
    let v53 : System.Diagnostics.ProcessStartInfo = System.Diagnostics.ProcessStartInfo (Arguments = v38, StandardOutputEncoding = v52, WorkingDirectory = v48, FileName = v37, CreateNoWindow = true, RedirectStandardError = true, RedirectStandardOutput = true, UseShellExecute = false)
    let v54 : int32 = v2.Length
    let v55 : Mut5 = {l0 = 0} : Mut5
    while method23(v54, v55) do
        let v57 : int32 = v55.l0
        let struct (v58 : string, v59 : string) = v2.[int v57]
        v53.EnvironmentVariables.[v58] &lt;- v59 
        let v60 : int32 = v57 + 1
        v55.l0 &lt;- v60
        ()
    let v61 : System.Diagnostics.Process = new System.Diagnostics.Process (StartInfo = v53)
    use v61 = v61 
    let v62 : System.Diagnostics.Process = v61 
    let v63 : (unit -&gt; System.Collections.Concurrent.ConcurrentStack&lt;string&gt;) = System.Collections.Concurrent.ConcurrentStack&lt;string&gt;
    let v64 : System.Collections.Concurrent.ConcurrentStack&lt;string&gt; = v63 ()
    let v65 : (System.Diagnostics.DataReceivedEventArgs -&gt; unit) = closure44(v0, v1, v2, v3, v4, v5, v62, v64)
    v62.OutputDataReceived.Add v65 
    let v66 : (System.Diagnostics.DataReceivedEventArgs -&gt; unit) = closure46(v0, v1, v2, v3, v4, v5, v62, v64)
    v62.ErrorDataReceived.Add v66 
    let v67 : (unit -&gt; bool) = v62.Start
    let v68 : bool = v67 ()
    let v69 : bool = v68 = false
    if v69 then
        let v70 : string = $"execute_with_options_async / process_start error"
        failwith&lt;unit&gt; v70
    let v71 : (unit -&gt; unit) = v62.BeginErrorReadLine
    v71 ()
    let v72 : (unit -&gt; unit) = v62.BeginOutputReadLine
    v72 ()
    let v73 : US17 option = None
    let _v73 = ref v73 
    match v0 with
    | Some x -&gt; (
    (fun () -&gt;
    (fun () -&gt;
    let v74 : System.Threading.CancellationToken = x
    let v75 : US17 = US17_0(v74)
    v75 
    )
    |&gt; fun x -&gt; x () |&gt; Some
    ) () ) | None -&gt; None
    |&gt; fun x -&gt; _v73.Value &lt;- x
    let v76 : US17 option = _v73.Value 
    let v77 : US17 = US17_1
    let v78 : US17 = v76 |&gt; Option.defaultValue v77 
    let v82 : System.Threading.CancellationToken =
        match v78 with
        | US17_1 -&gt; (* None *)
            let v80 : System.Threading.CancellationToken = System.Threading.CancellationToken.None
            v80
        | US17_0(v79) -&gt; (* Some *)
            v79
    let v83 : bool = true
    let mutable _v83 : Async&lt;System.Threading.CancellationToken&gt; option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v84 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v84 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v85 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v85 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v86 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v86 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v87 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v87 
    #endif
#if FABLE_COMPILER_PYTHON
    let v88 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v88 
    #endif
#else
    let v89 : bool = true
    let mutable _v89 : Async&lt;System.Threading.CancellationToken&gt; option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v90 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v90 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v91 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v91 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v92 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v92 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v93 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v93 
    #endif
#if FABLE_COMPILER_PYTHON
    let v94 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v94 
    #endif
#else
    let v95 : Async&lt;System.Threading.CancellationToken&gt; option = None
    let mutable _v95 = v95
    async {
    let v96 : Async&lt;System.Threading.CancellationToken&gt; = Async.CancellationToken
    let! v96 = v96 
    let v97 : System.Threading.CancellationToken = v96 
    let v98 : System.Threading.CancellationToken = Async.DefaultCancellationToken
    let v99 : (System.Threading.CancellationToken []) = [|v97; v98; v82|]
    let v100 : ((System.Threading.CancellationToken []) -&gt; System.Threading.CancellationTokenSource) = System.Threading.CancellationTokenSource.CreateLinkedTokenSource
    let v101 : System.Threading.CancellationTokenSource = v100 v99
    let v102 : System.Threading.CancellationToken = v101.Token
    return v102 
    }
    |&gt; fun x -&gt; _v95 &lt;- Some x
    let v103 : Async&lt;System.Threading.CancellationToken&gt; = _v95 |&gt; Option.get
    v103 
    #endif
    |&gt; fun x -&gt; _v89 &lt;- Some x
    let v104 : Async&lt;System.Threading.CancellationToken&gt; = _v89.Value
    v104 
    #endif
    |&gt; fun x -&gt; _v83 &lt;- Some x
    let v105 : Async&lt;System.Threading.CancellationToken&gt; = _v83.Value
    let! v105 = v105 
    let v106 : System.Threading.CancellationToken = v105 
    let v107 : ((unit -&gt; unit) -&gt; System.Threading.CancellationTokenRegistration) = v106.Register
    let v108 : (unit -&gt; unit) = closure47(v62)
    let v109 : System.Threading.CancellationTokenRegistration = v107 v108
    use v109 = v109 
    let v110 : System.Threading.CancellationTokenRegistration = v109 
    let v111 : bool = true
    let mutable _v111 : Async&lt;int32&gt; option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v112 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
    v112 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v113 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
    v113 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v114 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
    v114 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v115 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
    v115 
    #endif
#if FABLE_COMPILER_PYTHON
    let v116 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
    v116 
    #endif
#else
    let v117 : Async&lt;int32&gt; option = None
    let mutable _v117 = v117
    async {
    try
    let v118 : System.Threading.Tasks.Task = v62.WaitForExitAsync v106 
    let v119 : bool = true
    let mutable _v119 : Async&lt;unit&gt; option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v120 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v120 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v121 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v121 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v122 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v122 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v123 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v123 
    #endif
#if FABLE_COMPILER_PYTHON
    let v124 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v124 
    #endif
#else
    let v125 : (System.Threading.Tasks.Task -&gt; Async&lt;unit&gt;) = Async.AwaitTask
    let v126 : Async&lt;unit&gt; = v125 v118
    v126 
    #endif
    |&gt; fun x -&gt; _v119 &lt;- Some x
    let v127 : Async&lt;unit&gt; = _v119.Value
    do! v127 
    let v128 : int32 = v62.ExitCode
    return v128 
    with ex -&gt;
    let v129 : exn = ex
    let v130 : bool = true
    let mutable _v130 : string option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v131 : string = $"%A{v129}"
    v131 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v132 : string = $"%A{v129}"
    v132 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v133 : string = $"%A{v129}"
    v133 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v134 : string = $"%A{v129}"
    v134 
    #endif
#if FABLE_COMPILER_PYTHON
    let v135 : string = $"%A{v129}"
    v135 
    #endif
#else
    let v136 : string = $"{v129.GetType ()}: {v129.Message}"
    v136 
    #endif
    |&gt; fun x -&gt; _v130 &lt;- Some x
    let v137 : string = _v130.Value
    let v138 : (string -&gt; unit) = v64.Push
    v138 v137
    let v139 : System.Threading.Tasks.TaskCanceledException = v129 |&gt; unbox&lt;System.Threading.Tasks.TaskCanceledException&gt;
    let v140 : US0 = US0_3
    let v141 : (unit -&gt; string) = closure48(v139)
    let v142 : (unit -&gt; string) = method49()
    method3(v140, v141, v142)
    return -2147483648 
    (*
    *)
    }
    |&gt; fun x -&gt; _v117 &lt;- Some x
    let v143 : Async&lt;int32&gt; = _v117 |&gt; Option.get
    v143 
    #endif
    |&gt; fun x -&gt; _v111 &lt;- Some x
    let v144 : Async&lt;int32&gt; = _v111.Value
    let! v144 = v144 
    let v145 : int32 = v144 
    let v146 : (System.Collections.Concurrent.ConcurrentStack&lt;string&gt; -&gt; string seq) = Seq.rev
    let v147 : string seq = v146 v64
    let v148 : string = method50()
    let v149 : (string -&gt; (string seq -&gt; string)) = String.concat
    let v150 : (string seq -&gt; string) = v149 v148
    let v151 : string = v150 v147
    let v152 : US0 = US0_1
    let v153 : (unit -&gt; string) = closure49(v145, v151)
    let v154 : (unit -&gt; string) = method49()
    method3(v152, v153, v154)
    return struct (v145, v151) 
    }
    |&gt; fun x -&gt; _v18 &lt;- Some x
    let v155 : Async&lt;struct (int32 * string)&gt; = _v18 |&gt; Option.get
    v155 
    #endif
    |&gt; fun x -&gt; _v12 &lt;- Some x
    let v156 : Async&lt;struct (int32 * string)&gt; = _v12.Value
    v156 
    #endif
    |&gt; fun x -&gt; _v6 &lt;- Some x
    let v157 : Async&lt;struct (int32 * string)&gt; = _v6.Value
    v157
and method35 (v0 : System.Threading.CancellationToken option, v1 : string, v2 : (struct (string * string) []), v3 : (struct (bool * string * int32) -&gt; Async&lt;unit&gt;) option, v4 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) option, v5 : string option) : struct (int32 * string) =
    let v6 : bool = true
    let mutable _v6 : struct (int32 * string) option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v7 : string = method36(v0, v1, v2, v3, v4, v5)
    let struct (v8 : string, v9 : string) = method37()
    let v10 : int32 = v7.Length
    let v11 : (char []) = Array.zeroCreate&lt;char&gt; (v10)
    let v12 : Mut5 = {l0 = 0} : Mut5
    while method23(v10, v12) do
        let v14 : int32 = v12.l0
        let v15 : char = v7.[int v14]
        v11.[int v14] &lt;- v15
        let v16 : int32 = v14 + 1
        v12.l0 &lt;- v16
        ()
    let v17 : ((char []) -&gt; char list) = Array.toList
    let v18 : char list = v17 v11
    let v19 : ((char -&gt; (UH0 -&gt; UH0)) -&gt; (char list -&gt; (UH0 -&gt; UH0))) = List.foldBack
    let v20 : (char -&gt; (UH0 -&gt; UH0)) = method38()
    let v21 : (char list -&gt; (UH0 -&gt; UH0)) = v19 v20
    let v22 : (UH0 -&gt; UH0) = v21 v18
    let v23 : UH0 = UH0_0
    let v24 : UH0 = v22 v23
    let v25 : US7 = US7_0
    let struct (v26 : string, v27 : string) = method39(v9, v8, v24, v25)
    let v28 : (string []) = method40(v27)
    let v29 : string = "$0.to_vec()"
    let v30 : Vec&lt;string&gt; = Fable.Core.RustInterop.emitRustExpr v28 v29
    let v31 : string = "true; let _result = v30.into_iter().map(|x| { //"
    let v32 : bool = Fable.Core.RustInterop.emitRustExpr () v31
    let v33 : string = "x"
    let v34 : string = Fable.Core.RustInterop.emitRustExpr () v33
    let v35 : string = "&amp;*$0"
    let v36 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v34 v35
    let v37 : string = "String::from($0)"
    let v38 : std_string_String = Fable.Core.RustInterop.emitRustExpr v36 v37
    let v39 : string = "true; $0 }).collect()"
    let v40 : bool = Fable.Core.RustInterop.emitRustExpr v38 v39
    let v41 : string = "_result"
    let v42 : Vec&lt;std_string_String&gt; = Fable.Core.RustInterop.emitRustExpr () v41
    let v43 : US0 = US0_1
    let v44 : (unit -&gt; string) = closure25()
    let v45 : (unit -&gt; string) = closure26(v0, v1, v2, v3, v4, v5, v26, v42)
    method3(v43, v44, v45)
    let v46 : string = "let __result = Box::pin(async move { //"
    Fable.Core.RustInterop.emitRustExpr () v46
    let v47 : bool = true
    let mutable _v47 : (int32 * string) option = None 
    (
    (fun () -&gt;
    (fun () -&gt;
    let v48 : string = "std::process::Command::new(&amp;*$0)"
    let v49 : std_process_Command = Fable.Core.RustInterop.emitRustExpr v26 v48
    let v50 : string = "true; let mut v49 = v49"
    let v51 : bool = Fable.Core.RustInterop.emitRustExpr () v50
    let v52 : string = "std::process::Command::args(&amp;mut $0, &amp;*$1)"
    let v53 : Ref&lt;Mut&lt;std_process_Command&gt;&gt; = Fable.Core.RustInterop.emitRustExpr struct (v49, v42) v52
    let v54 : string = "std::process::Stdio::piped()"
    let v55 : std_process_Stdio = Fable.Core.RustInterop.emitRustExpr () v54
    let v56 : string = "std::process::Command::stdout($0, std::process::Stdio::piped())"
    let v57 : Ref&lt;Mut&lt;std_process_Command&gt;&gt; = Fable.Core.RustInterop.emitRustExpr v53 v56
    let v58 : string = "std::process::Stdio::piped()"
    let v59 : std_process_Stdio = Fable.Core.RustInterop.emitRustExpr () v58
    let v60 : string = "std::process::Command::stderr($0, std::process::Stdio::piped())"
    let v61 : Ref&lt;Mut&lt;std_process_Command&gt;&gt; = Fable.Core.RustInterop.emitRustExpr v57 v60
    let v62 : string = "std::process::Stdio::piped()"
    let v63 : std_process_Stdio = Fable.Core.RustInterop.emitRustExpr () v62
    let v64 : string = "std::process::Command::stdin($0, std::process::Stdio::piped())"
    let v65 : Ref&lt;Mut&lt;std_process_Command&gt;&gt; = Fable.Core.RustInterop.emitRustExpr v61 v64
    let v66 : US3 option = None
    let _v66 = ref v66 
    match v5 with
    | Some x -&gt; (
    (fun () -&gt;
    (fun () -&gt;
    let v67 : string = x
    let v68 : US3 = US3_0(v67)
    v68 
    )
    |&gt; fun x -&gt; x () |&gt; Some
    ) () ) | None -&gt; None
    |&gt; fun x -&gt; _v66.Value &lt;- x
    let v69 : US3 option = _v66.Value 
    let v70 : US3 = US3_1
    let v71 : US3 = v69 |&gt; Option.defaultValue v70 
    let v76 : Ref&lt;Mut&lt;std_process_Command&gt;&gt; =
        match v71 with
        | US3_1 -&gt; (* None *)
            v65
        | US3_0(v72) -&gt; (* Some *)
            let v73 : string = "std::process::Command::current_dir(v65, &amp;*$0)"
            let v74 : Ref&lt;Mut&lt;std_process_Command&gt;&gt; = Fable.Core.RustInterop.emitRustExpr v72 v73
            v74
    let v77 : uint64 = System.Convert.ToUInt64 v2.Length
    let v78 : bool = v77 = 0UL
    let v94 : Ref&lt;Mut&lt;std_process_Command&gt;&gt; =
        if v78 then
            v76
        else
            let v79 : string = "$0.to_vec()"
            let v80 : Vec&lt;struct (string * string)&gt; = Fable.Core.RustInterop.emitRustExpr v2 v79
            let v81 : string = "true; let _result = $0.into_iter().fold(v76, |acc, x| { //"
            let v82 : bool = Fable.Core.RustInterop.emitRustExpr v80 v81
            let v83 : string = "acc"
            let v84 : Ref&lt;Mut&lt;std_process_Command&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v83
            let v85 : string = "x"
            let struct (v86 : string, v87 : string) = Fable.Core.RustInterop.emitRustExpr () v85
            let v88 : string = "std::process::Command::env(v84, &amp;*$0, &amp;*$1)"
            let v89 : Ref&lt;Mut&lt;std_process_Command&gt;&gt; = Fable.Core.RustInterop.emitRustExpr struct (v86, v87) v88
            let v90 : string = "true; $0 })"
            let v91 : bool = Fable.Core.RustInterop.emitRustExpr v89 v90
            let v92 : string = "_result"
            let v93 : Ref&lt;Mut&lt;std_process_Command&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v92
            v93
    let v95 : string = "std::process::Command::spawn($0)"
    let v96 : Result&lt;std_process_Child, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr v94 v95
    let v97 : (std_io_Error -&gt; std_string_String) = method29()
    let v98 : string = "$0.map_err(|x| $1(x))"
    let v99 : Result&lt;std_process_Child, std_string_String&gt; = Fable.Core.RustInterop.emitRustExpr struct (v96, v97) v98
    let v100 : string = "true; let _result = $0.map(|x| { //"
    let v101 : bool = Fable.Core.RustInterop.emitRustExpr v99 v100
    let v102 : string = "x"
    let v103 : std_process_Child = Fable.Core.RustInterop.emitRustExpr () v102
    let v104 : std_process_Child option = Some v103 
    let v105 : string = "std::sync::Mutex::new($0)"
    let v106 : std_sync_Mutex&lt;std_process_Child option&gt; = Fable.Core.RustInterop.emitRustExpr v104 v105
    let v107 : string = "std::sync::Arc::new($0)"
    let v108 : std_sync_Arc&lt;std_sync_Mutex&lt;std_process_Child option&gt;&gt; = Fable.Core.RustInterop.emitRustExpr v106 v107
    let v109 : string = "true; $0 })"
    let v110 : bool = Fable.Core.RustInterop.emitRustExpr v108 v109
    let v111 : string = "_result"
    let v112 : Result&lt;std_sync_Arc&lt;std_sync_Mutex&lt;std_process_Child option&gt;&gt;, std_string_String&gt; = Fable.Core.RustInterop.emitRustExpr () v111
    let v113 : string = "match v112 { Ok(x) =&gt; $0(x), Err(e) =&gt; $1(e) }"
    let v114 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_Child option&gt;&gt; -&gt; US10) = closure27()
    let v115 : (std_string_String -&gt; US10) = closure28()
    let v116 : US10 = Fable.Core.RustInterop.emitRustExpr struct (v114, v115) v113
    let struct (v266 : int32, v267 : US2, v268 : US11) =
        match v116 with
        | US10_1(v257) -&gt; (* Error *)
            let v258 : US0 = US0_4
            let v259 : (unit -&gt; string) = closure29()
            let v260 : (unit -&gt; string) = closure30(v257)
            method3(v258, v259, v260)
            let v261 : US2 = US2_0(v257)
            let v262 : US11 = US11_1
            struct (-1, v261, v262)
        | US10_0(v117) -&gt; (* Ok *)
            let v118 : string = "$0.lock().unwrap().as_mut().unwrap().stdout.take().unwrap()"
            let v119 : std_process_ChildStdout = Fable.Core.RustInterop.emitRustExpr v117 v118
            let v120 : string = "$0.lock().unwrap().as_mut().unwrap().stderr.take().unwrap()"
            let v121 : std_process_ChildStderr = Fable.Core.RustInterop.emitRustExpr v117 v120
            let v122 : string = "$0.lock().unwrap().as_mut().unwrap().stdin.take().unwrap()"
            let v123 : std_process_ChildStdin = Fable.Core.RustInterop.emitRustExpr v117 v122
            let v124 : std_process_ChildStdout option = Some v119 
            let v125 : string = "std::sync::Mutex::new($0)"
            let v126 : std_sync_Mutex&lt;std_process_ChildStdout option&gt; = Fable.Core.RustInterop.emitRustExpr v124 v125
            let v127 : string = "std::sync::Arc::new($0)"
            let v128 : std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdout option&gt;&gt; = Fable.Core.RustInterop.emitRustExpr v126 v127
            let v129 : std_process_ChildStderr option = Some v121 
            let v130 : string = "std::sync::Mutex::new($0)"
            let v131 : std_sync_Mutex&lt;std_process_ChildStderr option&gt; = Fable.Core.RustInterop.emitRustExpr v129 v130
            let v132 : string = "std::sync::Arc::new($0)"
            let v133 : std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStderr option&gt;&gt; = Fable.Core.RustInterop.emitRustExpr v131 v132
            let v134 : std_process_ChildStdin option = Some v123 
            let v135 : string = "std::sync::Mutex::new($0)"
            let v136 : std_sync_Mutex&lt;std_process_ChildStdin option&gt; = Fable.Core.RustInterop.emitRustExpr v134 v135
            let v137 : string = "std::sync::Arc::new($0)"
            let v138 : std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin option&gt;&gt; = Fable.Core.RustInterop.emitRustExpr v136 v137
            let v139 : string = "{ let (sender, receiver) = std::sync::mpsc::channel(); (sender, std::sync::Arc::new(receiver)) }"
            let struct (v140 : std_sync_mpsc_Sender&lt;std_string_String&gt;, v141 : std_sync_Arc&lt;std_sync_mpsc_Receiver&lt;std_string_String&gt;&gt;) = Fable.Core.RustInterop.emitRustExpr () v139
            let v142 : std_sync_Arc&lt;std_sync_mpsc_Receiver&lt;std_string_String&gt;&gt; = method45(v141)
            let v143 : string = "true; let v142 = v142"
            let v144 : bool = Fable.Core.RustInterop.emitRustExpr v142 v143
            let v145 : string = "std::sync::Mutex::new($0)"
            let v146 : std_sync_Mutex&lt;std_sync_mpsc_Sender&lt;std_string_String&gt;&gt; = Fable.Core.RustInterop.emitRustExpr v140 v145
            let v147 : string = "std::sync::Arc::new($0)"
            let v148 : std_sync_Arc&lt;std_sync_Mutex&lt;std_sync_mpsc_Sender&lt;std_string_String&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr v146 v147
            let v149 : string = "v148.clone()"
            let v150 : std_sync_Arc&lt;std_sync_Mutex&lt;std_sync_mpsc_Sender&lt;std_string_String&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v149
            let v151 : string = "v148.clone()"
            let v152 : std_sync_Arc&lt;std_sync_Mutex&lt;std_sync_mpsc_Sender&lt;std_string_String&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v151
            let v153 : string = "std::sync::Mutex::new($0)"
            let v154 : std_sync_Mutex&lt;std_sync_Arc&lt;std_sync_mpsc_Receiver&lt;std_string_String&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr v142 v153
            let v155 : string = "std::sync::Arc::new($0)"
            let v156 : std_sync_Arc&lt;std_sync_Mutex&lt;std_sync_Arc&lt;std_sync_mpsc_Receiver&lt;std_string_String&gt;&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr v154 v155
            let v157 : string = "std::thread::spawn(move || { //"
            let v158 : std_thread_JoinHandle&lt;unit&gt; = Fable.Core.RustInterop.emitRustExpr () v157
            let v159 : string = "v128.lock().unwrap().take().unwrap()"
            let v160 : std_process_ChildStdout = Fable.Core.RustInterop.emitRustExpr () v159
            let v161 : string = "encoding_rs_io::DecodeReaderBytesBuilder::new().utf8_passthru(true).build(v160)"
            let v162 : encoding_rs_io_DecodeReaderBytes&lt;std_process_ChildStdout, Vec&lt;uint8&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v161
            let v163 : string = "std::io::BufReader::new(v162)"
            let v164 : std_io_BufReader&lt;encoding_rs_io_DecodeReaderBytes&lt;std_process_ChildStdout, Vec&lt;uint8&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v163
            let v165 : string = "std::sync::Mutex::new($0)"
            let v166 : std_sync_Mutex&lt;std_io_BufReader&lt;encoding_rs_io_DecodeReaderBytes&lt;std_process_ChildStdout, Vec&lt;uint8&gt;&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr v164 v165
            let v167 : string = "std::sync::Arc::new($0)"
            let v168 : std_sync_Arc&lt;std_sync_Mutex&lt;std_io_BufReader&lt;encoding_rs_io_DecodeReaderBytes&lt;std_process_ChildStdout, Vec&lt;uint8&gt;&gt;&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr v166 v167
            let v169 : string = "true; for line in std::io::BufRead::lines(std::io::Read::by_ref(&amp;mut *$0.lock().unwrap())).collect::&lt;Vec&lt;_&gt;&gt;() { $1(line) }"
            let v170 : (Result&lt;std_string_String, std_io_Error&gt; -&gt; unit) = closure31(v150)
            let v171 : bool = Fable.Core.RustInterop.emitRustExpr struct (v168, v170) v169
            let v172 : string = "true; })"
            let v173 : bool = Fable.Core.RustInterop.emitRustExpr () v172
            let v174 : string = "std::thread::spawn(move || { //"
            let v175 : std_thread_JoinHandle&lt;unit&gt; = Fable.Core.RustInterop.emitRustExpr () v174
            let v176 : string = "v133.lock().unwrap().take().unwrap()"
            let v177 : std_process_ChildStderr = Fable.Core.RustInterop.emitRustExpr () v176
            let v178 : string = "encoding_rs_io::DecodeReaderBytesBuilder::new().utf8_passthru(true).build(v177)"
            let v179 : encoding_rs_io_DecodeReaderBytes&lt;std_process_ChildStderr, Vec&lt;uint8&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v178
            let v180 : string = "std::io::BufReader::new(v179)"
            let v181 : std_io_BufReader&lt;encoding_rs_io_DecodeReaderBytes&lt;std_process_ChildStderr, Vec&lt;uint8&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v180
            let v182 : string = "std::sync::Mutex::new($0)"
            let v183 : std_sync_Mutex&lt;std_io_BufReader&lt;encoding_rs_io_DecodeReaderBytes&lt;std_process_ChildStderr, Vec&lt;uint8&gt;&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr v181 v182
            let v184 : string = "std::sync::Arc::new($0)"
            let v185 : std_sync_Arc&lt;std_sync_Mutex&lt;std_io_BufReader&lt;encoding_rs_io_DecodeReaderBytes&lt;std_process_ChildStderr, Vec&lt;uint8&gt;&gt;&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr v183 v184
            let v186 : string = "true; for line in std::io::BufRead::lines(std::io::Read::by_ref(&amp;mut *$0.lock().unwrap())).collect::&lt;Vec&lt;_&gt;&gt;() { $1(line) }"
            let v187 : (Result&lt;std_string_String, std_io_Error&gt; -&gt; unit) = closure31(v148)
            let v188 : bool = Fable.Core.RustInterop.emitRustExpr struct (v185, v187) v186
            let v189 : string = "true; })"
            let v190 : bool = Fable.Core.RustInterop.emitRustExpr () v189
            let v191 : US13 option = None
            let _v191 = ref v191 
            match v4 with
            | Some x -&gt; (
            (fun () -&gt;
            (fun () -&gt;
            let v192 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) = x
            let v193 : US13 = US13_0(v192)
            v193 
            )
            |&gt; fun x -&gt; x () |&gt; Some
            ) () ) | None -&gt; None
            |&gt; fun x -&gt; _v191.Value &lt;- x
            let v194 : US13 option = _v191.Value 
            let v195 : US13 = US13_1
            let v196 : US13 = v194 |&gt; Option.defaultValue v195 
            match v196 with
            | US13_1 -&gt; (* None *)
                ()
            | US13_0(v197) -&gt; (* Some *)
                let v198 : string = "v138.lock().unwrap().take()"
                let v199 : std_process_ChildStdin option = Fable.Core.RustInterop.emitRustExpr () v198
                let v200 : string = "true; let _result = v199.map(|x| { //"
                let v201 : bool = Fable.Core.RustInterop.emitRustExpr () v200
                let v202 : string = "x"
                let v203 : std_process_ChildStdin = Fable.Core.RustInterop.emitRustExpr () v202
                let v204 : string = "std::sync::Mutex::new($0)"
                let v205 : std_sync_Mutex&lt;std_process_ChildStdin&gt; = Fable.Core.RustInterop.emitRustExpr v203 v204
                let v206 : string = "std::sync::Arc::new($0)"
                let v207 : std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; = Fable.Core.RustInterop.emitRustExpr v205 v206
                let v208 : string = "true; $0 })"
                let v209 : bool = Fable.Core.RustInterop.emitRustExpr v207 v208
                let v210 : string = "_result"
                let v211 : std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; option = Fable.Core.RustInterop.emitRustExpr () v210
                let v212 : US14 option = None
                let _v212 = ref v212 
                match v211 with
                | Some x -&gt; (
                (fun () -&gt;
                (fun () -&gt;
                let v213 : std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; = x
                let v214 : US14 = US14_0(v213)
                v214 
                )
                |&gt; fun x -&gt; x () |&gt; Some
                ) () ) | None -&gt; None
                |&gt; fun x -&gt; _v212.Value &lt;- x
                let v215 : US14 option = _v212.Value 
                let v216 : US14 = US14_1
                let v217 : US14 = v215 |&gt; Option.defaultValue v216 
                match v217 with
                | US14_1 -&gt; (* None *)
                    ()
                | US14_0(v218) -&gt; (* Some *)
                    v197 v218
                    let v219 : string = "$0.lock()"
                    let v220 : Result&lt;std_sync_MutexGuard&lt;std_process_ChildStdin&gt;, std_sync_PoisonError&lt;std_sync_MutexGuard&lt;std_process_ChildStdin&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr v218 v219
                    let v221 : string = "$0.unwrap()"
                    let v222 : std_sync_MutexGuard&lt;std_process_ChildStdin&gt; = Fable.Core.RustInterop.emitRustExpr v220 v221
                    let v223 : std_sync_MutexGuard&lt;std_process_ChildStdin&gt; = method46(v222)
                    let v224 : string = "true; let mut v223 = v223"
                    let v225 : bool = Fable.Core.RustInterop.emitRustExpr () v224
                    let v226 : string = "true; std::io::Write::flush(&amp;mut *$0).unwrap()"
                    let v227 : bool = Fable.Core.RustInterop.emitRustExpr v223 v226
                    ()
            let v228 : string = "$0.lock().unwrap().take().unwrap().wait_with_output()"
            let v229 : Result&lt;std_process_Output, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr v117 v228
            let v230 : (std_io_Error -&gt; std_string_String) = method29()
            let v231 : string = "$0.map_err(|x| $1(x))"
            let v232 : Result&lt;std_process_Output, std_string_String&gt; = Fable.Core.RustInterop.emitRustExpr struct (v229, v230) v231
            let v233 : string = "true; v158.join().unwrap()"
            let v234 : bool = Fable.Core.RustInterop.emitRustExpr () v233
            let v235 : string = "true; v175.join().unwrap()"
            let v236 : bool = Fable.Core.RustInterop.emitRustExpr () v235
            let v237 : (std_process_Output -&gt; US15) = closure37()
            let v238 : (std_string_String -&gt; US15) = closure38()
            let v239 : US15 = match v232 with Ok x -&gt; v237 x | Error x -&gt; v238 x
            match v239 with
            | US15_1(v245) -&gt; (* Error *)
                let v246 : US0 = US0_4
                let v247 : (unit -&gt; string) = closure39()
                let v248 : (unit -&gt; string) = closure40(v245)
                method3(v246, v247, v248)
                let v249 : US2 = US2_0(v245)
                let v250 : US11 = US11_1
                struct (-2, v249, v250)
            | US15_0(v240) -&gt; (* Ok *)
                let v241 : string = "$0.status.code().unwrap()"
                let v242 : int32 = Fable.Core.RustInterop.emitRustExpr v240 v241
                let v243 : US2 = US2_1
                let v244 : US11 = US11_0(v156)
                struct (v242, v243, v244)
    let v275 : US2 =
        match v268 with
        | US11_1 -&gt; (* None *)
            US2_1
        | US11_0(v269) -&gt; (* Some *)
            let v270 : string = "$0.lock().unwrap().iter().collect::&lt;Vec&lt;String&gt;&gt;().join(\"\\n\")"
            let v271 : std_string_String = Fable.Core.RustInterop.emitRustExpr v269 v270
            US2_0(v271)
    let v282 : US3 =
        match v275 with
        | US2_1 -&gt; (* None *)
            US3_1
        | US2_0(v276) -&gt; (* Some *)
            let v277 : string = "fable_library_rust::String_::fromString($0)"
            let v278 : string = Fable.Core.RustInterop.emitRustExpr v276 v277
            US3_0(v278)
    let v289 : US3 =
        match v267 with
        | US2_1 -&gt; (* None *)
            US3_1
        | US2_0(v283) -&gt; (* Some *)
            let v284 : string = "fable_library_rust::String_::fromString($0)"
            let v285 : string = Fable.Core.RustInterop.emitRustExpr v283 v284
            US3_0(v285)
    let v293 : string =
        match v289 with
        | US3_1 -&gt; (* None *)
            let v291 : string = ""
            v291
        | US3_0(v290) -&gt; (* Some *)
            v290
    let v296 : string =
        match v282 with
        | US3_1 -&gt; (* None *)
            v293
        | US3_0(v294) -&gt; (* Some *)
            v294
    let v297 : US0 = US0_0
    let v298 : (unit -&gt; string) = closure41()
    let v299 : (unit -&gt; string) = closure42(v266, v296)
    method3(v297, v298, v299)
    let v300 : (int32 * string) = v266, v296
    v300 
    )
    |&gt; fun x -&gt; x ()
    ) () )
    |&gt; fun x -&gt; _v47 &lt;- Some x
    let v301 : (int32 * string) = _v47.Value 
    let v302 : (int32 * string) = method47(v301)
    let v303 : string = "v302 }}})"
    Fable.Core.RustInterop.emitRustExpr () v303
    let v304 : string = "{{ //"
    Fable.Core.RustInterop.emitRustExpr () v304
    let v305 : string = "__result"
    let v306 : std_pin_Pin&lt;Box&lt;Dyn&lt;std_future_Future&lt;(int32 * string)&gt;&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v305
    let v307 : string = "futures_lite::future::block_on($0)"
    let v308 : (int32 * string) = Fable.Core.RustInterop.emitRustExpr v306 v307
    let (a, b) = v308
    let v309 : int32 = a
    let v310 : string = b
    struct (v309, v310) 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let struct (v311 : int32, v312 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v311, v312) 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let struct (v313 : int32, v314 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v313, v314) 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let struct (v315 : int32, v316 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v315, v316) 
    #endif
#if FABLE_COMPILER_PYTHON
    let struct (v317 : int32, v318 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v317, v318) 
    #endif
#else
    let v319 : Async&lt;struct (int32 * string)&gt; = method48(v0, v1, v2, v3, v4, v5)
    let v320 : bool = true
    let mutable _v320 : struct (int32 * string) option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let struct (v321 : int32, v322 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v321, v322) 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let struct (v323 : int32, v324 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v323, v324) 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let struct (v325 : int32, v326 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v325, v326) 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let struct (v327 : int32, v328 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v327, v328) 
    #endif
#if FABLE_COMPILER_PYTHON
    let struct (v329 : int32, v330 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v329, v330) 
    #endif
#else
    let v331 : (Async&lt;struct (int32 * string)&gt; -&gt; struct (int32 * string)) = Async.RunSynchronously
    let struct (v332 : int32, v333 : string) = v331 v319
    struct (v332, v333) 
    #endif
    |&gt; fun x -&gt; _v320 &lt;- Some x
    let struct (v334 : int32, v335 : string) = _v320.Value
    struct (v334, v335) 
    #endif
    |&gt; fun x -&gt; _v6 &lt;- Some x
    let struct (v336 : int32, v337 : string) = _v6.Value
    struct (v336, v337)
and method51 (v0 : string, v1 : string, v2 : string) : struct (string * string) =
    let v3 : bool = true
    let mutable _v3 : string option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v4 : string = "&amp;*$0"
    let v5 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v1 v4
    let v6 : string = "String::from($0)"
    let v7 : std_string_String = Fable.Core.RustInterop.emitRustExpr v5 v6
    let v8 : string = "std::path::PathBuf::from($0)"
    let v9 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v7 v8
    let v10 : string = "$0.file_name()"
    let v11 : Ref&lt;std_ffi_OsStr&gt; option = Fable.Core.RustInterop.emitRustExpr v9 v10
    let v12 : string = "$0.unwrap()"
    let v13 : Ref&lt;std_ffi_OsStr&gt; = Fable.Core.RustInterop.emitRustExpr v11 v12
    let v14 : string = "$0.to_os_string()"
    let v15 : std_ffi_OsString = Fable.Core.RustInterop.emitRustExpr v13 v14
    let v16 : string = "$0.to_str()"
    let v17 : Ref&lt;Str&gt; option = Fable.Core.RustInterop.emitRustExpr v15 v16
    let v18 : string = "$0.unwrap()"
    let v19 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v17 v18
    let v20 : string = "String::from($0)"
    let v21 : std_string_String = Fable.Core.RustInterop.emitRustExpr v19 v20
    let v22 : string = "fable_library_rust::String_::fromString($0)"
    let v23 : string = Fable.Core.RustInterop.emitRustExpr v21 v22
    v23 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v24 : string = null |&gt; unbox&lt;string&gt;
    v24 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v25 : string = null |&gt; unbox&lt;string&gt;
    v25 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v26 : string = null |&gt; unbox&lt;string&gt;
    v26 
    #endif
#if FABLE_COMPILER_PYTHON
    let v27 : string = null |&gt; unbox&lt;string&gt;
    v27 
    #endif
#else
    let v28 : (string -&gt; string) = System.IO.Path.GetFileName
    let v29 : string = v28 v1
    v29 
    #endif
    |&gt; fun x -&gt; _v3 &lt;- Some x
    let v30 : string = _v3.Value
    let v31 : string = method11(v2, v30)
    let v32 : string = "."
    let v33 : int32 = v1.LastIndexOf v32
    let v34 : int32 = v33 - 1
    let v35 : string = v1.[int 0..int v34]
    let v36 : int32 = v31.LastIndexOf v32
    let v37 : int32 = v36 - 1
    let v38 : string = v31.[int 0..int v37]
    let v39 : string = ".md"
    let v40 : bool = v0.EndsWith v39
    let v41 : bool = v40 = false
    let v44 : string =
        if v41 then
            let v42 : string = $"{v1}.{v0}"
            v42
        else
            let v43 : string = $"{v35}.{v0}"
            v43
    let v47 : string =
        if v41 then
            let v45 : string = $"{v31}.{v0}"
            v45
        else
            let v46 : string = $"{v38}.{v0}"
            v46
    struct (v47, v44)
and closure50 () (v0 : uint8) : string =
    let v1 : string = "{:02x}"
    let v2 : string = "format!(\"" + v1 + "\", $0)"
    let v3 : std_string_String = Fable.Core.RustInterop.emitRustExpr v0 v2
    let v4 : string = "fable_library_rust::String_::fromString($0)"
    let v5 : string = Fable.Core.RustInterop.emitRustExpr v3 v4
    v5
and method52 () : string =
    let v0 : string = ""
    v0
and closure51 () () : string =
    let v0 : string = "documents.run / par_map / origin_hash |&gt; sm'.contains local_git_hash |&gt; not / hash2 = None || hash1 &lt;&gt;. (hash2 |&gt; optionm.value)"
    v0
and closure52 (v0 : string, v1 : string, v2 : string, v3 : string, v4 : int32, v5 : string, v6 : string, v7 : int32, v8 : string, v9 : string, v10 : US3) () : string =
    let v11 : (unit -&gt; string) = closure6()
    let v12 : string = $"file: {v1} / real_path: {v2} / relative_path: {v0} / origin_hash_exit_code: {v4} / origin_hash: {v3} / local_git_hash_exit_code: {v7} / local_git_hash: {v6} / hash1: {v9} / hash2: %A{v10} / dist_path: {v5} / cache_path: {v8} / {v11 ()}"
    v12
and method53 (v0 : string) : string =
    v0
and method55 (v0 : int32, v1 : Mut6) : bool =
    let v2 : int32 = v1.l0
    let v3 : bool = v2 &lt; v0
    v3
and method56 (v0 : string) : string =
    v0
and method57 (v0 : std_sync_MutexGuard&lt;std_process_ChildStdin&gt;) : std_sync_MutexGuard&lt;std_process_ChildStdin&gt; =
    v0
and closure55 (v0 : string) (v1 : std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt;) : unit =
    let v2 : string = "$0.lock()"
    let v3 : Result&lt;std_sync_MutexGuard&lt;std_process_ChildStdin&gt;, std_sync_PoisonError&lt;std_sync_MutexGuard&lt;std_process_ChildStdin&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr v1 v2
    let v4 : string = "$0.unwrap()"
    let v5 : std_sync_MutexGuard&lt;std_process_ChildStdin&gt; = Fable.Core.RustInterop.emitRustExpr v3 v4
    let v6 : string = method56(v0)
    let v7 : string = "v6.as_bytes()"
    let v8 : Ref&lt;Slice&lt;uint8&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v7
    let v9 : std_sync_MutexGuard&lt;std_process_ChildStdin&gt; = method57(v5)
    let v10 : string = "true; let mut v9 = v9"
    let v11 : bool = Fable.Core.RustInterop.emitRustExpr () v10
    let v12 : string = "true; std::io::Write::write_all(&amp;mut *$0, v8).unwrap()"
    let v13 : bool = Fable.Core.RustInterop.emitRustExpr v9 v12
    ()
and method58 (v0 : int32, v1 : Mut7) : bool =
    let v2 : int32 = v1.l0
    let v3 : bool = v2 &lt; v0
    v3
and method59 (v0 : string) : string =
    v0
and closure56 () () : string =
    let v0 : string = "documents.hangul"
    v0
and closure57 (v0 : string, v1 : int32, v2 : string) () : string =
    let v3 : int32 = v2.Length
    let v4 : (unit -&gt; string) = closure6()
    let v5 : string = $"exit_code: %A{v1} / result_len: {v3} / output_path: {v0} / {v4 ()}"
    v5
and method54 (v0 : string, v1 : string, v2 : string, v3 : string) : US19 =
    let v4 : bool = true
    let mutable _v4 : string option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v5 : bool = true
    let mutable _v5 : Vec&lt;uint8&gt; option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v6 : string = "std::fs::read(&amp;*$0).unwrap()"
    let v7 : Vec&lt;uint8&gt; = Fable.Core.RustInterop.emitRustExpr v3 v6
    v7 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v8 : Vec&lt;uint8&gt; = null |&gt; unbox&lt;Vec&lt;uint8&gt;&gt;
    v8 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v9 : Vec&lt;uint8&gt; = null |&gt; unbox&lt;Vec&lt;uint8&gt;&gt;
    v9 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v10 : Vec&lt;uint8&gt; = null |&gt; unbox&lt;Vec&lt;uint8&gt;&gt;
    v10 
    #endif
#if FABLE_COMPILER_PYTHON
    let v11 : Vec&lt;uint8&gt; = null |&gt; unbox&lt;Vec&lt;uint8&gt;&gt;
    v11 
    #endif
#else
    let v12 : (uint8 []) = v3 |&gt; System.IO.File.ReadAllBytes
    let v13 : string = "$0.to_vec()"
    let v14 : Vec&lt;uint8&gt; = Fable.Core.RustInterop.emitRustExpr v12 v13
    v14 
    #endif
    |&gt; fun x -&gt; _v5 &lt;- Some x
    let v15 : Vec&lt;uint8&gt; = _v5.Value
    let v16 : string = "std::string::String::from_utf8(v15)"
    let v17 : Result&lt;std_string_String, std_string_FromUtf8Error&gt; = Fable.Core.RustInterop.emitRustExpr () v16
    let v18 : string = "$0.unwrap()"
    let v19 : std_string_String = Fable.Core.RustInterop.emitRustExpr v17 v18
    let v20 : string = "fable_library_rust::String_::fromString($0)"
    let v21 : string = Fable.Core.RustInterop.emitRustExpr v19 v20
    v21 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v22 : string = null |&gt; unbox&lt;string&gt;
    v22 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v23 : string = null |&gt; unbox&lt;string&gt;
    v23 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v24 : string = null |&gt; unbox&lt;string&gt;
    v24 
    #endif
#if FABLE_COMPILER_PYTHON
    let v25 : string = null |&gt; unbox&lt;string&gt;
    v25 
    #endif
#else
    let v26 : string = v3 |&gt; System.IO.File.ReadAllText
    v26 
    #endif
    |&gt; fun x -&gt; _v4 &lt;- Some x
    let v27 : string = _v4.Value
    let v28 : string = "\n"
    let v29 : (string []) = v27.Split v28
    let v30 : int32 = v29.Length
    let v31 : (string []) = Array.zeroCreate&lt;string&gt; (v30)
    let v32 : Mut5 = {l0 = 0} : Mut5
    while method23(v30, v32) do
        let v34 : int32 = v32.l0
        let v35 : string = v29.[int v34]
        let v36 : string = v35.Trim ()
        v31.[int v34] &lt;- v36
        let v37 : int32 = v34 + 1
        v32.l0 &lt;- v37
        ()
    let v38 : int32 = v31.Length
    let v39 : (string []) = Array.zeroCreate&lt;string&gt; (v38)
    let v40 : Mut6 = {l0 = 0; l1 = 0} : Mut6
    while method55(v38, v40) do
        let v42 : int32 = v40.l0
        let v43 : int32 = v40.l1
        let v44 : string = v31.[int v42]
        let v45 : string = ""
        let v46 : bool = v45 &lt;&gt; v44
        let v48 : int32 =
            if v46 then
                v39.[int v43] &lt;- v44
                let v47 : int32 = v43 + 1
                v47
            else
                v43
        let v49 : int32 = v42 + 1
        v40.l0 &lt;- v49
        v40.l1 &lt;- v48
        ()
    let v50 : int32 = v40.l1
    let v51 : (string []) = Array.zeroCreate&lt;string&gt; (v50)
    let v52 : Mut5 = {l0 = 0} : Mut5
    while method23(v50, v52) do
        let v54 : int32 = v52.l0
        let v55 : string = v39.[int v54]
        v51.[int v54] &lt;- v55
        let v56 : int32 = v54 + 1
        v52.l0 &lt;- v56
        ()
    let v57 : string seq = seq { for i = 0 to v51.Length - 1 do yield v51.[i] }
    let v58 : string = method50()
    let v59 : (string -&gt; (string seq -&gt; string)) = String.concat
    let v60 : (string seq -&gt; string) = v59 v58
    let v61 : string = v60 v57
    let v62 : string = $"{v61}

"
    let v63 : string option = None
    let v64 : System.Threading.CancellationToken option = None
    let v65 : (struct (string * string) []) = [||]
    let v66 : (struct (bool * string * int32) -&gt; Async&lt;unit&gt;) option = None
    let v67 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) option = None
    let v68 : bool = true
    let mutable _v68 : bool option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v69 : string = "cfg!(windows)"
    let v70 : bool = Fable.Core.RustInterop.emitRustExpr () v69
    v70 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v71 : bool = null |&gt; unbox&lt;bool&gt;
    v71 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v72 : bool = null |&gt; unbox&lt;bool&gt;
    v72 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v73 : bool = null |&gt; unbox&lt;bool&gt;
    v73 
    #endif
#if FABLE_COMPILER_PYTHON
    let v74 : bool = null |&gt; unbox&lt;bool&gt;
    v74 
    #endif
#else
    let v75 : System.Runtime.InteropServices.OSPlatform = System.Runtime.InteropServices.OSPlatform.Windows
    let v76 : (System.Runtime.InteropServices.OSPlatform -&gt; bool) = System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform
    let v77 : bool = v76 v75
    v77 
    #endif
    |&gt; fun x -&gt; _v68 &lt;- Some x
    let v78 : bool = _v68.Value
    let v81 : string =
        if v78 then
            let v79 : string = ".exe"
            v79
        else
            let v80 : string = ""
            v80
    let v82 : string = $"../vault/deps/hangulize/cmd/hangulize/hangulize{v81}"
    let v83 : string = method11(v0, v82)
    let v84 : string = $"{v83} {v1}"
    let v85 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) = closure55(v62)
    let v86 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) option = Some v85 
    let struct (v87 : int32, v88 : string) = method35(v64, v84, v65, v66, v86, v63)
    let v89 : (string []) = v88.Split v28
    let v90 : int32 = v89.Length
    let v91 : string = ""
    let v92 : Mut7 = {l0 = 0; l1 = v91; l2 = 0; l3 = 0} : Mut7
    while method58(v38, v92) do
        let v94 : int32 = v92.l0
        let struct (v95 : string, v96 : int32, v97 : int32) = v92.l1, v92.l2, v92.l3
        let v98 : string = v31.[int v94]
        let v99 : bool = v98 = ""
        let struct (v113 : string, v114 : int32, v115 : int32) =
            if v99 then
                let v100 : string = $"{v95}
"
                let v101 : int32 = v96 + 1
                let v102 : int32 = v97 + 1
                struct (v100, v101, v102)
            else
                let v103 : int32 = v96 - v97
                let v104 : bool = v103 &gt;= v90
                let v111 : string =
                    if v104 then
                        v95
                    else
                        let v105 : string = v89.[int v103]
                        let v106 : int32 = v90 - 1
                        let v107 : bool = v103 = v106
                        if v107 then
                            let v108 : string = $"{v95}{v105}"
                            v108
                        else
                            let v109 : string = $"{v95}{v105}
"
                            v109
                let v112 : int32 = v96 + 1
                struct (v111, v112, v97)
        let v116 : int32 = v94 + 1
        v92.l0 &lt;- v116
        v92.l1 &lt;- v113
        v92.l2 &lt;- v114
        v92.l3 &lt;- v115
        ()
    let struct (v117 : string, v118 : int32, v119 : int32) = v92.l1, v92.l2, v92.l3
    let v120 : bool = true
    let mutable _v120 : unit option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v121 : string = "std::fs::write(&amp;*$0, &amp;*$1).unwrap()"
    Fable.Core.RustInterop.emitRustExpr struct (v2, v117) v121
    () 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    null |&gt; unbox&lt;unit&gt;
    () 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    null |&gt; unbox&lt;unit&gt;
    () 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    null |&gt; unbox&lt;unit&gt;
    () 
    #endif
#if FABLE_COMPILER_PYTHON
    null |&gt; unbox&lt;unit&gt;
    () 
    #endif
#else
    let v122 : string = method59(v117)
    System.IO.File.WriteAllText (v2, v122)
    () 
    #endif
    |&gt; fun x -&gt; _v120 &lt;- Some x
    _v120.Value
    let v123 : US0 = US0_2
    let v124 : (unit -&gt; string) = closure56()
    let v125 : (unit -&gt; string) = closure57(v2, v87, v117)
    method3(v123, v124, v125)
    US19_0(v87, v117)
and closure58 () () : string =
    let v0 : string = "documents.files_fn / error"
    v0
and closure59 (v0 : string, v1 : int32) () : string =
    let v2 : (unit -&gt; string) = closure6()
    let v3 : string = $"exit_code: %A{v1} / result: {v0} / {v2 ()}"
    v3
and closure54 (v0 : string, v1 : string, v2 : string, v3 : string, v4 : string) (v5 : string) : US18 =
    let struct (v6 : string, v7 : string) = method51(v5, v4, v0)
    let v8 : bool = true
    let mutable _v8 : bool option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v9 : string = "&amp;*$0"
    let v10 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v7 v9
    let v11 : string = "String::from($0)"
    let v12 : std_string_String = Fable.Core.RustInterop.emitRustExpr v10 v11
    let v13 : string = "std::path::PathBuf::from($0)"
    let v14 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v12 v13
    let v15 : string = "$0.exists()"
    let v16 : bool = Fable.Core.RustInterop.emitRustExpr v14 v15
    let v19 : bool =
        if v16 then
            let v17 : string = "$0.is_file()"
            let v18 : bool = Fable.Core.RustInterop.emitRustExpr v14 v17
            v18
        else
            false
    v19 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v20 : bool = null |&gt; unbox&lt;bool&gt;
    v20 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v21 : bool = null |&gt; unbox&lt;bool&gt;
    v21 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v22 : string = "fs"
    let v23 : IFsExistsSync = Fable.Core.JsInterop.importAll v22
    let v24 : string = "$0.existsSync($1)"
    let v25 : bool = Fable.Core.JsInterop.emitJsExpr struct (v23, v7) v24
    v25 
    #endif
#if FABLE_COMPILER_PYTHON
    let v26 : bool = null |&gt; unbox&lt;bool&gt;
    v26 
    #endif
#else
    let v27 : (string -&gt; bool) = System.IO.File.Exists
    let v28 : bool = v27 v7
    v28 
    #endif
    |&gt; fun x -&gt; _v8 &lt;- Some x
    let v29 : bool = _v8.Value
    let v51 : bool =
        if v29 then
            let v30 : bool = true
            let mutable _v30 : bool option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v31 : string = "&amp;*$0"
            let v32 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v6 v31
            let v33 : string = "String::from($0)"
            let v34 : std_string_String = Fable.Core.RustInterop.emitRustExpr v32 v33
            let v35 : string = "std::path::PathBuf::from($0)"
            let v36 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v34 v35
            let v37 : string = "$0.exists()"
            let v38 : bool = Fable.Core.RustInterop.emitRustExpr v36 v37
            let v41 : bool =
                if v38 then
                    let v39 : string = "$0.is_file()"
                    let v40 : bool = Fable.Core.RustInterop.emitRustExpr v36 v39
                    v40
                else
                    false
            v41 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v42 : bool = null |&gt; unbox&lt;bool&gt;
            v42 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v43 : bool = null |&gt; unbox&lt;bool&gt;
            v43 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v44 : IFsExistsSync = Fable.Core.JsInterop.importAll v22
            let v45 : string = "$0.existsSync($1)"
            let v46 : bool = Fable.Core.JsInterop.emitJsExpr struct (v44, v6) v45
            v46 
            #endif
#if FABLE_COMPILER_PYTHON
            let v47 : bool = null |&gt; unbox&lt;bool&gt;
            v47 
            #endif
#else
            let v48 : (string -&gt; bool) = System.IO.File.Exists
            let v49 : bool = v48 v6
            v49 
            #endif
            |&gt; fun x -&gt; _v30 &lt;- Some x
            let v50 : bool = _v30.Value
            v50
        else
            false
    let v239 : bool =
        if v51 then
            let v52 : bool = true
            let mutable _v52 : string option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v53 : string = method18(v7)
            let v54 : string = method19()
            let v55 : bool = true
            let mutable _v55 : Result&lt;regex_Regex, regex_Error&gt; option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v56 : string = method20()
            let v57 : string = $"regex::Regex::new(&amp;$0)"
            let v58 : Result&lt;regex_Regex, regex_Error&gt; = Fable.Core.RustInterop.emitRustExpr v56 v57
            v58 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v59 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v59 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v60 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v60 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v61 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v61 
            #endif
#if FABLE_COMPILER_PYTHON
            let v62 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v62 
            #endif
#else
            let v63 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v63 
            #endif
            |&gt; fun x -&gt; _v55 &lt;- Some x
            let v64 : Result&lt;regex_Regex, regex_Error&gt; = _v55.Value
            let v65 : string = "$0.unwrap()"
            let v66 : regex_Regex = Fable.Core.RustInterop.emitRustExpr v64 v65
            let v67 : string = $"$0.replace_all(&amp;$1, &amp;*$2)"
            let v68 : std_borrow_Cow&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr struct (v66, v53, v54) v67
            let v69 : string = "String::from($0)"
            let v70 : std_string_String = Fable.Core.RustInterop.emitRustExpr v68 v69
            let v71 : string = "fable_library_rust::String_::fromString($0)"
            let v72 : string = Fable.Core.RustInterop.emitRustExpr v70 v71
            v72 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v73 : string = null |&gt; unbox&lt;string&gt;
            v73 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v74 : string = null |&gt; unbox&lt;string&gt;
            v74 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v75 : string = null |&gt; unbox&lt;string&gt;
            v75 
            #endif
#if FABLE_COMPILER_PYTHON
            let v76 : string = null |&gt; unbox&lt;string&gt;
            v76 
            #endif
#else
            let v77 : string = method21()
            let v78 : string = "^\\\\\\\\\\?\\\\"
            let v79 : string = System.Text.RegularExpressions.Regex.Replace (v7, v78, v77)
            v79 
            #endif
            |&gt; fun x -&gt; _v52 &lt;- Some x
            let v80 : string = _v52.Value
            let v81 : string = $"{v80.[0] |&gt; string |&gt; _.ToLower()}{v80.[1..]}"
            let v82 : string = "\\"
            let v83 : string = "/"
            let v84 : string = v81.Replace (v82, v83)
            let v85 : string = "std::fs::File::open(&amp;*v84)"
            let v86 : Result&lt;std_fs_File, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr () v85
            let v87 : string = "$0.unwrap()"
            let v88 : std_fs_File = Fable.Core.RustInterop.emitRustExpr v86 v87
            let v89 : string = "std::io::BufReader::new(v88)"
            let v90 : std_io_BufReader&lt;std_fs_File&gt; = Fable.Core.RustInterop.emitRustExpr () v89
            let v91 : string = "true; let mut v90 = v90"
            let v92 : bool = Fable.Core.RustInterop.emitRustExpr () v91
            let v93 : string = "sha2::Digest::new()"
            let v94 : sha2_Sha256 = Fable.Core.RustInterop.emitRustExpr () v93
            let v95 : string = "true; let mut v94 = v94"
            let v96 : bool = Fable.Core.RustInterop.emitRustExpr () v95
            let v97 : unativeint = unativeint 0
            let v98 : string = "[$0; 1024]"
            let v99 : Slice'&lt;uint8&gt; = Fable.Core.RustInterop.emitRustExpr 0uy v98
            let v100 : string = "true; loop { // rust.loop"
            let v101 : bool = Fable.Core.RustInterop.emitRustExpr () v100
            let v102 : string = "true; let mut v99 = v99"
            let v103 : bool = Fable.Core.RustInterop.emitRustExpr () v102
            let v104 : string = "std::io::Read::read(&amp;mut v90, &amp;mut v99)"
            let v105 : Result&lt;unativeint, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr () v104
            let v106 : string = "$0.unwrap()"
            let v107 : unativeint = Fable.Core.RustInterop.emitRustExpr v105 v106
            let v108 : bool = v107 = v97
            if v108 then
                let v109 : string = "true; break"
                let v110 : bool = Fable.Core.RustInterop.emitRustExpr () v109
                ()
            let v111 : string = "v99.len()"
            let v112 : unativeint = Fable.Core.RustInterop.emitRustExpr () v111
            let v113 : uint8 = uint8 v112 
            let v114 : unativeint = unativeint v107
            let v115 : unativeint = v114 |&gt; unbox&lt;unativeint&gt;
            let v116 : bool = v115 = v112
            let v121 : Ref&lt;Slice'&lt;uint8&gt;&gt; =
                if v116 then
                    let v117 : string = "&amp;v99[v97..]"
                    let v118 : Ref&lt;Slice'&lt;uint8&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v117
                    v118
                else
                    let v119 : string = "&amp;v99[$0..$1]"
                    let v120 : Ref&lt;Slice'&lt;uint8&gt;&gt; = Fable.Core.RustInterop.emitRustExpr struct (v97, v114) v119
                    v120
            let v122 : string = "sha2::Digest::update(&amp;mut v94, v121)"
            Fable.Core.RustInterop.emitRustExpr () v122
            let v123 : string = "true; } // rust.loop"
            let v124 : bool = Fable.Core.RustInterop.emitRustExpr () v123
            let v125 : string = "true; } // rust.loop"
            let v126 : bool = Fable.Core.RustInterop.emitRustExpr () v125
            let v127 : string = "true; } // rust.loop"
            let v128 : bool = Fable.Core.RustInterop.emitRustExpr () v127
            let v129 : string = "true; { // rust.loop"
            let v130 : bool = Fable.Core.RustInterop.emitRustExpr () v129
            let v131 : string = "true; { // rust.loop"
            let v132 : bool = Fable.Core.RustInterop.emitRustExpr () v131
            let v133 : string = "&amp;sha2::Digest::finalize(v94)"
            let v134 : Ref&lt;Slice&lt;uint8&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v133
            let v135 : string = "$0.iter().map(|x| *x).collect()"
            let v136 : Vec&lt;uint8&gt; = Fable.Core.RustInterop.emitRustExpr v134 v135
            let v137 : string = "$0.into_iter().map(|x| $1(x.clone())).collect()"
            let v138 : (uint8 -&gt; string) = closure50()
            let v139 : Vec&lt;string&gt; = Fable.Core.RustInterop.emitRustExpr struct (v136, v138) v137
            let v140 : string = "fable_library_rust::NativeArray_::array_from($0)"
            let v141 : (string []) = Fable.Core.RustInterop.emitRustExpr v139 v140
            let v142 : string seq = seq { for i = 0 to v141.Length - 1 do yield v141.[i] }
            let v143 : string = method52()
            let v144 : (string -&gt; (string seq -&gt; string)) = String.concat
            let v145 : (string seq -&gt; string) = v144 v143
            let v146 : string = v145 v142
            let v147 : bool = true
            let mutable _v147 : string option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v148 : string = method18(v6)
            let v149 : string = method19()
            let v150 : bool = true
            let mutable _v150 : Result&lt;regex_Regex, regex_Error&gt; option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v151 : string = method20()
            let v152 : string = $"regex::Regex::new(&amp;$0)"
            let v153 : Result&lt;regex_Regex, regex_Error&gt; = Fable.Core.RustInterop.emitRustExpr v151 v152
            v153 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v154 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v154 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v155 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v155 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v156 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v156 
            #endif
#if FABLE_COMPILER_PYTHON
            let v157 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v157 
            #endif
#else
            let v158 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v158 
            #endif
            |&gt; fun x -&gt; _v150 &lt;- Some x
            let v159 : Result&lt;regex_Regex, regex_Error&gt; = _v150.Value
            let v160 : string = "$0.unwrap()"
            let v161 : regex_Regex = Fable.Core.RustInterop.emitRustExpr v159 v160
            let v162 : string = $"$0.replace_all(&amp;$1, &amp;*$2)"
            let v163 : std_borrow_Cow&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr struct (v161, v148, v149) v162
            let v164 : string = "String::from($0)"
            let v165 : std_string_String = Fable.Core.RustInterop.emitRustExpr v163 v164
            let v166 : string = "fable_library_rust::String_::fromString($0)"
            let v167 : string = Fable.Core.RustInterop.emitRustExpr v165 v166
            v167 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v168 : string = null |&gt; unbox&lt;string&gt;
            v168 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v169 : string = null |&gt; unbox&lt;string&gt;
            v169 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v170 : string = null |&gt; unbox&lt;string&gt;
            v170 
            #endif
#if FABLE_COMPILER_PYTHON
            let v171 : string = null |&gt; unbox&lt;string&gt;
            v171 
            #endif
#else
            let v172 : string = method21()
            let v173 : string = System.Text.RegularExpressions.Regex.Replace (v6, v78, v172)
            v173 
            #endif
            |&gt; fun x -&gt; _v147 &lt;- Some x
            let v174 : string = _v147.Value
            let v175 : string = $"{v174.[0] |&gt; string |&gt; _.ToLower()}{v174.[1..]}"
            let v176 : string = v175.Replace (v82, v83)
            let v177 : string = "std::fs::File::open(&amp;*v176)"
            let v178 : Result&lt;std_fs_File, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr () v177
            let v179 : string = "$0.unwrap()"
            let v180 : std_fs_File = Fable.Core.RustInterop.emitRustExpr v178 v179
            let v181 : string = "std::io::BufReader::new(v180)"
            let v182 : std_io_BufReader&lt;std_fs_File&gt; = Fable.Core.RustInterop.emitRustExpr () v181
            let v183 : string = "true; let mut v182 = v182"
            let v184 : bool = Fable.Core.RustInterop.emitRustExpr () v183
            let v185 : string = "sha2::Digest::new()"
            let v186 : sha2_Sha256 = Fable.Core.RustInterop.emitRustExpr () v185
            let v187 : string = "true; let mut v186 = v186"
            let v188 : bool = Fable.Core.RustInterop.emitRustExpr () v187
            let v189 : unativeint = unativeint 0
            let v190 : string = "[$0; 1024]"
            let v191 : Slice'&lt;uint8&gt; = Fable.Core.RustInterop.emitRustExpr 0uy v190
            let v192 : string = "true; loop { // rust.loop"
            let v193 : bool = Fable.Core.RustInterop.emitRustExpr () v192
            let v194 : string = "true; let mut v191 = v191"
            let v195 : bool = Fable.Core.RustInterop.emitRustExpr () v194
            let v196 : string = "std::io::Read::read(&amp;mut v182, &amp;mut v191)"
            let v197 : Result&lt;unativeint, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr () v196
            let v198 : string = "$0.unwrap()"
            let v199 : unativeint = Fable.Core.RustInterop.emitRustExpr v197 v198
            let v200 : bool = v199 = v189
            if v200 then
                let v201 : string = "true; break"
                let v202 : bool = Fable.Core.RustInterop.emitRustExpr () v201
                ()
            let v203 : string = "v191.len()"
            let v204 : unativeint = Fable.Core.RustInterop.emitRustExpr () v203
            let v205 : uint8 = uint8 v204 
            let v206 : unativeint = unativeint v199
            let v207 : unativeint = v206 |&gt; unbox&lt;unativeint&gt;
            let v208 : bool = v207 = v204
            let v213 : Ref&lt;Slice'&lt;uint8&gt;&gt; =
                if v208 then
                    let v209 : string = "&amp;v191[v189..]"
                    let v210 : Ref&lt;Slice'&lt;uint8&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v209
                    v210
                else
                    let v211 : string = "&amp;v191[$0..$1]"
                    let v212 : Ref&lt;Slice'&lt;uint8&gt;&gt; = Fable.Core.RustInterop.emitRustExpr struct (v189, v206) v211
                    v212
            let v214 : string = "sha2::Digest::update(&amp;mut v186, v213)"
            Fable.Core.RustInterop.emitRustExpr () v214
            let v215 : string = "true; } // rust.loop"
            let v216 : bool = Fable.Core.RustInterop.emitRustExpr () v215
            let v217 : string = "true; } // rust.loop"
            let v218 : bool = Fable.Core.RustInterop.emitRustExpr () v217
            let v219 : string = "true; } // rust.loop"
            let v220 : bool = Fable.Core.RustInterop.emitRustExpr () v219
            let v221 : string = "true; { // rust.loop"
            let v222 : bool = Fable.Core.RustInterop.emitRustExpr () v221
            let v223 : string = "true; { // rust.loop"
            let v224 : bool = Fable.Core.RustInterop.emitRustExpr () v223
            let v225 : string = "&amp;sha2::Digest::finalize(v186)"
            let v226 : Ref&lt;Slice&lt;uint8&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v225
            let v227 : string = "$0.iter().map(|x| *x).collect()"
            let v228 : Vec&lt;uint8&gt; = Fable.Core.RustInterop.emitRustExpr v226 v227
            let v229 : string = "$0.into_iter().map(|x| $1(x.clone())).collect()"
            let v230 : Vec&lt;string&gt; = Fable.Core.RustInterop.emitRustExpr struct (v228, v138) v229
            let v231 : string = "fable_library_rust::NativeArray_::array_from($0)"
            let v232 : (string []) = Fable.Core.RustInterop.emitRustExpr v230 v231
            let v233 : string seq = seq { for i = 0 to v232.Length - 1 do yield v232.[i] }
            let v234 : string = method52()
            let v235 : (string -&gt; (string seq -&gt; string)) = String.concat
            let v236 : (string seq -&gt; string) = v235 v234
            let v237 : string = v236 v233
            let v238 : bool = v146 = v237
            v238
        else
            false
    let v240 : bool = v239 = false
    if v240 then
        let v241 : US19 = method54(v2, v3, v7, v4)
        match v241 with
        | US19_1(v282, v283) -&gt; (* Error *)
            let v284 : (string * string) = v7, v283
            let v285 : Result&lt;string, (string * string)&gt; = Error v284
            US18_0(v285)
        | US19_0(v242, v243) -&gt; (* Ok *)
            let v244 : bool = v242 &lt;&gt; 0
            if v244 then
                let v245 : US0 = US0_2
                let v246 : (unit -&gt; string) = closure58()
                let v247 : (unit -&gt; string) = closure59(v243, v242)
                method3(v245, v246, v247)
                let v248 : (string * string) = v7, v243
                let v249 : Result&lt;string, (string * string)&gt; = Error v248
                US18_0(v249)
            else
                let v251 : bool = true
                let mutable _v251 : bool option = None 
                
#if FABLE_COMPILER || WASM || CONTRACT
                
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                let v252 : string = "&amp;*$0"
                let v253 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v7 v252
                let v254 : string = "String::from($0)"
                let v255 : std_string_String = Fable.Core.RustInterop.emitRustExpr v253 v254
                let v256 : string = "std::path::PathBuf::from($0)"
                let v257 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v255 v256
                let v258 : string = "$0.exists()"
                let v259 : bool = Fable.Core.RustInterop.emitRustExpr v257 v258
                let v262 : bool =
                    if v259 then
                        let v260 : string = "$0.is_file()"
                        let v261 : bool = Fable.Core.RustInterop.emitRustExpr v257 v260
                        v261
                    else
                        false
                v262 
                #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                let v263 : bool = null |&gt; unbox&lt;bool&gt;
                v263 
                #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                let v264 : bool = null |&gt; unbox&lt;bool&gt;
                v264 
                #endif
#if FABLE_COMPILER_TYPESCRIPT
                let v265 : IFsExistsSync = Fable.Core.JsInterop.importAll v22
                let v266 : string = "$0.existsSync($1)"
                let v267 : bool = Fable.Core.JsInterop.emitJsExpr struct (v265, v7) v266
                v267 
                #endif
#if FABLE_COMPILER_PYTHON
                let v268 : bool = null |&gt; unbox&lt;bool&gt;
                v268 
                #endif
#else
                let v269 : (string -&gt; bool) = System.IO.File.Exists
                let v270 : bool = v269 v7
                v270 
                #endif
                |&gt; fun x -&gt; _v251 &lt;- Some x
                let v271 : bool = _v251.Value
                if v271 then
                    let v272 : bool = true
                    let mutable _v272 : unit option = None 
                    
#if FABLE_COMPILER || WASM || CONTRACT
                    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                    let v273 : string = method53(v6)
                    let v274 : string = "std::fs::copy(&amp;*$0, &amp;*v273)"
                    let v275 : Result&lt;uint64, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr v7 v274
                    let v276 : string = "$0.unwrap()"
                    let v277 : uint64 = Fable.Core.RustInterop.emitRustExpr v275 v276
                    () 
                    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                    null |&gt; unbox&lt;unit&gt;
                    () 
                    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                    null |&gt; unbox&lt;unit&gt;
                    () 
                    #endif
#if FABLE_COMPILER_TYPESCRIPT
                    null |&gt; unbox&lt;unit&gt;
                    () 
                    #endif
#if FABLE_COMPILER_PYTHON
                    null |&gt; unbox&lt;unit&gt;
                    () 
                    #endif
#else
                    System.IO.File.Copy (v7, v6, true)
                    () 
                    #endif
                    |&gt; fun x -&gt; _v272 &lt;- Some x
                    _v272.Value
                    ()
                else
                    let v278 : string = $"documents.files_fn / {v7} should exist"
                    failwith&lt;unit&gt; v278
                let v279 : Result&lt;string, (string * string)&gt; = Ok v7
                US18_0(v279)
    else
        US18_1
and closure53 (v0 : string, v1 : string, v2 : string, v3 : string) (v4 : string) : (string -&gt; US18) =
    closure54(v0, v1, v2, v3, v4)
and closure62 () () : string =
    let v0 : string = "documents.crowbook / result contains ERROR"
    v0
and closure63 (v0 : string, v1 : string, v2 : int32) () : string =
    let v3 : (unit -&gt; string) = closure6()
    let v4 : string = $"exit_code: %A{v2} / output_path: {v0} / result: {v1} / {v3 ()}"
    v4
and method60 (v0 : string, v1 : string, v2 : string, v3 : string) : US19 =
    let v4 : string option = None
    let v5 : System.Threading.CancellationToken option = None
    let v6 : (struct (string * string) []) = [||]
    let v7 : (struct (bool * string * int32) -&gt; Async&lt;unit&gt;) option = None
    let v8 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) option = None
    let v9 : string = $"crowbook --single \"{v1}\" --output \"{v0}\" --to {v3} --set rendering.num_depth 6 html.css.add \\\"' body {{ color: #e8e6e3; background-color: #202324; }} a {{ color: #989693; }} '\\\""
    let v10 : string option = Some v2 
    let struct (v11 : int32, v12 : string) = method35(v5, v9, v6, v7, v8, v10)
    let v13 : string = "ERROR"
    let v14 : bool = v12.Contains v13
    if v14 then
        let v15 : US0 = US0_3
        let v16 : (unit -&gt; string) = closure62()
        let v17 : (unit -&gt; string) = closure63(v0, v12, v11)
        method3(v15, v16, v17)
        US19_1(v11, v12)
    else
        US19_0(v11, v12)
and closure61 (v0 : string, v1 : string, v2 : string) (v3 : string) : US18 =
    let struct (v4 : string, v5 : string) = method51(v3, v2, v0)
    let v6 : bool = true
    let mutable _v6 : bool option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v7 : string = "&amp;*$0"
    let v8 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v5 v7
    let v9 : string = "String::from($0)"
    let v10 : std_string_String = Fable.Core.RustInterop.emitRustExpr v8 v9
    let v11 : string = "std::path::PathBuf::from($0)"
    let v12 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v10 v11
    let v13 : string = "$0.exists()"
    let v14 : bool = Fable.Core.RustInterop.emitRustExpr v12 v13
    let v17 : bool =
        if v14 then
            let v15 : string = "$0.is_file()"
            let v16 : bool = Fable.Core.RustInterop.emitRustExpr v12 v15
            v16
        else
            false
    v17 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v18 : bool = null |&gt; unbox&lt;bool&gt;
    v18 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v19 : bool = null |&gt; unbox&lt;bool&gt;
    v19 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v20 : string = "fs"
    let v21 : IFsExistsSync = Fable.Core.JsInterop.importAll v20
    let v22 : string = "$0.existsSync($1)"
    let v23 : bool = Fable.Core.JsInterop.emitJsExpr struct (v21, v5) v22
    v23 
    #endif
#if FABLE_COMPILER_PYTHON
    let v24 : bool = null |&gt; unbox&lt;bool&gt;
    v24 
    #endif
#else
    let v25 : (string -&gt; bool) = System.IO.File.Exists
    let v26 : bool = v25 v5
    v26 
    #endif
    |&gt; fun x -&gt; _v6 &lt;- Some x
    let v27 : bool = _v6.Value
    let v49 : bool =
        if v27 then
            let v28 : bool = true
            let mutable _v28 : bool option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v29 : string = "&amp;*$0"
            let v30 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v4 v29
            let v31 : string = "String::from($0)"
            let v32 : std_string_String = Fable.Core.RustInterop.emitRustExpr v30 v31
            let v33 : string = "std::path::PathBuf::from($0)"
            let v34 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v32 v33
            let v35 : string = "$0.exists()"
            let v36 : bool = Fable.Core.RustInterop.emitRustExpr v34 v35
            let v39 : bool =
                if v36 then
                    let v37 : string = "$0.is_file()"
                    let v38 : bool = Fable.Core.RustInterop.emitRustExpr v34 v37
                    v38
                else
                    false
            v39 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v40 : bool = null |&gt; unbox&lt;bool&gt;
            v40 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v41 : bool = null |&gt; unbox&lt;bool&gt;
            v41 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v42 : IFsExistsSync = Fable.Core.JsInterop.importAll v20
            let v43 : string = "$0.existsSync($1)"
            let v44 : bool = Fable.Core.JsInterop.emitJsExpr struct (v42, v4) v43
            v44 
            #endif
#if FABLE_COMPILER_PYTHON
            let v45 : bool = null |&gt; unbox&lt;bool&gt;
            v45 
            #endif
#else
            let v46 : (string -&gt; bool) = System.IO.File.Exists
            let v47 : bool = v46 v4
            v47 
            #endif
            |&gt; fun x -&gt; _v28 &lt;- Some x
            let v48 : bool = _v28.Value
            v48
        else
            false
    let v237 : bool =
        if v49 then
            let v50 : bool = true
            let mutable _v50 : string option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v51 : string = method18(v5)
            let v52 : string = method19()
            let v53 : bool = true
            let mutable _v53 : Result&lt;regex_Regex, regex_Error&gt; option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v54 : string = method20()
            let v55 : string = $"regex::Regex::new(&amp;$0)"
            let v56 : Result&lt;regex_Regex, regex_Error&gt; = Fable.Core.RustInterop.emitRustExpr v54 v55
            v56 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v57 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v57 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v58 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v58 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v59 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v59 
            #endif
#if FABLE_COMPILER_PYTHON
            let v60 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v60 
            #endif
#else
            let v61 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v61 
            #endif
            |&gt; fun x -&gt; _v53 &lt;- Some x
            let v62 : Result&lt;regex_Regex, regex_Error&gt; = _v53.Value
            let v63 : string = "$0.unwrap()"
            let v64 : regex_Regex = Fable.Core.RustInterop.emitRustExpr v62 v63
            let v65 : string = $"$0.replace_all(&amp;$1, &amp;*$2)"
            let v66 : std_borrow_Cow&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr struct (v64, v51, v52) v65
            let v67 : string = "String::from($0)"
            let v68 : std_string_String = Fable.Core.RustInterop.emitRustExpr v66 v67
            let v69 : string = "fable_library_rust::String_::fromString($0)"
            let v70 : string = Fable.Core.RustInterop.emitRustExpr v68 v69
            v70 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v71 : string = null |&gt; unbox&lt;string&gt;
            v71 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v72 : string = null |&gt; unbox&lt;string&gt;
            v72 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v73 : string = null |&gt; unbox&lt;string&gt;
            v73 
            #endif
#if FABLE_COMPILER_PYTHON
            let v74 : string = null |&gt; unbox&lt;string&gt;
            v74 
            #endif
#else
            let v75 : string = method21()
            let v76 : string = "^\\\\\\\\\\?\\\\"
            let v77 : string = System.Text.RegularExpressions.Regex.Replace (v5, v76, v75)
            v77 
            #endif
            |&gt; fun x -&gt; _v50 &lt;- Some x
            let v78 : string = _v50.Value
            let v79 : string = $"{v78.[0] |&gt; string |&gt; _.ToLower()}{v78.[1..]}"
            let v80 : string = "\\"
            let v81 : string = "/"
            let v82 : string = v79.Replace (v80, v81)
            let v83 : string = "std::fs::File::open(&amp;*v82)"
            let v84 : Result&lt;std_fs_File, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr () v83
            let v85 : string = "$0.unwrap()"
            let v86 : std_fs_File = Fable.Core.RustInterop.emitRustExpr v84 v85
            let v87 : string = "std::io::BufReader::new(v86)"
            let v88 : std_io_BufReader&lt;std_fs_File&gt; = Fable.Core.RustInterop.emitRustExpr () v87
            let v89 : string = "true; let mut v88 = v88"
            let v90 : bool = Fable.Core.RustInterop.emitRustExpr () v89
            let v91 : string = "sha2::Digest::new()"
            let v92 : sha2_Sha256 = Fable.Core.RustInterop.emitRustExpr () v91
            let v93 : string = "true; let mut v92 = v92"
            let v94 : bool = Fable.Core.RustInterop.emitRustExpr () v93
            let v95 : unativeint = unativeint 0
            let v96 : string = "[$0; 1024]"
            let v97 : Slice'&lt;uint8&gt; = Fable.Core.RustInterop.emitRustExpr 0uy v96
            let v98 : string = "true; loop { // rust.loop"
            let v99 : bool = Fable.Core.RustInterop.emitRustExpr () v98
            let v100 : string = "true; let mut v97 = v97"
            let v101 : bool = Fable.Core.RustInterop.emitRustExpr () v100
            let v102 : string = "std::io::Read::read(&amp;mut v88, &amp;mut v97)"
            let v103 : Result&lt;unativeint, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr () v102
            let v104 : string = "$0.unwrap()"
            let v105 : unativeint = Fable.Core.RustInterop.emitRustExpr v103 v104
            let v106 : bool = v105 = v95
            if v106 then
                let v107 : string = "true; break"
                let v108 : bool = Fable.Core.RustInterop.emitRustExpr () v107
                ()
            let v109 : string = "v97.len()"
            let v110 : unativeint = Fable.Core.RustInterop.emitRustExpr () v109
            let v111 : uint8 = uint8 v110 
            let v112 : unativeint = unativeint v105
            let v113 : unativeint = v112 |&gt; unbox&lt;unativeint&gt;
            let v114 : bool = v113 = v110
            let v119 : Ref&lt;Slice'&lt;uint8&gt;&gt; =
                if v114 then
                    let v115 : string = "&amp;v97[v95..]"
                    let v116 : Ref&lt;Slice'&lt;uint8&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v115
                    v116
                else
                    let v117 : string = "&amp;v97[$0..$1]"
                    let v118 : Ref&lt;Slice'&lt;uint8&gt;&gt; = Fable.Core.RustInterop.emitRustExpr struct (v95, v112) v117
                    v118
            let v120 : string = "sha2::Digest::update(&amp;mut v92, v119)"
            Fable.Core.RustInterop.emitRustExpr () v120
            let v121 : string = "true; } // rust.loop"
            let v122 : bool = Fable.Core.RustInterop.emitRustExpr () v121
            let v123 : string = "true; } // rust.loop"
            let v124 : bool = Fable.Core.RustInterop.emitRustExpr () v123
            let v125 : string = "true; } // rust.loop"
            let v126 : bool = Fable.Core.RustInterop.emitRustExpr () v125
            let v127 : string = "true; { // rust.loop"
            let v128 : bool = Fable.Core.RustInterop.emitRustExpr () v127
            let v129 : string = "true; { // rust.loop"
            let v130 : bool = Fable.Core.RustInterop.emitRustExpr () v129
            let v131 : string = "&amp;sha2::Digest::finalize(v92)"
            let v132 : Ref&lt;Slice&lt;uint8&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v131
            let v133 : string = "$0.iter().map(|x| *x).collect()"
            let v134 : Vec&lt;uint8&gt; = Fable.Core.RustInterop.emitRustExpr v132 v133
            let v135 : string = "$0.into_iter().map(|x| $1(x.clone())).collect()"
            let v136 : (uint8 -&gt; string) = closure50()
            let v137 : Vec&lt;string&gt; = Fable.Core.RustInterop.emitRustExpr struct (v134, v136) v135
            let v138 : string = "fable_library_rust::NativeArray_::array_from($0)"
            let v139 : (string []) = Fable.Core.RustInterop.emitRustExpr v137 v138
            let v140 : string seq = seq { for i = 0 to v139.Length - 1 do yield v139.[i] }
            let v141 : string = method52()
            let v142 : (string -&gt; (string seq -&gt; string)) = String.concat
            let v143 : (string seq -&gt; string) = v142 v141
            let v144 : string = v143 v140
            let v145 : bool = true
            let mutable _v145 : string option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v146 : string = method18(v4)
            let v147 : string = method19()
            let v148 : bool = true
            let mutable _v148 : Result&lt;regex_Regex, regex_Error&gt; option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v149 : string = method20()
            let v150 : string = $"regex::Regex::new(&amp;$0)"
            let v151 : Result&lt;regex_Regex, regex_Error&gt; = Fable.Core.RustInterop.emitRustExpr v149 v150
            v151 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v152 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v152 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v153 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v153 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v154 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v154 
            #endif
#if FABLE_COMPILER_PYTHON
            let v155 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v155 
            #endif
#else
            let v156 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v156 
            #endif
            |&gt; fun x -&gt; _v148 &lt;- Some x
            let v157 : Result&lt;regex_Regex, regex_Error&gt; = _v148.Value
            let v158 : string = "$0.unwrap()"
            let v159 : regex_Regex = Fable.Core.RustInterop.emitRustExpr v157 v158
            let v160 : string = $"$0.replace_all(&amp;$1, &amp;*$2)"
            let v161 : std_borrow_Cow&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr struct (v159, v146, v147) v160
            let v162 : string = "String::from($0)"
            let v163 : std_string_String = Fable.Core.RustInterop.emitRustExpr v161 v162
            let v164 : string = "fable_library_rust::String_::fromString($0)"
            let v165 : string = Fable.Core.RustInterop.emitRustExpr v163 v164
            v165 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v166 : string = null |&gt; unbox&lt;string&gt;
            v166 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v167 : string = null |&gt; unbox&lt;string&gt;
            v167 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v168 : string = null |&gt; unbox&lt;string&gt;
            v168 
            #endif
#if FABLE_COMPILER_PYTHON
            let v169 : string = null |&gt; unbox&lt;string&gt;
            v169 
            #endif
#else
            let v170 : string = method21()
            let v171 : string = System.Text.RegularExpressions.Regex.Replace (v4, v76, v170)
            v171 
            #endif
            |&gt; fun x -&gt; _v145 &lt;- Some x
            let v172 : string = _v145.Value
            let v173 : string = $"{v172.[0] |&gt; string |&gt; _.ToLower()}{v172.[1..]}"
            let v174 : string = v173.Replace (v80, v81)
            let v175 : string = "std::fs::File::open(&amp;*v174)"
            let v176 : Result&lt;std_fs_File, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr () v175
            let v177 : string = "$0.unwrap()"
            let v178 : std_fs_File = Fable.Core.RustInterop.emitRustExpr v176 v177
            let v179 : string = "std::io::BufReader::new(v178)"
            let v180 : std_io_BufReader&lt;std_fs_File&gt; = Fable.Core.RustInterop.emitRustExpr () v179
            let v181 : string = "true; let mut v180 = v180"
            let v182 : bool = Fable.Core.RustInterop.emitRustExpr () v181
            let v183 : string = "sha2::Digest::new()"
            let v184 : sha2_Sha256 = Fable.Core.RustInterop.emitRustExpr () v183
            let v185 : string = "true; let mut v184 = v184"
            let v186 : bool = Fable.Core.RustInterop.emitRustExpr () v185
            let v187 : unativeint = unativeint 0
            let v188 : string = "[$0; 1024]"
            let v189 : Slice'&lt;uint8&gt; = Fable.Core.RustInterop.emitRustExpr 0uy v188
            let v190 : string = "true; loop { // rust.loop"
            let v191 : bool = Fable.Core.RustInterop.emitRustExpr () v190
            let v192 : string = "true; let mut v189 = v189"
            let v193 : bool = Fable.Core.RustInterop.emitRustExpr () v192
            let v194 : string = "std::io::Read::read(&amp;mut v180, &amp;mut v189)"
            let v195 : Result&lt;unativeint, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr () v194
            let v196 : string = "$0.unwrap()"
            let v197 : unativeint = Fable.Core.RustInterop.emitRustExpr v195 v196
            let v198 : bool = v197 = v187
            if v198 then
                let v199 : string = "true; break"
                let v200 : bool = Fable.Core.RustInterop.emitRustExpr () v199
                ()
            let v201 : string = "v189.len()"
            let v202 : unativeint = Fable.Core.RustInterop.emitRustExpr () v201
            let v203 : uint8 = uint8 v202 
            let v204 : unativeint = unativeint v197
            let v205 : unativeint = v204 |&gt; unbox&lt;unativeint&gt;
            let v206 : bool = v205 = v202
            let v211 : Ref&lt;Slice'&lt;uint8&gt;&gt; =
                if v206 then
                    let v207 : string = "&amp;v189[v187..]"
                    let v208 : Ref&lt;Slice'&lt;uint8&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v207
                    v208
                else
                    let v209 : string = "&amp;v189[$0..$1]"
                    let v210 : Ref&lt;Slice'&lt;uint8&gt;&gt; = Fable.Core.RustInterop.emitRustExpr struct (v187, v204) v209
                    v210
            let v212 : string = "sha2::Digest::update(&amp;mut v184, v211)"
            Fable.Core.RustInterop.emitRustExpr () v212
            let v213 : string = "true; } // rust.loop"
            let v214 : bool = Fable.Core.RustInterop.emitRustExpr () v213
            let v215 : string = "true; } // rust.loop"
            let v216 : bool = Fable.Core.RustInterop.emitRustExpr () v215
            let v217 : string = "true; } // rust.loop"
            let v218 : bool = Fable.Core.RustInterop.emitRustExpr () v217
            let v219 : string = "true; { // rust.loop"
            let v220 : bool = Fable.Core.RustInterop.emitRustExpr () v219
            let v221 : string = "true; { // rust.loop"
            let v222 : bool = Fable.Core.RustInterop.emitRustExpr () v221
            let v223 : string = "&amp;sha2::Digest::finalize(v184)"
            let v224 : Ref&lt;Slice&lt;uint8&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v223
            let v225 : string = "$0.iter().map(|x| *x).collect()"
            let v226 : Vec&lt;uint8&gt; = Fable.Core.RustInterop.emitRustExpr v224 v225
            let v227 : string = "$0.into_iter().map(|x| $1(x.clone())).collect()"
            let v228 : Vec&lt;string&gt; = Fable.Core.RustInterop.emitRustExpr struct (v226, v136) v227
            let v229 : string = "fable_library_rust::NativeArray_::array_from($0)"
            let v230 : (string []) = Fable.Core.RustInterop.emitRustExpr v228 v229
            let v231 : string seq = seq { for i = 0 to v230.Length - 1 do yield v230.[i] }
            let v232 : string = method52()
            let v233 : (string -&gt; (string seq -&gt; string)) = String.concat
            let v234 : (string seq -&gt; string) = v233 v232
            let v235 : string = v234 v231
            let v236 : bool = v144 = v235
            v236
        else
            false
    let v238 : bool = v237 = false
    if v238 then
        let v239 : US19 = method60(v5, v2, v1, v3)
        match v239 with
        | US19_1(v280, v281) -&gt; (* Error *)
            let v282 : (string * string) = v5, v281
            let v283 : Result&lt;string, (string * string)&gt; = Error v282
            US18_0(v283)
        | US19_0(v240, v241) -&gt; (* Ok *)
            let v242 : bool = v240 &lt;&gt; 0
            if v242 then
                let v243 : US0 = US0_2
                let v244 : (unit -&gt; string) = closure58()
                let v245 : (unit -&gt; string) = closure59(v241, v240)
                method3(v243, v244, v245)
                let v246 : (string * string) = v5, v241
                let v247 : Result&lt;string, (string * string)&gt; = Error v246
                US18_0(v247)
            else
                let v249 : bool = true
                let mutable _v249 : bool option = None 
                
#if FABLE_COMPILER || WASM || CONTRACT
                
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                let v250 : string = "&amp;*$0"
                let v251 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v5 v250
                let v252 : string = "String::from($0)"
                let v253 : std_string_String = Fable.Core.RustInterop.emitRustExpr v251 v252
                let v254 : string = "std::path::PathBuf::from($0)"
                let v255 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v253 v254
                let v256 : string = "$0.exists()"
                let v257 : bool = Fable.Core.RustInterop.emitRustExpr v255 v256
                let v260 : bool =
                    if v257 then
                        let v258 : string = "$0.is_file()"
                        let v259 : bool = Fable.Core.RustInterop.emitRustExpr v255 v258
                        v259
                    else
                        false
                v260 
                #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                let v261 : bool = null |&gt; unbox&lt;bool&gt;
                v261 
                #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                let v262 : bool = null |&gt; unbox&lt;bool&gt;
                v262 
                #endif
#if FABLE_COMPILER_TYPESCRIPT
                let v263 : IFsExistsSync = Fable.Core.JsInterop.importAll v20
                let v264 : string = "$0.existsSync($1)"
                let v265 : bool = Fable.Core.JsInterop.emitJsExpr struct (v263, v5) v264
                v265 
                #endif
#if FABLE_COMPILER_PYTHON
                let v266 : bool = null |&gt; unbox&lt;bool&gt;
                v266 
                #endif
#else
                let v267 : (string -&gt; bool) = System.IO.File.Exists
                let v268 : bool = v267 v5
                v268 
                #endif
                |&gt; fun x -&gt; _v249 &lt;- Some x
                let v269 : bool = _v249.Value
                if v269 then
                    let v270 : bool = true
                    let mutable _v270 : unit option = None 
                    
#if FABLE_COMPILER || WASM || CONTRACT
                    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                    let v271 : string = method53(v4)
                    let v272 : string = "std::fs::copy(&amp;*$0, &amp;*v271)"
                    let v273 : Result&lt;uint64, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr v5 v272
                    let v274 : string = "$0.unwrap()"
                    let v275 : uint64 = Fable.Core.RustInterop.emitRustExpr v273 v274
                    () 
                    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                    null |&gt; unbox&lt;unit&gt;
                    () 
                    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                    null |&gt; unbox&lt;unit&gt;
                    () 
                    #endif
#if FABLE_COMPILER_TYPESCRIPT
                    null |&gt; unbox&lt;unit&gt;
                    () 
                    #endif
#if FABLE_COMPILER_PYTHON
                    null |&gt; unbox&lt;unit&gt;
                    () 
                    #endif
#else
                    System.IO.File.Copy (v5, v4, true)
                    () 
                    #endif
                    |&gt; fun x -&gt; _v270 &lt;- Some x
                    _v270.Value
                    ()
                else
                    let v276 : string = $"documents.files_fn / {v5} should exist"
                    failwith&lt;unit&gt; v276
                let v277 : Result&lt;string, (string * string)&gt; = Ok v5
                US18_0(v277)
    else
        US18_1
and closure60 (v0 : string, v1 : string) (v2 : string) : (string -&gt; US18) =
    closure61(v0, v1, v2)
and closure64 () () : string =
    let v0 : string = "documents.run / par_map / files' = [] / listm.iter"
    v0
and closure65 (v0 : string, v1 : string) () : string =
    let v2 : (unit -&gt; string) = closure6()
    let v3 : string = $"output_path: %A{v1} / output_cache_path: {v0} / {v2 ()}"
    v3
and method61 (v0 : UH2, v1 : UH3 list) : UH3 list =
    match v0 with
    | UH2_1(v2, v3) -&gt; (* Cons *)
        let v4 : UH3 list = method61(v3, v1)
        let v5 : UH3 list = v2 :: v4 
        v5
    | UH2_0 -&gt; (* Nil *)
        v1
and method62 (v0 : int32, v1 : Mut8) : bool =
    let v2 : int32 = v1.l0
    let v3 : bool = v2 &lt; v0
    v3
and method63 (v0 : UH3, v1 : struct (string * string * (string -&gt; (string -&gt; US18))) list) : struct (string * string * (string -&gt; (string -&gt; US18))) list =
    match v0 with
    | UH3_1(v2, v3, v4, v5) -&gt; (* Cons *)
        let v6 : struct (string * string * (string -&gt; (string -&gt; US18))) list = method63(v5, v1)
        let v7 : struct (string * string * (string -&gt; (string -&gt; US18))) list = struct (v2, v3, v4) :: v6 
        v7
    | UH3_0 -&gt; (* Nil *)
        v1
and closure66 () struct (v0 : string, v1 : string, v2 : (string -&gt; (string -&gt; US18))) : Result&lt;string, (string * string)&gt; option =
    let v3 : (string -&gt; US18) = v2 v1
    let v4 : US18 = v3 v0
    match v4 with
    | US18_1 -&gt; (* None *)
        let v7 : Result&lt;string, (string * string)&gt; option = None
        v7
    | US18_0(v5) -&gt; (* Some *)
        let v6 : Result&lt;string, (string * string)&gt; option = Some v5 
        v6
and method64 (v0 : Vec&lt;Result&lt;string, (string * string)&gt; option&gt;) : Vec&lt;Result&lt;string, (string * string)&gt; option&gt; =
    v0
and method65 (v0 : Vec&lt;Result&lt;string, (string * string)&gt; option&gt;) : Vec&lt;Result&lt;string, (string * string)&gt; option&gt; =
    v0
and closure22 (v0 : string, v1 : string, v2 : string, v3 : string, v4 : string) (v5 : string) : Result&lt;(string * Vec&lt;Result&lt;string, (string * string)&gt; option&gt;), std_string_String&gt; =
    let v6 : bool = true
    let mutable _v6 : string option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v7 : string = method17(v5)
    let v8 : string = "&amp;*$0"
    let v9 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v7 v8
    let v10 : string = "String::from($0)"
    let v11 : std_string_String = Fable.Core.RustInterop.emitRustExpr v9 v10
    let v12 : string = "std::path::PathBuf::from($0)"
    let v13 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v11 v12
    let v14 : string = "$0.exists()"
    let v15 : bool = Fable.Core.RustInterop.emitRustExpr v13 v14
    let v16 : bool = v15 = false
    let v172 : string =
        if v16 then
            let v17 : bool = true
            let mutable _v17 : string option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v18 : string = "std::env::current_dir()"
            let v19 : Result&lt;std_path_PathBuf, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr () v18
            let v20 : string = "$0.unwrap()"
            let v21 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v19 v20
            let v22 : string = "$0.display()"
            let v23 : std_path_Display = Fable.Core.RustInterop.emitRustExpr v21 v22
            let v24 : bool = true
            let mutable _v24 : std_string_String option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v25 : string = "format!(\"{}\", $0)"
            let v26 : std_string_String = Fable.Core.RustInterop.emitRustExpr v23 v25
            v26 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v27 : string = "format!(\"{}\", $0)"
            let v28 : std_string_String = Fable.Core.RustInterop.emitRustExpr v23 v27
            v28 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v29 : string = "format!(\"{}\", $0)"
            let v30 : std_string_String = Fable.Core.RustInterop.emitRustExpr v23 v29
            v30 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v31 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v31 
            #endif
#if FABLE_COMPILER_PYTHON
            let v32 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v32 
            #endif
#else
            let v33 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v33 
            #endif
            |&gt; fun x -&gt; _v24 &lt;- Some x
            let v34 : std_string_String = _v24.Value
            let v35 : string = "fable_library_rust::String_::fromString($0)"
            let v36 : string = Fable.Core.RustInterop.emitRustExpr v34 v35
            v36 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v37 : string = null |&gt; unbox&lt;string&gt;
            v37 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v38 : string = null |&gt; unbox&lt;string&gt;
            v38 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v39 : string = null |&gt; unbox&lt;string&gt;
            v39 
            #endif
#if FABLE_COMPILER_PYTHON
            let v40 : string = null |&gt; unbox&lt;string&gt;
            v40 
            #endif
#else
            let v41 : (unit -&gt; string) = System.IO.Directory.GetCurrentDirectory
            let v42 : string = v41 ()
            v42 
            #endif
            |&gt; fun x -&gt; _v17 &lt;- Some x
            let v43 : string = _v17.Value
            let v44 : string = method11(v43, v7)
            let v45 : bool = true
            let mutable _v45 : string option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v46 : string = method18(v44)
            let v47 : string = method19()
            let v48 : bool = true
            let mutable _v48 : Result&lt;regex_Regex, regex_Error&gt; option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v49 : string = method20()
            let v50 : string = $"regex::Regex::new(&amp;$0)"
            let v51 : Result&lt;regex_Regex, regex_Error&gt; = Fable.Core.RustInterop.emitRustExpr v49 v50
            v51 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v52 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v52 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v53 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v53 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v54 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v54 
            #endif
#if FABLE_COMPILER_PYTHON
            let v55 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v55 
            #endif
#else
            let v56 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v56 
            #endif
            |&gt; fun x -&gt; _v48 &lt;- Some x
            let v57 : Result&lt;regex_Regex, regex_Error&gt; = _v48.Value
            let v58 : string = "$0.unwrap()"
            let v59 : regex_Regex = Fable.Core.RustInterop.emitRustExpr v57 v58
            let v60 : string = $"$0.replace_all(&amp;$1, &amp;*$2)"
            let v61 : std_borrow_Cow&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr struct (v59, v46, v47) v60
            let v62 : string = "String::from($0)"
            let v63 : std_string_String = Fable.Core.RustInterop.emitRustExpr v61 v62
            let v64 : string = "fable_library_rust::String_::fromString($0)"
            let v65 : string = Fable.Core.RustInterop.emitRustExpr v63 v64
            v65 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v66 : string = null |&gt; unbox&lt;string&gt;
            v66 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v67 : string = null |&gt; unbox&lt;string&gt;
            v67 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v68 : string = null |&gt; unbox&lt;string&gt;
            v68 
            #endif
#if FABLE_COMPILER_PYTHON
            let v69 : string = null |&gt; unbox&lt;string&gt;
            v69 
            #endif
#else
            let v70 : string = method21()
            let v71 : string = "^\\\\\\\\\\?\\\\"
            let v72 : string = System.Text.RegularExpressions.Regex.Replace (v44, v71, v70)
            v72 
            #endif
            |&gt; fun x -&gt; _v45 &lt;- Some x
            let v73 : string = _v45.Value
            let v74 : string = $"{v73.[0] |&gt; string |&gt; _.ToLower()}{v73.[1..]}"
            let v75 : string = "\\"
            let v76 : string = "/"
            let v77 : string = v74.Replace (v75, v76)
            let v78 : (string []) = v77.Split v76
            let v79 : (string []) = [||]
            let v80 : int32 = v78.Length
            let v81 : Mut4 = {l0 = 0; l1 = 0; l2 = v79} : Mut4
            while method22(v80, v81) do
                let v83 : int32 = v81.l0
                let v84 : int32 =  -v83
                let v85 : int32 = v84 + v80
                let v86 : int32 = v85 - 1
                let struct (v87 : int32, v88 : (string [])) = v81.l1, v81.l2
                let v89 : string = v78.[int v86]
                let v90 : bool = ".." = v89
                let struct (v132 : int32, v133 : (string [])) =
                    if v90 then
                        let v91 : int32 = v87 + 1
                        struct (v91, v88)
                    else
                        let v92 : bool = "." = v89
                        if v92 then
                            struct (v87, v88)
                        else
                            let v93 : bool = 0 = v87
                            if v93 then
                                let v94 : string = ":"
                                let v95 : bool = v89.EndsWith v94
                                if v95 then
                                    let v96 : string = $"{v43.[0]}:"
                                    let v97 : (string []) = [|v96|]
                                    let v98 : int32 = v97.Length
                                    let v99 : int32 = v88.Length
                                    let v100 : int32 = v98 + v99
                                    let v101 : (string []) = Array.zeroCreate&lt;string&gt; (v100)
                                    let v102 : Mut5 = {l0 = 0} : Mut5
                                    while method23(v100, v102) do
                                        let v104 : int32 = v102.l0
                                        let v105 : bool = v104 &lt; v98
                                        let v109 : string =
                                            if v105 then
                                                let v106 : string = v97.[int v104]
                                                v106
                                            else
                                                let v107 : int32 = v104 - v98
                                                let v108 : string = v88.[int v107]
                                                v108
                                        v101.[int v104] &lt;- v109
                                        let v110 : int32 = v104 + 1
                                        v102.l0 &lt;- v110
                                        ()
                                    struct (0, v101)
                                else
                                    let v111 : (string []) = [|v89|]
                                    let v112 : int32 = v111.Length
                                    let v113 : int32 = v88.Length
                                    let v114 : int32 = v112 + v113
                                    let v115 : (string []) = Array.zeroCreate&lt;string&gt; (v114)
                                    let v116 : Mut5 = {l0 = 0} : Mut5
                                    while method23(v114, v116) do
                                        let v118 : int32 = v116.l0
                                        let v119 : bool = v118 &lt; v112
                                        let v123 : string =
                                            if v119 then
                                                let v120 : string = v111.[int v118]
                                                v120
                                            else
                                                let v121 : int32 = v118 - v112
                                                let v122 : string = v88.[int v121]
                                                v122
                                        v115.[int v118] &lt;- v123
                                        let v124 : int32 = v118 + 1
                                        v116.l0 &lt;- v124
                                        ()
                                    struct (0, v115)
                            else
                                let v127 : int32 = v87 - 1
                                struct (v127, v88)
                let v134 : int32 = v83 + 1
                v81.l0 &lt;- v134
                v81.l1 &lt;- v132
                v81.l2 &lt;- v133
                ()
            let struct (v135 : int32, v136 : (string [])) = v81.l1, v81.l2
            let v137 : string seq = seq { for i = 0 to v136.Length - 1 do yield v136.[i] }
            let v138 : bool = true
            let mutable _v138 : char option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v139 : string = "std::path::MAIN_SEPARATOR"
            let v140 : char = Fable.Core.RustInterop.emitRustExpr () v139
            v140 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v141 : char = null |&gt; unbox&lt;char&gt;
            v141 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v142 : char = null |&gt; unbox&lt;char&gt;
            v142 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v143 : char = null |&gt; unbox&lt;char&gt;
            v143 
            #endif
#if FABLE_COMPILER_PYTHON
            let v144 : char = null |&gt; unbox&lt;char&gt;
            v144 
            #endif
#else
            let v145 : char = System.IO.Path.DirectorySeparatorChar
            v145 
            #endif
            |&gt; fun x -&gt; _v138 &lt;- Some x
            let v146 : char = _v138.Value
            let v147 : (char -&gt; string) = _.ToString()
            let v148 : string = v147 v146
            let v149 : string = method24(v148)
            let v150 : (string -&gt; (string seq -&gt; string)) = String.concat
            let v151 : (string seq -&gt; string) = v150 v149
            v151 v137
        else
            let v153 : string = "std::fs::canonicalize(&amp;*$0)"
            let v154 : Result&lt;std_path_PathBuf, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr v7 v153
            let v155 : string = "$0.unwrap()"
            let v156 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v154 v155
            let v157 : string = "$0.display()"
            let v158 : std_path_Display = Fable.Core.RustInterop.emitRustExpr v156 v157
            let v159 : bool = true
            let mutable _v159 : std_string_String option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v160 : string = "format!(\"{}\", $0)"
            let v161 : std_string_String = Fable.Core.RustInterop.emitRustExpr v158 v160
            v161 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v162 : string = "format!(\"{}\", $0)"
            let v163 : std_string_String = Fable.Core.RustInterop.emitRustExpr v158 v162
            v163 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v164 : string = "format!(\"{}\", $0)"
            let v165 : std_string_String = Fable.Core.RustInterop.emitRustExpr v158 v164
            v165 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v166 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v166 
            #endif
#if FABLE_COMPILER_PYTHON
            let v167 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v167 
            #endif
#else
            let v168 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v168 
            #endif
            |&gt; fun x -&gt; _v159 &lt;- Some x
            let v169 : std_string_String = _v159.Value
            let v170 : string = "fable_library_rust::String_::fromString($0)"
            let v171 : string = Fable.Core.RustInterop.emitRustExpr v169 v170
            v171
    v172 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v173 : string = null |&gt; unbox&lt;string&gt;
    v173 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v174 : string = null |&gt; unbox&lt;string&gt;
    v174 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v175 : string = null |&gt; unbox&lt;string&gt;
    v175 
    #endif
#if FABLE_COMPILER_PYTHON
    let v176 : string = null |&gt; unbox&lt;string&gt;
    v176 
    #endif
#else
    let v177 : string = method25(v5)
    let v178 : (string -&gt; string) = System.IO.Path.GetFullPath
    let v179 : string = v178 v177
    v179 
    #endif
    |&gt; fun x -&gt; _v6 &lt;- Some x
    let v180 : string = _v6.Value
    let v181 : string = "&amp;*$0"
    let v182 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v180 v181
    let v183 : string = "String::from($0)"
    let v184 : std_string_String = Fable.Core.RustInterop.emitRustExpr v182 v183
    let v185 : string = "std::path::PathBuf::from($0)"
    let v186 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v184 v185
    let v187 : string = "$0.display()"
    let v188 : std_path_Display = Fable.Core.RustInterop.emitRustExpr v186 v187
    let v189 : bool = true
    let mutable _v189 : std_string_String option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v190 : string = "format!(\"{}\", $0)"
    let v191 : std_string_String = Fable.Core.RustInterop.emitRustExpr v188 v190
    v191 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v192 : string = "format!(\"{}\", $0)"
    let v193 : std_string_String = Fable.Core.RustInterop.emitRustExpr v188 v192
    v193 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v194 : string = "format!(\"{}\", $0)"
    let v195 : std_string_String = Fable.Core.RustInterop.emitRustExpr v188 v194
    v195 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v196 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
    v196 
    #endif
#if FABLE_COMPILER_PYTHON
    let v197 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
    v197 
    #endif
#else
    let v198 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
    v198 
    #endif
    |&gt; fun x -&gt; _v189 &lt;- Some x
    let v199 : std_string_String = _v189.Value
    let v200 : string = "fable_library_rust::String_::fromString($0)"
    let v201 : string = Fable.Core.RustInterop.emitRustExpr v199 v200
    let v202 : string = ""
    let v203 : string = v201.Replace (v3, v202)
    let v204 : string = "\\"
    let v205 : string = "/"
    let v206 : string = v203.Replace (v204, v205)
    let v207 : string = $".{v206}"
    let v208 : bool = true
    let mutable _v208 : string option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v209 : string = method18(v180)
    let v210 : string = method19()
    let v211 : bool = true
    let mutable _v211 : Result&lt;regex_Regex, regex_Error&gt; option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v212 : string = method20()
    let v213 : string = $"regex::Regex::new(&amp;$0)"
    let v214 : Result&lt;regex_Regex, regex_Error&gt; = Fable.Core.RustInterop.emitRustExpr v212 v213
    v214 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v215 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
    v215 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v216 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
    v216 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v217 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
    v217 
    #endif
#if FABLE_COMPILER_PYTHON
    let v218 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
    v218 
    #endif
#else
    let v219 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
    v219 
    #endif
    |&gt; fun x -&gt; _v211 &lt;- Some x
    let v220 : Result&lt;regex_Regex, regex_Error&gt; = _v211.Value
    let v221 : string = "$0.unwrap()"
    let v222 : regex_Regex = Fable.Core.RustInterop.emitRustExpr v220 v221
    let v223 : string = $"$0.replace_all(&amp;$1, &amp;*$2)"
    let v224 : std_borrow_Cow&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr struct (v222, v209, v210) v223
    let v225 : string = "String::from($0)"
    let v226 : std_string_String = Fable.Core.RustInterop.emitRustExpr v224 v225
    let v227 : string = "fable_library_rust::String_::fromString($0)"
    let v228 : string = Fable.Core.RustInterop.emitRustExpr v226 v227
    v228 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v229 : string = null |&gt; unbox&lt;string&gt;
    v229 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v230 : string = null |&gt; unbox&lt;string&gt;
    v230 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v231 : string = null |&gt; unbox&lt;string&gt;
    v231 
    #endif
#if FABLE_COMPILER_PYTHON
    let v232 : string = null |&gt; unbox&lt;string&gt;
    v232 
    #endif
#else
    let v233 : string = method21()
    let v234 : string = "^\\\\\\\\\\?\\\\"
    let v235 : string = System.Text.RegularExpressions.Regex.Replace (v180, v234, v233)
    v235 
    #endif
    |&gt; fun x -&gt; _v208 &lt;- Some x
    let v236 : string = _v208.Value
    let v237 : string = $"{v236.[0] |&gt; string |&gt; _.ToLower()}{v236.[1..]}"
    let v238 : string = v237.Replace (v204, v205)
    let v239 : string = method11(v2, v207)
    let v240 : string = method34(v239)
    let v241 : string option = None
    let v242 : System.Threading.CancellationToken option = None
    let v243 : (struct (string * string) []) = [||]
    let v244 : (struct (bool * string * int32) -&gt; Async&lt;unit&gt;) option = None
    let v245 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) option = None
    let v246 : string = $"git ls-tree --format='%%(objectname)' origin/gh-pages \"{v240}\""
    let v247 : string option = Some v2 
    let struct (v248 : int32, v249 : string) = method35(v242, v246, v243, v244, v245, v247)
    let v250 : string = method11(v3, v207)
    let v251 : string = method34(v250)
    let v252 : string option = None
    let v253 : System.Threading.CancellationToken option = None
    let v254 : (struct (string * string) []) = [||]
    let v255 : (struct (bool * string * int32) -&gt; Async&lt;unit&gt;) option = None
    let v256 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) option = None
    let v257 : string = $"git hash-object \"{v251}\""
    let v258 : string option = Some v3 
    let struct (v259 : int32, v260 : string) = method35(v253, v257, v254, v255, v256, v258)
    let v261 : string = method11(v4, v207)
    let v262 : string = method34(v261)
    let v263 : string = "hangul.md"
    let struct (v264 : string, v265 : string) = method51(v263, v251, v4)
    let v266 : bool = v249.Contains v260
    let v267 : bool = v266 = false
    let v513 : UH2 =
        if v267 then
            let v268 : bool = true
            let mutable _v268 : string option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v269 : string = method18(v251)
            let v270 : string = method19()
            let v271 : bool = true
            let mutable _v271 : Result&lt;regex_Regex, regex_Error&gt; option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v272 : string = method20()
            let v273 : string = $"regex::Regex::new(&amp;$0)"
            let v274 : Result&lt;regex_Regex, regex_Error&gt; = Fable.Core.RustInterop.emitRustExpr v272 v273
            v274 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v275 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v275 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v276 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v276 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v277 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v277 
            #endif
#if FABLE_COMPILER_PYTHON
            let v278 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v278 
            #endif
#else
            let v279 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v279 
            #endif
            |&gt; fun x -&gt; _v271 &lt;- Some x
            let v280 : Result&lt;regex_Regex, regex_Error&gt; = _v271.Value
            let v281 : string = "$0.unwrap()"
            let v282 : regex_Regex = Fable.Core.RustInterop.emitRustExpr v280 v281
            let v283 : string = $"$0.replace_all(&amp;$1, &amp;*$2)"
            let v284 : std_borrow_Cow&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr struct (v282, v269, v270) v283
            let v285 : string = "String::from($0)"
            let v286 : std_string_String = Fable.Core.RustInterop.emitRustExpr v284 v285
            let v287 : string = "fable_library_rust::String_::fromString($0)"
            let v288 : string = Fable.Core.RustInterop.emitRustExpr v286 v287
            v288 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v289 : string = null |&gt; unbox&lt;string&gt;
            v289 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v290 : string = null |&gt; unbox&lt;string&gt;
            v290 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v291 : string = null |&gt; unbox&lt;string&gt;
            v291 
            #endif
#if FABLE_COMPILER_PYTHON
            let v292 : string = null |&gt; unbox&lt;string&gt;
            v292 
            #endif
#else
            let v293 : string = method21()
            let v294 : string = System.Text.RegularExpressions.Regex.Replace (v251, v234, v293)
            v294 
            #endif
            |&gt; fun x -&gt; _v268 &lt;- Some x
            let v295 : string = _v268.Value
            let v296 : string = $"{v295.[0] |&gt; string |&gt; _.ToLower()}{v295.[1..]}"
            let v297 : string = v296.Replace (v204, v205)
            let v298 : string = "std::fs::File::open(&amp;*v297)"
            let v299 : Result&lt;std_fs_File, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr () v298
            let v300 : string = "$0.unwrap()"
            let v301 : std_fs_File = Fable.Core.RustInterop.emitRustExpr v299 v300
            let v302 : string = "std::io::BufReader::new(v301)"
            let v303 : std_io_BufReader&lt;std_fs_File&gt; = Fable.Core.RustInterop.emitRustExpr () v302
            let v304 : string = "true; let mut v303 = v303"
            let v305 : bool = Fable.Core.RustInterop.emitRustExpr () v304
            let v306 : string = "sha2::Digest::new()"
            let v307 : sha2_Sha256 = Fable.Core.RustInterop.emitRustExpr () v306
            let v308 : string = "true; let mut v307 = v307"
            let v309 : bool = Fable.Core.RustInterop.emitRustExpr () v308
            let v310 : unativeint = unativeint 0
            let v311 : string = "[$0; 1024]"
            let v312 : Slice'&lt;uint8&gt; = Fable.Core.RustInterop.emitRustExpr 0uy v311
            let v313 : string = "true; loop { // rust.loop"
            let v314 : bool = Fable.Core.RustInterop.emitRustExpr () v313
            let v315 : string = "true; let mut v312 = v312"
            let v316 : bool = Fable.Core.RustInterop.emitRustExpr () v315
            let v317 : string = "std::io::Read::read(&amp;mut v303, &amp;mut v312)"
            let v318 : Result&lt;unativeint, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr () v317
            let v319 : string = "$0.unwrap()"
            let v320 : unativeint = Fable.Core.RustInterop.emitRustExpr v318 v319
            let v321 : bool = v320 = v310
            if v321 then
                let v322 : string = "true; break"
                let v323 : bool = Fable.Core.RustInterop.emitRustExpr () v322
                ()
            let v324 : string = "v312.len()"
            let v325 : unativeint = Fable.Core.RustInterop.emitRustExpr () v324
            let v326 : uint8 = uint8 v325 
            let v327 : unativeint = unativeint v320
            let v328 : unativeint = v327 |&gt; unbox&lt;unativeint&gt;
            let v329 : bool = v328 = v325
            let v334 : Ref&lt;Slice'&lt;uint8&gt;&gt; =
                if v329 then
                    let v330 : string = "&amp;v312[v310..]"
                    let v331 : Ref&lt;Slice'&lt;uint8&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v330
                    v331
                else
                    let v332 : string = "&amp;v312[$0..$1]"
                    let v333 : Ref&lt;Slice'&lt;uint8&gt;&gt; = Fable.Core.RustInterop.emitRustExpr struct (v310, v327) v332
                    v333
            let v335 : string = "sha2::Digest::update(&amp;mut v307, v334)"
            Fable.Core.RustInterop.emitRustExpr () v335
            let v336 : string = "true; } // rust.loop"
            let v337 : bool = Fable.Core.RustInterop.emitRustExpr () v336
            let v338 : string = "true; } // rust.loop"
            let v339 : bool = Fable.Core.RustInterop.emitRustExpr () v338
            let v340 : string = "true; } // rust.loop"
            let v341 : bool = Fable.Core.RustInterop.emitRustExpr () v340
            let v342 : string = "true; { // rust.loop"
            let v343 : bool = Fable.Core.RustInterop.emitRustExpr () v342
            let v344 : string = "true; { // rust.loop"
            let v345 : bool = Fable.Core.RustInterop.emitRustExpr () v344
            let v346 : string = "&amp;sha2::Digest::finalize(v307)"
            let v347 : Ref&lt;Slice&lt;uint8&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v346
            let v348 : string = "$0.iter().map(|x| *x).collect()"
            let v349 : Vec&lt;uint8&gt; = Fable.Core.RustInterop.emitRustExpr v347 v348
            let v350 : string = "$0.into_iter().map(|x| $1(x.clone())).collect()"
            let v351 : (uint8 -&gt; string) = closure50()
            let v352 : Vec&lt;string&gt; = Fable.Core.RustInterop.emitRustExpr struct (v349, v351) v350
            let v353 : string = "fable_library_rust::NativeArray_::array_from($0)"
            let v354 : (string []) = Fable.Core.RustInterop.emitRustExpr v352 v353
            let v355 : string seq = seq { for i = 0 to v354.Length - 1 do yield v354.[i] }
            let v356 : string = method52()
            let v357 : (string -&gt; (string seq -&gt; string)) = String.concat
            let v358 : (string seq -&gt; string) = v357 v356
            let v359 : string = v358 v355
            let v360 : bool = true
            let mutable _v360 : bool option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v361 : string = "&amp;*$0"
            let v362 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v262 v361
            let v363 : string = "String::from($0)"
            let v364 : std_string_String = Fable.Core.RustInterop.emitRustExpr v362 v363
            let v365 : string = "std::path::PathBuf::from($0)"
            let v366 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v364 v365
            let v367 : string = "$0.exists()"
            let v368 : bool = Fable.Core.RustInterop.emitRustExpr v366 v367
            let v371 : bool =
                if v368 then
                    let v369 : string = "$0.is_file()"
                    let v370 : bool = Fable.Core.RustInterop.emitRustExpr v366 v369
                    v370
                else
                    false
            v371 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v372 : bool = null |&gt; unbox&lt;bool&gt;
            v372 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v373 : bool = null |&gt; unbox&lt;bool&gt;
            v373 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v374 : string = "fs"
            let v375 : IFsExistsSync = Fable.Core.JsInterop.importAll v374
            let v376 : string = "$0.existsSync($1)"
            let v377 : bool = Fable.Core.JsInterop.emitJsExpr struct (v375, v262) v376
            v377 
            #endif
#if FABLE_COMPILER_PYTHON
            let v378 : bool = null |&gt; unbox&lt;bool&gt;
            v378 
            #endif
#else
            let v379 : (string -&gt; bool) = System.IO.File.Exists
            let v380 : bool = v379 v262
            v380 
            #endif
            |&gt; fun x -&gt; _v360 &lt;- Some x
            let v381 : bool = _v360.Value
            let v475 : US3 =
                if v381 then
                    let v382 : bool = true
                    let mutable _v382 : string option = None 
                    
#if FABLE_COMPILER || WASM || CONTRACT
                    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                    let v383 : string = method18(v262)
                    let v384 : string = method19()
                    let v385 : bool = true
                    let mutable _v385 : Result&lt;regex_Regex, regex_Error&gt; option = None 
                    
#if FABLE_COMPILER || WASM || CONTRACT
                    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                    let v386 : string = method20()
                    let v387 : string = $"regex::Regex::new(&amp;$0)"
                    let v388 : Result&lt;regex_Regex, regex_Error&gt; = Fable.Core.RustInterop.emitRustExpr v386 v387
                    v388 
                    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                    let v389 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
                    v389 
                    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                    let v390 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
                    v390 
                    #endif
#if FABLE_COMPILER_TYPESCRIPT
                    let v391 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
                    v391 
                    #endif
#if FABLE_COMPILER_PYTHON
                    let v392 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
                    v392 
                    #endif
#else
                    let v393 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
                    v393 
                    #endif
                    |&gt; fun x -&gt; _v385 &lt;- Some x
                    let v394 : Result&lt;regex_Regex, regex_Error&gt; = _v385.Value
                    let v395 : string = "$0.unwrap()"
                    let v396 : regex_Regex = Fable.Core.RustInterop.emitRustExpr v394 v395
                    let v397 : string = $"$0.replace_all(&amp;$1, &amp;*$2)"
                    let v398 : std_borrow_Cow&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr struct (v396, v383, v384) v397
                    let v399 : string = "String::from($0)"
                    let v400 : std_string_String = Fable.Core.RustInterop.emitRustExpr v398 v399
                    let v401 : string = "fable_library_rust::String_::fromString($0)"
                    let v402 : string = Fable.Core.RustInterop.emitRustExpr v400 v401
                    v402 
                    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                    let v403 : string = null |&gt; unbox&lt;string&gt;
                    v403 
                    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                    let v404 : string = null |&gt; unbox&lt;string&gt;
                    v404 
                    #endif
#if FABLE_COMPILER_TYPESCRIPT
                    let v405 : string = null |&gt; unbox&lt;string&gt;
                    v405 
                    #endif
#if FABLE_COMPILER_PYTHON
                    let v406 : string = null |&gt; unbox&lt;string&gt;
                    v406 
                    #endif
#else
                    let v407 : string = method21()
                    let v408 : string = System.Text.RegularExpressions.Regex.Replace (v262, v234, v407)
                    v408 
                    #endif
                    |&gt; fun x -&gt; _v382 &lt;- Some x
                    let v409 : string = _v382.Value
                    let v410 : string = $"{v409.[0] |&gt; string |&gt; _.ToLower()}{v409.[1..]}"
                    let v411 : string = v410.Replace (v204, v205)
                    let v412 : string = "std::fs::File::open(&amp;*v411)"
                    let v413 : Result&lt;std_fs_File, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr () v412
                    let v414 : string = "$0.unwrap()"
                    let v415 : std_fs_File = Fable.Core.RustInterop.emitRustExpr v413 v414
                    let v416 : string = "std::io::BufReader::new(v415)"
                    let v417 : std_io_BufReader&lt;std_fs_File&gt; = Fable.Core.RustInterop.emitRustExpr () v416
                    let v418 : string = "true; let mut v417 = v417"
                    let v419 : bool = Fable.Core.RustInterop.emitRustExpr () v418
                    let v420 : string = "sha2::Digest::new()"
                    let v421 : sha2_Sha256 = Fable.Core.RustInterop.emitRustExpr () v420
                    let v422 : string = "true; let mut v421 = v421"
                    let v423 : bool = Fable.Core.RustInterop.emitRustExpr () v422
                    let v424 : unativeint = unativeint 0
                    let v425 : string = "[$0; 1024]"
                    let v426 : Slice'&lt;uint8&gt; = Fable.Core.RustInterop.emitRustExpr 0uy v425
                    let v427 : string = "true; loop { // rust.loop"
                    let v428 : bool = Fable.Core.RustInterop.emitRustExpr () v427
                    let v429 : string = "true; let mut v426 = v426"
                    let v430 : bool = Fable.Core.RustInterop.emitRustExpr () v429
                    let v431 : string = "std::io::Read::read(&amp;mut v417, &amp;mut v426)"
                    let v432 : Result&lt;unativeint, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr () v431
                    let v433 : string = "$0.unwrap()"
                    let v434 : unativeint = Fable.Core.RustInterop.emitRustExpr v432 v433
                    let v435 : bool = v434 = v424
                    if v435 then
                        let v436 : string = "true; break"
                        let v437 : bool = Fable.Core.RustInterop.emitRustExpr () v436
                        ()
                    let v438 : string = "v426.len()"
                    let v439 : unativeint = Fable.Core.RustInterop.emitRustExpr () v438
                    let v440 : uint8 = uint8 v439 
                    let v441 : unativeint = unativeint v434
                    let v442 : unativeint = v441 |&gt; unbox&lt;unativeint&gt;
                    let v443 : bool = v442 = v439
                    let v448 : Ref&lt;Slice'&lt;uint8&gt;&gt; =
                        if v443 then
                            let v444 : string = "&amp;v426[v424..]"
                            let v445 : Ref&lt;Slice'&lt;uint8&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v444
                            v445
                        else
                            let v446 : string = "&amp;v426[$0..$1]"
                            let v447 : Ref&lt;Slice'&lt;uint8&gt;&gt; = Fable.Core.RustInterop.emitRustExpr struct (v424, v441) v446
                            v447
                    let v449 : string = "sha2::Digest::update(&amp;mut v421, v448)"
                    Fable.Core.RustInterop.emitRustExpr () v449
                    let v450 : string = "true; } // rust.loop"
                    let v451 : bool = Fable.Core.RustInterop.emitRustExpr () v450
                    let v452 : string = "true; } // rust.loop"
                    let v453 : bool = Fable.Core.RustInterop.emitRustExpr () v452
                    let v454 : string = "true; } // rust.loop"
                    let v455 : bool = Fable.Core.RustInterop.emitRustExpr () v454
                    let v456 : string = "true; { // rust.loop"
                    let v457 : bool = Fable.Core.RustInterop.emitRustExpr () v456
                    let v458 : string = "true; { // rust.loop"
                    let v459 : bool = Fable.Core.RustInterop.emitRustExpr () v458
                    let v460 : string = "&amp;sha2::Digest::finalize(v421)"
                    let v461 : Ref&lt;Slice&lt;uint8&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v460
                    let v462 : string = "$0.iter().map(|x| *x).collect()"
                    let v463 : Vec&lt;uint8&gt; = Fable.Core.RustInterop.emitRustExpr v461 v462
                    let v464 : string = "$0.into_iter().map(|x| $1(x.clone())).collect()"
                    let v465 : Vec&lt;string&gt; = Fable.Core.RustInterop.emitRustExpr struct (v463, v351) v464
                    let v466 : string = "fable_library_rust::NativeArray_::array_from($0)"
                    let v467 : (string []) = Fable.Core.RustInterop.emitRustExpr v465 v466
                    let v468 : string seq = seq { for i = 0 to v467.Length - 1 do yield v467.[i] }
                    let v469 : string = method52()
                    let v470 : (string -&gt; (string seq -&gt; string)) = String.concat
                    let v471 : (string seq -&gt; string) = v470 v469
                    let v472 : string = v471 v468
                    US3_0(v472)
                else
                    US3_1
            let v477 : bool =
                match v475 with
                | US3_1 -&gt; (* None *)
                    true
                | _ -&gt;
                    false
            let v483 : bool =
                if v477 then
                    true
                else
                    let v481 : string =
                        match v475 with
                        | US3_1 -&gt; (* None *)
                            failwith&lt;string&gt; "Option does not have a value."
                        | US3_0(v478) -&gt; (* Some *)
                            v478
                    let v482 : bool = v359 &lt;&gt; v481
                    v482
            if v483 then
                let v484 : US0 = US0_2
                let v485 : (unit -&gt; string) = closure51()
                let v486 : (unit -&gt; string) = closure52(v207, v238, v240, v249, v248, v251, v260, v259, v262, v359, v475)
                method3(v484, v485, v486)
                let v487 : bool = true
                let mutable _v487 : unit option = None 
                
#if FABLE_COMPILER || WASM || CONTRACT
                
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                let v488 : string = method53(v262)
                let v489 : string = "std::fs::copy(&amp;*$0, &amp;*v488)"
                let v490 : Result&lt;uint64, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr v251 v489
                let v491 : string = "$0.unwrap()"
                let v492 : uint64 = Fable.Core.RustInterop.emitRustExpr v490 v491
                () 
                #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                null |&gt; unbox&lt;unit&gt;
                () 
                #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                null |&gt; unbox&lt;unit&gt;
                () 
                #endif
#if FABLE_COMPILER_TYPESCRIPT
                null |&gt; unbox&lt;unit&gt;
                () 
                #endif
#if FABLE_COMPILER_PYTHON
                null |&gt; unbox&lt;unit&gt;
                () 
                #endif
#else
                System.IO.File.Copy (v251, v262, true)
                () 
                #endif
                |&gt; fun x -&gt; _v487 &lt;- Some x
                _v487.Value
                let v493 : (string -&gt; (string -&gt; US18)) = closure53(v4, v3, v1, v0)
                let v494 : UH3 = UH3_0
                let v495 : UH3 = UH3_1(v263, v251, v493, v494)
                let v496 : string = "html"
                let v497 : (string -&gt; (string -&gt; US18)) = closure60(v4, v3)
                let v498 : string = "pdf"
                let v499 : string = "epub"
                let v500 : UH3 = UH3_0
                let v501 : UH3 = UH3_1(v499, v265, v497, v500)
                let v502 : UH3 = UH3_1(v498, v265, v497, v501)
                let v503 : UH3 = UH3_1(v496, v265, v497, v502)
                let v504 : UH3 = UH3_1(v499, v251, v497, v503)
                let v505 : UH3 = UH3_1(v498, v251, v497, v504)
                let v506 : UH3 = UH3_1(v496, v251, v497, v505)
                let v507 : UH2 = UH2_0
                let v508 : UH2 = UH2_1(v506, v507)
                UH2_1(v495, v508)
            else
                UH2_0
        else
            UH2_0
    let v515 : bool =
        match v513 with
        | UH2_0 -&gt; (* Nil *)
            true
        | _ -&gt;
            false
    let v516 : bool = v515 &lt;&gt; true
    let v941 : UH2 =
        if v516 then
            v513
        else
            let v517 : string = "epub"
            let struct (v518 : string, v519 : string) = method51(v517, v265, v4)
            let v520 : bool = true
            let mutable _v520 : bool option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v521 : string = "&amp;*$0"
            let v522 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v519 v521
            let v523 : string = "String::from($0)"
            let v524 : std_string_String = Fable.Core.RustInterop.emitRustExpr v522 v523
            let v525 : string = "std::path::PathBuf::from($0)"
            let v526 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v524 v525
            let v527 : string = "$0.exists()"
            let v528 : bool = Fable.Core.RustInterop.emitRustExpr v526 v527
            let v531 : bool =
                if v528 then
                    let v529 : string = "$0.is_file()"
                    let v530 : bool = Fable.Core.RustInterop.emitRustExpr v526 v529
                    v530
                else
                    false
            v531 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v532 : bool = null |&gt; unbox&lt;bool&gt;
            v532 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v533 : bool = null |&gt; unbox&lt;bool&gt;
            v533 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v534 : string = "fs"
            let v535 : IFsExistsSync = Fable.Core.JsInterop.importAll v534
            let v536 : string = "$0.existsSync($1)"
            let v537 : bool = Fable.Core.JsInterop.emitJsExpr struct (v535, v519) v536
            v537 
            #endif
#if FABLE_COMPILER_PYTHON
            let v538 : bool = null |&gt; unbox&lt;bool&gt;
            v538 
            #endif
#else
            let v539 : (string -&gt; bool) = System.IO.File.Exists
            let v540 : bool = v539 v519
            v540 
            #endif
            |&gt; fun x -&gt; _v520 &lt;- Some x
            let v541 : bool = _v520.Value
            let v542 : bool = v541 = false
            let v574 : bool =
                if v542 then
                    let v543 : bool = true
                    let mutable _v543 : bool option = None 
                    
#if FABLE_COMPILER || WASM || CONTRACT
                    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                    let v544 : string = "&amp;*$0"
                    let v545 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v518 v544
                    let v546 : string = "String::from($0)"
                    let v547 : std_string_String = Fable.Core.RustInterop.emitRustExpr v545 v546
                    let v548 : string = "std::path::PathBuf::from($0)"
                    let v549 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v547 v548
                    let v550 : string = "$0.exists()"
                    let v551 : bool = Fable.Core.RustInterop.emitRustExpr v549 v550
                    let v554 : bool =
                        if v551 then
                            let v552 : string = "$0.is_file()"
                            let v553 : bool = Fable.Core.RustInterop.emitRustExpr v549 v552
                            v553
                        else
                            false
                    v554 
                    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                    let v555 : bool = null |&gt; unbox&lt;bool&gt;
                    v555 
                    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                    let v556 : bool = null |&gt; unbox&lt;bool&gt;
                    v556 
                    #endif
#if FABLE_COMPILER_TYPESCRIPT
                    let v557 : IFsExistsSync = Fable.Core.JsInterop.importAll v534
                    let v558 : string = "$0.existsSync($1)"
                    let v559 : bool = Fable.Core.JsInterop.emitJsExpr struct (v557, v518) v558
                    v559 
                    #endif
#if FABLE_COMPILER_PYTHON
                    let v560 : bool = null |&gt; unbox&lt;bool&gt;
                    v560 
                    #endif
#else
                    let v561 : (string -&gt; bool) = System.IO.File.Exists
                    let v562 : bool = v561 v518
                    v562 
                    #endif
                    |&gt; fun x -&gt; _v543 &lt;- Some x
                    let v563 : bool = _v543.Value
                    if v563 then
                        let v564 : US0 = US0_2
                        let v565 : (unit -&gt; string) = closure64()
                        let v566 : (unit -&gt; string) = closure65(v518, v519)
                        method3(v564, v565, v566)
                        let v567 : bool = true
                        let mutable _v567 : unit option = None 
                        
#if FABLE_COMPILER || WASM || CONTRACT
                        
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                        let v568 : string = method53(v519)
                        let v569 : string = "std::fs::copy(&amp;*$0, &amp;*v568)"
                        let v570 : Result&lt;uint64, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr v518 v569
                        let v571 : string = "$0.unwrap()"
                        let v572 : uint64 = Fable.Core.RustInterop.emitRustExpr v570 v571
                        () 
                        #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                        null |&gt; unbox&lt;unit&gt;
                        () 
                        #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                        null |&gt; unbox&lt;unit&gt;
                        () 
                        #endif
#if FABLE_COMPILER_TYPESCRIPT
                        null |&gt; unbox&lt;unit&gt;
                        () 
                        #endif
#if FABLE_COMPILER_PYTHON
                        null |&gt; unbox&lt;unit&gt;
                        () 
                        #endif
#else
                        System.IO.File.Copy (v518, v519, true)
                        () 
                        #endif
                        |&gt; fun x -&gt; _v567 &lt;- Some x
                        _v567.Value
                        false
                    else
                        true
                else
                    true
            let v579 : UH3 =
                if v574 then
                    let v575 : (string -&gt; (string -&gt; US18)) = closure60(v4, v3)
                    let v576 : UH3 = UH3_0
                    UH3_1(v517, v265, v575, v576)
                else
                    UH3_0
            let v580 : string = "pdf"
            let struct (v581 : string, v582 : string) = method51(v580, v265, v4)
            let v583 : bool = true
            let mutable _v583 : bool option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v584 : string = "&amp;*$0"
            let v585 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v582 v584
            let v586 : string = "String::from($0)"
            let v587 : std_string_String = Fable.Core.RustInterop.emitRustExpr v585 v586
            let v588 : string = "std::path::PathBuf::from($0)"
            let v589 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v587 v588
            let v590 : string = "$0.exists()"
            let v591 : bool = Fable.Core.RustInterop.emitRustExpr v589 v590
            let v594 : bool =
                if v591 then
                    let v592 : string = "$0.is_file()"
                    let v593 : bool = Fable.Core.RustInterop.emitRustExpr v589 v592
                    v593
                else
                    false
            v594 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v595 : bool = null |&gt; unbox&lt;bool&gt;
            v595 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v596 : bool = null |&gt; unbox&lt;bool&gt;
            v596 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v597 : IFsExistsSync = Fable.Core.JsInterop.importAll v534
            let v598 : string = "$0.existsSync($1)"
            let v599 : bool = Fable.Core.JsInterop.emitJsExpr struct (v597, v582) v598
            v599 
            #endif
#if FABLE_COMPILER_PYTHON
            let v600 : bool = null |&gt; unbox&lt;bool&gt;
            v600 
            #endif
#else
            let v601 : (string -&gt; bool) = System.IO.File.Exists
            let v602 : bool = v601 v582
            v602 
            #endif
            |&gt; fun x -&gt; _v583 &lt;- Some x
            let v603 : bool = _v583.Value
            let v604 : bool = v603 = false
            let v636 : bool =
                if v604 then
                    let v605 : bool = true
                    let mutable _v605 : bool option = None 
                    
#if FABLE_COMPILER || WASM || CONTRACT
                    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                    let v606 : string = "&amp;*$0"
                    let v607 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v581 v606
                    let v608 : string = "String::from($0)"
                    let v609 : std_string_String = Fable.Core.RustInterop.emitRustExpr v607 v608
                    let v610 : string = "std::path::PathBuf::from($0)"
                    let v611 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v609 v610
                    let v612 : string = "$0.exists()"
                    let v613 : bool = Fable.Core.RustInterop.emitRustExpr v611 v612
                    let v616 : bool =
                        if v613 then
                            let v614 : string = "$0.is_file()"
                            let v615 : bool = Fable.Core.RustInterop.emitRustExpr v611 v614
                            v615
                        else
                            false
                    v616 
                    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                    let v617 : bool = null |&gt; unbox&lt;bool&gt;
                    v617 
                    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                    let v618 : bool = null |&gt; unbox&lt;bool&gt;
                    v618 
                    #endif
#if FABLE_COMPILER_TYPESCRIPT
                    let v619 : IFsExistsSync = Fable.Core.JsInterop.importAll v534
                    let v620 : string = "$0.existsSync($1)"
                    let v621 : bool = Fable.Core.JsInterop.emitJsExpr struct (v619, v581) v620
                    v621 
                    #endif
#if FABLE_COMPILER_PYTHON
                    let v622 : bool = null |&gt; unbox&lt;bool&gt;
                    v622 
                    #endif
#else
                    let v623 : (string -&gt; bool) = System.IO.File.Exists
                    let v624 : bool = v623 v581
                    v624 
                    #endif
                    |&gt; fun x -&gt; _v605 &lt;- Some x
                    let v625 : bool = _v605.Value
                    if v625 then
                        let v626 : US0 = US0_2
                        let v627 : (unit -&gt; string) = closure64()
                        let v628 : (unit -&gt; string) = closure65(v581, v582)
                        method3(v626, v627, v628)
                        let v629 : bool = true
                        let mutable _v629 : unit option = None 
                        
#if FABLE_COMPILER || WASM || CONTRACT
                        
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                        let v630 : string = method53(v582)
                        let v631 : string = "std::fs::copy(&amp;*$0, &amp;*v630)"
                        let v632 : Result&lt;uint64, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr v581 v631
                        let v633 : string = "$0.unwrap()"
                        let v634 : uint64 = Fable.Core.RustInterop.emitRustExpr v632 v633
                        () 
                        #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                        null |&gt; unbox&lt;unit&gt;
                        () 
                        #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                        null |&gt; unbox&lt;unit&gt;
                        () 
                        #endif
#if FABLE_COMPILER_TYPESCRIPT
                        null |&gt; unbox&lt;unit&gt;
                        () 
                        #endif
#if FABLE_COMPILER_PYTHON
                        null |&gt; unbox&lt;unit&gt;
                        () 
                        #endif
#else
                        System.IO.File.Copy (v581, v582, true)
                        () 
                        #endif
                        |&gt; fun x -&gt; _v629 &lt;- Some x
                        _v629.Value
                        false
                    else
                        true
                else
                    true
            let v639 : UH3 =
                if v636 then
                    let v637 : (string -&gt; (string -&gt; US18)) = closure60(v4, v3)
                    UH3_1(v580, v265, v637, v579)
                else
                    v579
            let v640 : string = "html"
            let struct (v641 : string, v642 : string) = method51(v640, v265, v4)
            let v643 : bool = true
            let mutable _v643 : bool option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v644 : string = "&amp;*$0"
            let v645 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v642 v644
            let v646 : string = "String::from($0)"
            let v647 : std_string_String = Fable.Core.RustInterop.emitRustExpr v645 v646
            let v648 : string = "std::path::PathBuf::from($0)"
            let v649 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v647 v648
            let v650 : string = "$0.exists()"
            let v651 : bool = Fable.Core.RustInterop.emitRustExpr v649 v650
            let v654 : bool =
                if v651 then
                    let v652 : string = "$0.is_file()"
                    let v653 : bool = Fable.Core.RustInterop.emitRustExpr v649 v652
                    v653
                else
                    false
            v654 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v655 : bool = null |&gt; unbox&lt;bool&gt;
            v655 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v656 : bool = null |&gt; unbox&lt;bool&gt;
            v656 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v657 : IFsExistsSync = Fable.Core.JsInterop.importAll v534
            let v658 : string = "$0.existsSync($1)"
            let v659 : bool = Fable.Core.JsInterop.emitJsExpr struct (v657, v642) v658
            v659 
            #endif
#if FABLE_COMPILER_PYTHON
            let v660 : bool = null |&gt; unbox&lt;bool&gt;
            v660 
            #endif
#else
            let v661 : (string -&gt; bool) = System.IO.File.Exists
            let v662 : bool = v661 v642
            v662 
            #endif
            |&gt; fun x -&gt; _v643 &lt;- Some x
            let v663 : bool = _v643.Value
            let v664 : bool = v663 = false
            let v696 : bool =
                if v664 then
                    let v665 : bool = true
                    let mutable _v665 : bool option = None 
                    
#if FABLE_COMPILER || WASM || CONTRACT
                    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                    let v666 : string = "&amp;*$0"
                    let v667 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v641 v666
                    let v668 : string = "String::from($0)"
                    let v669 : std_string_String = Fable.Core.RustInterop.emitRustExpr v667 v668
                    let v670 : string = "std::path::PathBuf::from($0)"
                    let v671 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v669 v670
                    let v672 : string = "$0.exists()"
                    let v673 : bool = Fable.Core.RustInterop.emitRustExpr v671 v672
                    let v676 : bool =
                        if v673 then
                            let v674 : string = "$0.is_file()"
                            let v675 : bool = Fable.Core.RustInterop.emitRustExpr v671 v674
                            v675
                        else
                            false
                    v676 
                    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                    let v677 : bool = null |&gt; unbox&lt;bool&gt;
                    v677 
                    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                    let v678 : bool = null |&gt; unbox&lt;bool&gt;
                    v678 
                    #endif
#if FABLE_COMPILER_TYPESCRIPT
                    let v679 : IFsExistsSync = Fable.Core.JsInterop.importAll v534
                    let v680 : string = "$0.existsSync($1)"
                    let v681 : bool = Fable.Core.JsInterop.emitJsExpr struct (v679, v641) v680
                    v681 
                    #endif
#if FABLE_COMPILER_PYTHON
                    let v682 : bool = null |&gt; unbox&lt;bool&gt;
                    v682 
                    #endif
#else
                    let v683 : (string -&gt; bool) = System.IO.File.Exists
                    let v684 : bool = v683 v641
                    v684 
                    #endif
                    |&gt; fun x -&gt; _v665 &lt;- Some x
                    let v685 : bool = _v665.Value
                    if v685 then
                        let v686 : US0 = US0_2
                        let v687 : (unit -&gt; string) = closure64()
                        let v688 : (unit -&gt; string) = closure65(v641, v642)
                        method3(v686, v687, v688)
                        let v689 : bool = true
                        let mutable _v689 : unit option = None 
                        
#if FABLE_COMPILER || WASM || CONTRACT
                        
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                        let v690 : string = method53(v642)
                        let v691 : string = "std::fs::copy(&amp;*$0, &amp;*v690)"
                        let v692 : Result&lt;uint64, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr v641 v691
                        let v693 : string = "$0.unwrap()"
                        let v694 : uint64 = Fable.Core.RustInterop.emitRustExpr v692 v693
                        () 
                        #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                        null |&gt; unbox&lt;unit&gt;
                        () 
                        #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                        null |&gt; unbox&lt;unit&gt;
                        () 
                        #endif
#if FABLE_COMPILER_TYPESCRIPT
                        null |&gt; unbox&lt;unit&gt;
                        () 
                        #endif
#if FABLE_COMPILER_PYTHON
                        null |&gt; unbox&lt;unit&gt;
                        () 
                        #endif
#else
                        System.IO.File.Copy (v641, v642, true)
                        () 
                        #endif
                        |&gt; fun x -&gt; _v689 &lt;- Some x
                        _v689.Value
                        false
                    else
                        true
                else
                    true
            let v699 : UH3 =
                if v696 then
                    let v697 : (string -&gt; (string -&gt; US18)) = closure60(v4, v3)
                    UH3_1(v640, v265, v697, v639)
                else
                    v639
            let struct (v700 : string, v701 : string) = method51(v517, v251, v4)
            let v702 : bool = true
            let mutable _v702 : bool option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v703 : string = "&amp;*$0"
            let v704 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v701 v703
            let v705 : string = "String::from($0)"
            let v706 : std_string_String = Fable.Core.RustInterop.emitRustExpr v704 v705
            let v707 : string = "std::path::PathBuf::from($0)"
            let v708 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v706 v707
            let v709 : string = "$0.exists()"
            let v710 : bool = Fable.Core.RustInterop.emitRustExpr v708 v709
            let v713 : bool =
                if v710 then
                    let v711 : string = "$0.is_file()"
                    let v712 : bool = Fable.Core.RustInterop.emitRustExpr v708 v711
                    v712
                else
                    false
            v713 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v714 : bool = null |&gt; unbox&lt;bool&gt;
            v714 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v715 : bool = null |&gt; unbox&lt;bool&gt;
            v715 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v716 : IFsExistsSync = Fable.Core.JsInterop.importAll v534
            let v717 : string = "$0.existsSync($1)"
            let v718 : bool = Fable.Core.JsInterop.emitJsExpr struct (v716, v701) v717
            v718 
            #endif
#if FABLE_COMPILER_PYTHON
            let v719 : bool = null |&gt; unbox&lt;bool&gt;
            v719 
            #endif
#else
            let v720 : (string -&gt; bool) = System.IO.File.Exists
            let v721 : bool = v720 v701
            v721 
            #endif
            |&gt; fun x -&gt; _v702 &lt;- Some x
            let v722 : bool = _v702.Value
            let v723 : bool = v722 = false
            let v755 : bool =
                if v723 then
                    let v724 : bool = true
                    let mutable _v724 : bool option = None 
                    
#if FABLE_COMPILER || WASM || CONTRACT
                    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                    let v725 : string = "&amp;*$0"
                    let v726 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v700 v725
                    let v727 : string = "String::from($0)"
                    let v728 : std_string_String = Fable.Core.RustInterop.emitRustExpr v726 v727
                    let v729 : string = "std::path::PathBuf::from($0)"
                    let v730 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v728 v729
                    let v731 : string = "$0.exists()"
                    let v732 : bool = Fable.Core.RustInterop.emitRustExpr v730 v731
                    let v735 : bool =
                        if v732 then
                            let v733 : string = "$0.is_file()"
                            let v734 : bool = Fable.Core.RustInterop.emitRustExpr v730 v733
                            v734
                        else
                            false
                    v735 
                    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                    let v736 : bool = null |&gt; unbox&lt;bool&gt;
                    v736 
                    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                    let v737 : bool = null |&gt; unbox&lt;bool&gt;
                    v737 
                    #endif
#if FABLE_COMPILER_TYPESCRIPT
                    let v738 : IFsExistsSync = Fable.Core.JsInterop.importAll v534
                    let v739 : string = "$0.existsSync($1)"
                    let v740 : bool = Fable.Core.JsInterop.emitJsExpr struct (v738, v700) v739
                    v740 
                    #endif
#if FABLE_COMPILER_PYTHON
                    let v741 : bool = null |&gt; unbox&lt;bool&gt;
                    v741 
                    #endif
#else
                    let v742 : (string -&gt; bool) = System.IO.File.Exists
                    let v743 : bool = v742 v700
                    v743 
                    #endif
                    |&gt; fun x -&gt; _v724 &lt;- Some x
                    let v744 : bool = _v724.Value
                    if v744 then
                        let v745 : US0 = US0_2
                        let v746 : (unit -&gt; string) = closure64()
                        let v747 : (unit -&gt; string) = closure65(v700, v701)
                        method3(v745, v746, v747)
                        let v748 : bool = true
                        let mutable _v748 : unit option = None 
                        
#if FABLE_COMPILER || WASM || CONTRACT
                        
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                        let v749 : string = method53(v701)
                        let v750 : string = "std::fs::copy(&amp;*$0, &amp;*v749)"
                        let v751 : Result&lt;uint64, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr v700 v750
                        let v752 : string = "$0.unwrap()"
                        let v753 : uint64 = Fable.Core.RustInterop.emitRustExpr v751 v752
                        () 
                        #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                        null |&gt; unbox&lt;unit&gt;
                        () 
                        #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                        null |&gt; unbox&lt;unit&gt;
                        () 
                        #endif
#if FABLE_COMPILER_TYPESCRIPT
                        null |&gt; unbox&lt;unit&gt;
                        () 
                        #endif
#if FABLE_COMPILER_PYTHON
                        null |&gt; unbox&lt;unit&gt;
                        () 
                        #endif
#else
                        System.IO.File.Copy (v700, v701, true)
                        () 
                        #endif
                        |&gt; fun x -&gt; _v748 &lt;- Some x
                        _v748.Value
                        false
                    else
                        true
                else
                    true
            let v758 : UH3 =
                if v755 then
                    let v756 : (string -&gt; (string -&gt; US18)) = closure60(v4, v3)
                    UH3_1(v517, v251, v756, v699)
                else
                    v699
            let struct (v759 : string, v760 : string) = method51(v580, v251, v4)
            let v761 : bool = true
            let mutable _v761 : bool option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v762 : string = "&amp;*$0"
            let v763 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v760 v762
            let v764 : string = "String::from($0)"
            let v765 : std_string_String = Fable.Core.RustInterop.emitRustExpr v763 v764
            let v766 : string = "std::path::PathBuf::from($0)"
            let v767 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v765 v766
            let v768 : string = "$0.exists()"
            let v769 : bool = Fable.Core.RustInterop.emitRustExpr v767 v768
            let v772 : bool =
                if v769 then
                    let v770 : string = "$0.is_file()"
                    let v771 : bool = Fable.Core.RustInterop.emitRustExpr v767 v770
                    v771
                else
                    false
            v772 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v773 : bool = null |&gt; unbox&lt;bool&gt;
            v773 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v774 : bool = null |&gt; unbox&lt;bool&gt;
            v774 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v775 : IFsExistsSync = Fable.Core.JsInterop.importAll v534
            let v776 : string = "$0.existsSync($1)"
            let v777 : bool = Fable.Core.JsInterop.emitJsExpr struct (v775, v760) v776
            v777 
            #endif
#if FABLE_COMPILER_PYTHON
            let v778 : bool = null |&gt; unbox&lt;bool&gt;
            v778 
            #endif
#else
            let v779 : (string -&gt; bool) = System.IO.File.Exists
            let v780 : bool = v779 v760
            v780 
            #endif
            |&gt; fun x -&gt; _v761 &lt;- Some x
            let v781 : bool = _v761.Value
            let v782 : bool = v781 = false
            let v814 : bool =
                if v782 then
                    let v783 : bool = true
                    let mutable _v783 : bool option = None 
                    
#if FABLE_COMPILER || WASM || CONTRACT
                    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                    let v784 : string = "&amp;*$0"
                    let v785 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v759 v784
                    let v786 : string = "String::from($0)"
                    let v787 : std_string_String = Fable.Core.RustInterop.emitRustExpr v785 v786
                    let v788 : string = "std::path::PathBuf::from($0)"
                    let v789 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v787 v788
                    let v790 : string = "$0.exists()"
                    let v791 : bool = Fable.Core.RustInterop.emitRustExpr v789 v790
                    let v794 : bool =
                        if v791 then
                            let v792 : string = "$0.is_file()"
                            let v793 : bool = Fable.Core.RustInterop.emitRustExpr v789 v792
                            v793
                        else
                            false
                    v794 
                    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                    let v795 : bool = null |&gt; unbox&lt;bool&gt;
                    v795 
                    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                    let v796 : bool = null |&gt; unbox&lt;bool&gt;
                    v796 
                    #endif
#if FABLE_COMPILER_TYPESCRIPT
                    let v797 : IFsExistsSync = Fable.Core.JsInterop.importAll v534
                    let v798 : string = "$0.existsSync($1)"
                    let v799 : bool = Fable.Core.JsInterop.emitJsExpr struct (v797, v759) v798
                    v799 
                    #endif
#if FABLE_COMPILER_PYTHON
                    let v800 : bool = null |&gt; unbox&lt;bool&gt;
                    v800 
                    #endif
#else
                    let v801 : (string -&gt; bool) = System.IO.File.Exists
                    let v802 : bool = v801 v759
                    v802 
                    #endif
                    |&gt; fun x -&gt; _v783 &lt;- Some x
                    let v803 : bool = _v783.Value
                    if v803 then
                        let v804 : US0 = US0_2
                        let v805 : (unit -&gt; string) = closure64()
                        let v806 : (unit -&gt; string) = closure65(v759, v760)
                        method3(v804, v805, v806)
                        let v807 : bool = true
                        let mutable _v807 : unit option = None 
                        
#if FABLE_COMPILER || WASM || CONTRACT
                        
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                        let v808 : string = method53(v760)
                        let v809 : string = "std::fs::copy(&amp;*$0, &amp;*v808)"
                        let v810 : Result&lt;uint64, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr v759 v809
                        let v811 : string = "$0.unwrap()"
                        let v812 : uint64 = Fable.Core.RustInterop.emitRustExpr v810 v811
                        () 
                        #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                        null |&gt; unbox&lt;unit&gt;
                        () 
                        #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                        null |&gt; unbox&lt;unit&gt;
                        () 
                        #endif
#if FABLE_COMPILER_TYPESCRIPT
                        null |&gt; unbox&lt;unit&gt;
                        () 
                        #endif
#if FABLE_COMPILER_PYTHON
                        null |&gt; unbox&lt;unit&gt;
                        () 
                        #endif
#else
                        System.IO.File.Copy (v759, v760, true)
                        () 
                        #endif
                        |&gt; fun x -&gt; _v807 &lt;- Some x
                        _v807.Value
                        false
                    else
                        true
                else
                    true
            let v817 : UH3 =
                if v814 then
                    let v815 : (string -&gt; (string -&gt; US18)) = closure60(v4, v3)
                    UH3_1(v580, v251, v815, v758)
                else
                    v758
            let struct (v818 : string, v819 : string) = method51(v640, v251, v4)
            let v820 : bool = true
            let mutable _v820 : bool option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v821 : string = "&amp;*$0"
            let v822 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v819 v821
            let v823 : string = "String::from($0)"
            let v824 : std_string_String = Fable.Core.RustInterop.emitRustExpr v822 v823
            let v825 : string = "std::path::PathBuf::from($0)"
            let v826 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v824 v825
            let v827 : string = "$0.exists()"
            let v828 : bool = Fable.Core.RustInterop.emitRustExpr v826 v827
            let v831 : bool =
                if v828 then
                    let v829 : string = "$0.is_file()"
                    let v830 : bool = Fable.Core.RustInterop.emitRustExpr v826 v829
                    v830
                else
                    false
            v831 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v832 : bool = null |&gt; unbox&lt;bool&gt;
            v832 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v833 : bool = null |&gt; unbox&lt;bool&gt;
            v833 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v834 : IFsExistsSync = Fable.Core.JsInterop.importAll v534
            let v835 : string = "$0.existsSync($1)"
            let v836 : bool = Fable.Core.JsInterop.emitJsExpr struct (v834, v819) v835
            v836 
            #endif
#if FABLE_COMPILER_PYTHON
            let v837 : bool = null |&gt; unbox&lt;bool&gt;
            v837 
            #endif
#else
            let v838 : (string -&gt; bool) = System.IO.File.Exists
            let v839 : bool = v838 v819
            v839 
            #endif
            |&gt; fun x -&gt; _v820 &lt;- Some x
            let v840 : bool = _v820.Value
            let v841 : bool = v840 = false
            let v873 : bool =
                if v841 then
                    let v842 : bool = true
                    let mutable _v842 : bool option = None 
                    
#if FABLE_COMPILER || WASM || CONTRACT
                    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                    let v843 : string = "&amp;*$0"
                    let v844 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v818 v843
                    let v845 : string = "String::from($0)"
                    let v846 : std_string_String = Fable.Core.RustInterop.emitRustExpr v844 v845
                    let v847 : string = "std::path::PathBuf::from($0)"
                    let v848 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v846 v847
                    let v849 : string = "$0.exists()"
                    let v850 : bool = Fable.Core.RustInterop.emitRustExpr v848 v849
                    let v853 : bool =
                        if v850 then
                            let v851 : string = "$0.is_file()"
                            let v852 : bool = Fable.Core.RustInterop.emitRustExpr v848 v851
                            v852
                        else
                            false
                    v853 
                    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                    let v854 : bool = null |&gt; unbox&lt;bool&gt;
                    v854 
                    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                    let v855 : bool = null |&gt; unbox&lt;bool&gt;
                    v855 
                    #endif
#if FABLE_COMPILER_TYPESCRIPT
                    let v856 : IFsExistsSync = Fable.Core.JsInterop.importAll v534
                    let v857 : string = "$0.existsSync($1)"
                    let v858 : bool = Fable.Core.JsInterop.emitJsExpr struct (v856, v818) v857
                    v858 
                    #endif
#if FABLE_COMPILER_PYTHON
                    let v859 : bool = null |&gt; unbox&lt;bool&gt;
                    v859 
                    #endif
#else
                    let v860 : (string -&gt; bool) = System.IO.File.Exists
                    let v861 : bool = v860 v818
                    v861 
                    #endif
                    |&gt; fun x -&gt; _v842 &lt;- Some x
                    let v862 : bool = _v842.Value
                    if v862 then
                        let v863 : US0 = US0_2
                        let v864 : (unit -&gt; string) = closure64()
                        let v865 : (unit -&gt; string) = closure65(v818, v819)
                        method3(v863, v864, v865)
                        let v866 : bool = true
                        let mutable _v866 : unit option = None 
                        
#if FABLE_COMPILER || WASM || CONTRACT
                        
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                        let v867 : string = method53(v819)
                        let v868 : string = "std::fs::copy(&amp;*$0, &amp;*v867)"
                        let v869 : Result&lt;uint64, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr v818 v868
                        let v870 : string = "$0.unwrap()"
                        let v871 : uint64 = Fable.Core.RustInterop.emitRustExpr v869 v870
                        () 
                        #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                        null |&gt; unbox&lt;unit&gt;
                        () 
                        #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                        null |&gt; unbox&lt;unit&gt;
                        () 
                        #endif
#if FABLE_COMPILER_TYPESCRIPT
                        null |&gt; unbox&lt;unit&gt;
                        () 
                        #endif
#if FABLE_COMPILER_PYTHON
                        null |&gt; unbox&lt;unit&gt;
                        () 
                        #endif
#else
                        System.IO.File.Copy (v818, v819, true)
                        () 
                        #endif
                        |&gt; fun x -&gt; _v866 &lt;- Some x
                        _v866.Value
                        false
                    else
                        true
                else
                    true
            let v876 : UH3 =
                if v873 then
                    let v874 : (string -&gt; (string -&gt; US18)) = closure60(v4, v3)
                    UH3_1(v640, v251, v874, v817)
                else
                    v817
            let struct (v877 : string, v878 : string) = method51(v263, v251, v4)
            let v879 : bool = true
            let mutable _v879 : bool option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v880 : string = "&amp;*$0"
            let v881 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v878 v880
            let v882 : string = "String::from($0)"
            let v883 : std_string_String = Fable.Core.RustInterop.emitRustExpr v881 v882
            let v884 : string = "std::path::PathBuf::from($0)"
            let v885 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v883 v884
            let v886 : string = "$0.exists()"
            let v887 : bool = Fable.Core.RustInterop.emitRustExpr v885 v886
            let v890 : bool =
                if v887 then
                    let v888 : string = "$0.is_file()"
                    let v889 : bool = Fable.Core.RustInterop.emitRustExpr v885 v888
                    v889
                else
                    false
            v890 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v891 : bool = null |&gt; unbox&lt;bool&gt;
            v891 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v892 : bool = null |&gt; unbox&lt;bool&gt;
            v892 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v893 : IFsExistsSync = Fable.Core.JsInterop.importAll v534
            let v894 : string = "$0.existsSync($1)"
            let v895 : bool = Fable.Core.JsInterop.emitJsExpr struct (v893, v878) v894
            v895 
            #endif
#if FABLE_COMPILER_PYTHON
            let v896 : bool = null |&gt; unbox&lt;bool&gt;
            v896 
            #endif
#else
            let v897 : (string -&gt; bool) = System.IO.File.Exists
            let v898 : bool = v897 v878
            v898 
            #endif
            |&gt; fun x -&gt; _v879 &lt;- Some x
            let v899 : bool = _v879.Value
            let v900 : bool = v899 = false
            let v932 : bool =
                if v900 then
                    let v901 : bool = true
                    let mutable _v901 : bool option = None 
                    
#if FABLE_COMPILER || WASM || CONTRACT
                    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                    let v902 : string = "&amp;*$0"
                    let v903 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v877 v902
                    let v904 : string = "String::from($0)"
                    let v905 : std_string_String = Fable.Core.RustInterop.emitRustExpr v903 v904
                    let v906 : string = "std::path::PathBuf::from($0)"
                    let v907 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v905 v906
                    let v908 : string = "$0.exists()"
                    let v909 : bool = Fable.Core.RustInterop.emitRustExpr v907 v908
                    let v912 : bool =
                        if v909 then
                            let v910 : string = "$0.is_file()"
                            let v911 : bool = Fable.Core.RustInterop.emitRustExpr v907 v910
                            v911
                        else
                            false
                    v912 
                    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                    let v913 : bool = null |&gt; unbox&lt;bool&gt;
                    v913 
                    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                    let v914 : bool = null |&gt; unbox&lt;bool&gt;
                    v914 
                    #endif
#if FABLE_COMPILER_TYPESCRIPT
                    let v915 : IFsExistsSync = Fable.Core.JsInterop.importAll v534
                    let v916 : string = "$0.existsSync($1)"
                    let v917 : bool = Fable.Core.JsInterop.emitJsExpr struct (v915, v877) v916
                    v917 
                    #endif
#if FABLE_COMPILER_PYTHON
                    let v918 : bool = null |&gt; unbox&lt;bool&gt;
                    v918 
                    #endif
#else
                    let v919 : (string -&gt; bool) = System.IO.File.Exists
                    let v920 : bool = v919 v877
                    v920 
                    #endif
                    |&gt; fun x -&gt; _v901 &lt;- Some x
                    let v921 : bool = _v901.Value
                    if v921 then
                        let v922 : US0 = US0_2
                        let v923 : (unit -&gt; string) = closure64()
                        let v924 : (unit -&gt; string) = closure65(v877, v878)
                        method3(v922, v923, v924)
                        let v925 : bool = true
                        let mutable _v925 : unit option = None 
                        
#if FABLE_COMPILER || WASM || CONTRACT
                        
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                        let v926 : string = method53(v878)
                        let v927 : string = "std::fs::copy(&amp;*$0, &amp;*v926)"
                        let v928 : Result&lt;uint64, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr v877 v927
                        let v929 : string = "$0.unwrap()"
                        let v930 : uint64 = Fable.Core.RustInterop.emitRustExpr v928 v929
                        () 
                        #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                        null |&gt; unbox&lt;unit&gt;
                        () 
                        #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                        null |&gt; unbox&lt;unit&gt;
                        () 
                        #endif
#if FABLE_COMPILER_TYPESCRIPT
                        null |&gt; unbox&lt;unit&gt;
                        () 
                        #endif
#if FABLE_COMPILER_PYTHON
                        null |&gt; unbox&lt;unit&gt;
                        () 
                        #endif
#else
                        System.IO.File.Copy (v877, v878, true)
                        () 
                        #endif
                        |&gt; fun x -&gt; _v925 &lt;- Some x
                        _v925.Value
                        false
                    else
                        true
                else
                    true
            let v937 : UH3 =
                if v932 then
                    let v933 : (string -&gt; (string -&gt; US18)) = closure53(v4, v3, v1, v0)
                    let v934 : UH3 = UH3_0
                    UH3_1(v263, v251, v933, v934)
                else
                    UH3_0
            let v938 : UH2 = UH2_0
            let v939 : UH2 = UH2_1(v876, v938)
            UH2_1(v937, v939)
    let v942 : UH3 list = []
    let v943 : UH3 list = method61(v941, v942)
    let v944 : (UH3 list -&gt; (UH3 [])) = List.toArray
    let v945 : (UH3 []) = v944 v943
    let v946 : string = "$0.to_vec()"
    let v947 : Vec&lt;UH3&gt; = Fable.Core.RustInterop.emitRustExpr v945 v946
    let v948 : (Result&lt;string, (string * string)&gt; option []) = [||]
    let v949 : string = "$0.to_vec()"
    let v950 : Vec&lt;Result&lt;string, (string * string)&gt; option&gt; = Fable.Core.RustInterop.emitRustExpr v948 v949
    let v951 : string = "fable_library_rust::NativeArray_::array_from($0)"
    let v952 : (UH3 []) = Fable.Core.RustInterop.emitRustExpr v947 v951
    let v953 : int32 = v952.Length
    let v954 : Mut8 = {l0 = 0; l1 = v950} : Mut8
    while method62(v953, v954) do
        let v956 : int32 = v954.l0
        let v957 : Vec&lt;Result&lt;string, (string * string)&gt; option&gt; = v954.l1
        let v958 : UH3 = v952.[int v956]
        let v959 : struct (string * string * (string -&gt; (string -&gt; US18))) list = []
        let v960 : struct (string * string * (string -&gt; (string -&gt; US18))) list = method63(v958, v959)
        let v961 : (struct (string * string * (string -&gt; (string -&gt; US18))) list -&gt; (struct (string * string * (string -&gt; (string -&gt; US18))) [])) = List.toArray
        let v962 : (struct (string * string * (string -&gt; (string -&gt; US18))) []) = v961 v960
        let v963 : string = "$0.to_vec()"
        let v964 : Vec&lt;struct (string * string * (string -&gt; (string -&gt; US18)))&gt; = Fable.Core.RustInterop.emitRustExpr v962 v963
        let v965 : string = "rayon::iter::IntoParallelIterator::into_par_iter(v964)"
        let v966 : rayon_vec_IntoIter&lt;struct (string * string * (string -&gt; (string -&gt; US18)))&gt; = Fable.Core.RustInterop.emitRustExpr () v965
        let v967 : string = "rayon::iter::ParallelIterator::map($0, |x| $1(x))"
        let v968 : (struct (string * string * (string -&gt; (string -&gt; US18))) -&gt; Result&lt;string, (string * string)&gt; option) = closure66()
        let v969 : rayon_iter_Map&lt;rayon_vec_IntoIter&lt;struct (string * string * (string -&gt; (string -&gt; US18)))&gt;&gt; = Fable.Core.RustInterop.emitRustExpr struct (v966, v968) v967
        let v970 : string = "rayon::iter::ParallelIterator::collect($0)"
        let v971 : Vec&lt;Result&lt;string, (string * string)&gt; option&gt; = Fable.Core.RustInterop.emitRustExpr v969 v970
        let v972 : Vec&lt;Result&lt;string, (string * string)&gt; option&gt; = method64(v971)
        let v973 : Vec&lt;Result&lt;string, (string * string)&gt; option&gt; = method65(v957)
        let v974 : string = "true; let mut v973 = v973"
        let v975 : bool = Fable.Core.RustInterop.emitRustExpr () v974
        let v976 : string = "true; v973.extend(v972)"
        let v977 : bool = Fable.Core.RustInterop.emitRustExpr () v976
        let v978 : string = "v973"
        let v979 : Vec&lt;Result&lt;string, (string * string)&gt; option&gt; = Fable.Core.RustInterop.emitRustExpr () v978
        let v980 : int32 = v956 + 1
        v954.l0 &lt;- v980
        v954.l1 &lt;- v979
        ()
    let v981 : Vec&lt;Result&lt;string, (string * string)&gt; option&gt; = v954.l1
    let v982 : (string * Vec&lt;Result&lt;string, (string * string)&gt; option&gt;) = v238, v981
    let v983 : Result&lt;(string * Vec&lt;Result&lt;string, (string * string)&gt; option&gt;), std_string_String&gt; = Ok v982
    v983
and closure67 () () : string =
    let v0 : string = "documents.run"
    v0
and closure68 (v0 : Vec&lt;Result&lt;(string * Vec&lt;Result&lt;string, (string * string)&gt; option&gt;), std_string_String&gt;&gt;) () : string =
    let v1 : string = "$0.len()"
    let v2 : unativeint = Fable.Core.RustInterop.emitRustExpr v0 v1
    let v3 : (unit -&gt; string) = closure6()
    let v4 : string = $"result_len: {v2} / {v3 ()}"
    v4
and method66 (v0 : Result&lt;Vec&lt;Result&lt;(string * Vec&lt;Result&lt;string, (string * string)&gt; option&gt;), std_string_String&gt;&gt;, std_string_String&gt;) : Result&lt;Vec&lt;Result&lt;(string * Vec&lt;Result&lt;string, (string * string)&gt; option&gt;), std_string_String&gt;&gt;, std_string_String&gt; =
    v0
and method10 (v0 : string, v1 : string, v2 : string, v3 : string) : std_pin_Pin&lt;Box&lt;Dyn&lt;std_future_Future&lt;Result&lt;Vec&lt;Result&lt;(string * Vec&lt;Result&lt;string, (string * string)&gt; option&gt;), std_string_String&gt;&gt;, std_string_String&gt;&gt;&gt;&gt;&gt; =
    let v4 : string = __SOURCE_DIRECTORY__
    let v5 : string = "polyglot"
    let v6 : string = ".paket"
    let v7 : string = method11(v5, v6)
    let v8 : string = method14(v7, v4)
    let v9 : string = method11(v8, v5)
    let v10 : bool = true
    let mutable _v10 : string option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v11 : string = method17(v3)
    let v12 : string = "&amp;*$0"
    let v13 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v11 v12
    let v14 : string = "String::from($0)"
    let v15 : std_string_String = Fable.Core.RustInterop.emitRustExpr v13 v14
    let v16 : string = "std::path::PathBuf::from($0)"
    let v17 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v15 v16
    let v18 : string = "$0.exists()"
    let v19 : bool = Fable.Core.RustInterop.emitRustExpr v17 v18
    let v20 : bool = v19 = false
    let v176 : string =
        if v20 then
            let v21 : bool = true
            let mutable _v21 : string option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v22 : string = "std::env::current_dir()"
            let v23 : Result&lt;std_path_PathBuf, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr () v22
            let v24 : string = "$0.unwrap()"
            let v25 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v23 v24
            let v26 : string = "$0.display()"
            let v27 : std_path_Display = Fable.Core.RustInterop.emitRustExpr v25 v26
            let v28 : bool = true
            let mutable _v28 : std_string_String option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v29 : string = "format!(\"{}\", $0)"
            let v30 : std_string_String = Fable.Core.RustInterop.emitRustExpr v27 v29
            v30 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v31 : string = "format!(\"{}\", $0)"
            let v32 : std_string_String = Fable.Core.RustInterop.emitRustExpr v27 v31
            v32 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v33 : string = "format!(\"{}\", $0)"
            let v34 : std_string_String = Fable.Core.RustInterop.emitRustExpr v27 v33
            v34 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v35 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v35 
            #endif
#if FABLE_COMPILER_PYTHON
            let v36 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v36 
            #endif
#else
            let v37 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v37 
            #endif
            |&gt; fun x -&gt; _v28 &lt;- Some x
            let v38 : std_string_String = _v28.Value
            let v39 : string = "fable_library_rust::String_::fromString($0)"
            let v40 : string = Fable.Core.RustInterop.emitRustExpr v38 v39
            v40 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v41 : string = null |&gt; unbox&lt;string&gt;
            v41 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v42 : string = null |&gt; unbox&lt;string&gt;
            v42 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v43 : string = null |&gt; unbox&lt;string&gt;
            v43 
            #endif
#if FABLE_COMPILER_PYTHON
            let v44 : string = null |&gt; unbox&lt;string&gt;
            v44 
            #endif
#else
            let v45 : (unit -&gt; string) = System.IO.Directory.GetCurrentDirectory
            let v46 : string = v45 ()
            v46 
            #endif
            |&gt; fun x -&gt; _v21 &lt;- Some x
            let v47 : string = _v21.Value
            let v48 : string = method11(v47, v11)
            let v49 : bool = true
            let mutable _v49 : string option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v50 : string = method18(v48)
            let v51 : string = method19()
            let v52 : bool = true
            let mutable _v52 : Result&lt;regex_Regex, regex_Error&gt; option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v53 : string = method20()
            let v54 : string = $"regex::Regex::new(&amp;$0)"
            let v55 : Result&lt;regex_Regex, regex_Error&gt; = Fable.Core.RustInterop.emitRustExpr v53 v54
            v55 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v56 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v56 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v57 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v57 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v58 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v58 
            #endif
#if FABLE_COMPILER_PYTHON
            let v59 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v59 
            #endif
#else
            let v60 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v60 
            #endif
            |&gt; fun x -&gt; _v52 &lt;- Some x
            let v61 : Result&lt;regex_Regex, regex_Error&gt; = _v52.Value
            let v62 : string = "$0.unwrap()"
            let v63 : regex_Regex = Fable.Core.RustInterop.emitRustExpr v61 v62
            let v64 : string = $"$0.replace_all(&amp;$1, &amp;*$2)"
            let v65 : std_borrow_Cow&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr struct (v63, v50, v51) v64
            let v66 : string = "String::from($0)"
            let v67 : std_string_String = Fable.Core.RustInterop.emitRustExpr v65 v66
            let v68 : string = "fable_library_rust::String_::fromString($0)"
            let v69 : string = Fable.Core.RustInterop.emitRustExpr v67 v68
            v69 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v70 : string = null |&gt; unbox&lt;string&gt;
            v70 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v71 : string = null |&gt; unbox&lt;string&gt;
            v71 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v72 : string = null |&gt; unbox&lt;string&gt;
            v72 
            #endif
#if FABLE_COMPILER_PYTHON
            let v73 : string = null |&gt; unbox&lt;string&gt;
            v73 
            #endif
#else
            let v74 : string = method21()
            let v75 : string = "^\\\\\\\\\\?\\\\"
            let v76 : string = System.Text.RegularExpressions.Regex.Replace (v48, v75, v74)
            v76 
            #endif
            |&gt; fun x -&gt; _v49 &lt;- Some x
            let v77 : string = _v49.Value
            let v78 : string = $"{v77.[0] |&gt; string |&gt; _.ToLower()}{v77.[1..]}"
            let v79 : string = "\\"
            let v80 : string = "/"
            let v81 : string = v78.Replace (v79, v80)
            let v82 : (string []) = v81.Split v80
            let v83 : (string []) = [||]
            let v84 : int32 = v82.Length
            let v85 : Mut4 = {l0 = 0; l1 = 0; l2 = v83} : Mut4
            while method22(v84, v85) do
                let v87 : int32 = v85.l0
                let v88 : int32 =  -v87
                let v89 : int32 = v88 + v84
                let v90 : int32 = v89 - 1
                let struct (v91 : int32, v92 : (string [])) = v85.l1, v85.l2
                let v93 : string = v82.[int v90]
                let v94 : bool = ".." = v93
                let struct (v136 : int32, v137 : (string [])) =
                    if v94 then
                        let v95 : int32 = v91 + 1
                        struct (v95, v92)
                    else
                        let v96 : bool = "." = v93
                        if v96 then
                            struct (v91, v92)
                        else
                            let v97 : bool = 0 = v91
                            if v97 then
                                let v98 : string = ":"
                                let v99 : bool = v93.EndsWith v98
                                if v99 then
                                    let v100 : string = $"{v47.[0]}:"
                                    let v101 : (string []) = [|v100|]
                                    let v102 : int32 = v101.Length
                                    let v103 : int32 = v92.Length
                                    let v104 : int32 = v102 + v103
                                    let v105 : (string []) = Array.zeroCreate&lt;string&gt; (v104)
                                    let v106 : Mut5 = {l0 = 0} : Mut5
                                    while method23(v104, v106) do
                                        let v108 : int32 = v106.l0
                                        let v109 : bool = v108 &lt; v102
                                        let v113 : string =
                                            if v109 then
                                                let v110 : string = v101.[int v108]
                                                v110
                                            else
                                                let v111 : int32 = v108 - v102
                                                let v112 : string = v92.[int v111]
                                                v112
                                        v105.[int v108] &lt;- v113
                                        let v114 : int32 = v108 + 1
                                        v106.l0 &lt;- v114
                                        ()
                                    struct (0, v105)
                                else
                                    let v115 : (string []) = [|v93|]
                                    let v116 : int32 = v115.Length
                                    let v117 : int32 = v92.Length
                                    let v118 : int32 = v116 + v117
                                    let v119 : (string []) = Array.zeroCreate&lt;string&gt; (v118)
                                    let v120 : Mut5 = {l0 = 0} : Mut5
                                    while method23(v118, v120) do
                                        let v122 : int32 = v120.l0
                                        let v123 : bool = v122 &lt; v116
                                        let v127 : string =
                                            if v123 then
                                                let v124 : string = v115.[int v122]
                                                v124
                                            else
                                                let v125 : int32 = v122 - v116
                                                let v126 : string = v92.[int v125]
                                                v126
                                        v119.[int v122] &lt;- v127
                                        let v128 : int32 = v122 + 1
                                        v120.l0 &lt;- v128
                                        ()
                                    struct (0, v119)
                            else
                                let v131 : int32 = v91 - 1
                                struct (v131, v92)
                let v138 : int32 = v87 + 1
                v85.l0 &lt;- v138
                v85.l1 &lt;- v136
                v85.l2 &lt;- v137
                ()
            let struct (v139 : int32, v140 : (string [])) = v85.l1, v85.l2
            let v141 : string seq = seq { for i = 0 to v140.Length - 1 do yield v140.[i] }
            let v142 : bool = true
            let mutable _v142 : char option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v143 : string = "std::path::MAIN_SEPARATOR"
            let v144 : char = Fable.Core.RustInterop.emitRustExpr () v143
            v144 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v145 : char = null |&gt; unbox&lt;char&gt;
            v145 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v146 : char = null |&gt; unbox&lt;char&gt;
            v146 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v147 : char = null |&gt; unbox&lt;char&gt;
            v147 
            #endif
#if FABLE_COMPILER_PYTHON
            let v148 : char = null |&gt; unbox&lt;char&gt;
            v148 
            #endif
#else
            let v149 : char = System.IO.Path.DirectorySeparatorChar
            v149 
            #endif
            |&gt; fun x -&gt; _v142 &lt;- Some x
            let v150 : char = _v142.Value
            let v151 : (char -&gt; string) = _.ToString()
            let v152 : string = v151 v150
            let v153 : string = method24(v152)
            let v154 : (string -&gt; (string seq -&gt; string)) = String.concat
            let v155 : (string seq -&gt; string) = v154 v153
            v155 v141
        else
            let v157 : string = "std::fs::canonicalize(&amp;*$0)"
            let v158 : Result&lt;std_path_PathBuf, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr v11 v157
            let v159 : string = "$0.unwrap()"
            let v160 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v158 v159
            let v161 : string = "$0.display()"
            let v162 : std_path_Display = Fable.Core.RustInterop.emitRustExpr v160 v161
            let v163 : bool = true
            let mutable _v163 : std_string_String option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v164 : string = "format!(\"{}\", $0)"
            let v165 : std_string_String = Fable.Core.RustInterop.emitRustExpr v162 v164
            v165 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v166 : string = "format!(\"{}\", $0)"
            let v167 : std_string_String = Fable.Core.RustInterop.emitRustExpr v162 v166
            v167 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v168 : string = "format!(\"{}\", $0)"
            let v169 : std_string_String = Fable.Core.RustInterop.emitRustExpr v162 v168
            v169 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v170 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v170 
            #endif
#if FABLE_COMPILER_PYTHON
            let v171 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v171 
            #endif
#else
            let v172 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v172 
            #endif
            |&gt; fun x -&gt; _v163 &lt;- Some x
            let v173 : std_string_String = _v163.Value
            let v174 : string = "fable_library_rust::String_::fromString($0)"
            let v175 : string = Fable.Core.RustInterop.emitRustExpr v173 v174
            v175
    v176 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v177 : string = null |&gt; unbox&lt;string&gt;
    v177 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v178 : string = null |&gt; unbox&lt;string&gt;
    v178 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v179 : string = null |&gt; unbox&lt;string&gt;
    v179 
    #endif
#if FABLE_COMPILER_PYTHON
    let v180 : string = null |&gt; unbox&lt;string&gt;
    v180 
    #endif
#else
    let v181 : string = method25(v3)
    let v182 : (string -&gt; string) = System.IO.Path.GetFullPath
    let v183 : string = v182 v181
    v183 
    #endif
    |&gt; fun x -&gt; _v10 &lt;- Some x
    let v184 : string = _v10.Value
    let v185 : bool = true
    let mutable _v185 : string option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v186 : string = method17(v2)
    let v187 : string = "&amp;*$0"
    let v188 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v186 v187
    let v189 : string = "String::from($0)"
    let v190 : std_string_String = Fable.Core.RustInterop.emitRustExpr v188 v189
    let v191 : string = "std::path::PathBuf::from($0)"
    let v192 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v190 v191
    let v193 : string = "$0.exists()"
    let v194 : bool = Fable.Core.RustInterop.emitRustExpr v192 v193
    let v195 : bool = v194 = false
    let v351 : string =
        if v195 then
            let v196 : bool = true
            let mutable _v196 : string option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v197 : string = "std::env::current_dir()"
            let v198 : Result&lt;std_path_PathBuf, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr () v197
            let v199 : string = "$0.unwrap()"
            let v200 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v198 v199
            let v201 : string = "$0.display()"
            let v202 : std_path_Display = Fable.Core.RustInterop.emitRustExpr v200 v201
            let v203 : bool = true
            let mutable _v203 : std_string_String option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v204 : string = "format!(\"{}\", $0)"
            let v205 : std_string_String = Fable.Core.RustInterop.emitRustExpr v202 v204
            v205 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v206 : string = "format!(\"{}\", $0)"
            let v207 : std_string_String = Fable.Core.RustInterop.emitRustExpr v202 v206
            v207 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v208 : string = "format!(\"{}\", $0)"
            let v209 : std_string_String = Fable.Core.RustInterop.emitRustExpr v202 v208
            v209 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v210 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v210 
            #endif
#if FABLE_COMPILER_PYTHON
            let v211 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v211 
            #endif
#else
            let v212 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v212 
            #endif
            |&gt; fun x -&gt; _v203 &lt;- Some x
            let v213 : std_string_String = _v203.Value
            let v214 : string = "fable_library_rust::String_::fromString($0)"
            let v215 : string = Fable.Core.RustInterop.emitRustExpr v213 v214
            v215 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v216 : string = null |&gt; unbox&lt;string&gt;
            v216 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v217 : string = null |&gt; unbox&lt;string&gt;
            v217 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v218 : string = null |&gt; unbox&lt;string&gt;
            v218 
            #endif
#if FABLE_COMPILER_PYTHON
            let v219 : string = null |&gt; unbox&lt;string&gt;
            v219 
            #endif
#else
            let v220 : (unit -&gt; string) = System.IO.Directory.GetCurrentDirectory
            let v221 : string = v220 ()
            v221 
            #endif
            |&gt; fun x -&gt; _v196 &lt;- Some x
            let v222 : string = _v196.Value
            let v223 : string = method11(v222, v186)
            let v224 : bool = true
            let mutable _v224 : string option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v225 : string = method18(v223)
            let v226 : string = method19()
            let v227 : bool = true
            let mutable _v227 : Result&lt;regex_Regex, regex_Error&gt; option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v228 : string = method20()
            let v229 : string = $"regex::Regex::new(&amp;$0)"
            let v230 : Result&lt;regex_Regex, regex_Error&gt; = Fable.Core.RustInterop.emitRustExpr v228 v229
            v230 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v231 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v231 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v232 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v232 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v233 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v233 
            #endif
#if FABLE_COMPILER_PYTHON
            let v234 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v234 
            #endif
#else
            let v235 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v235 
            #endif
            |&gt; fun x -&gt; _v227 &lt;- Some x
            let v236 : Result&lt;regex_Regex, regex_Error&gt; = _v227.Value
            let v237 : string = "$0.unwrap()"
            let v238 : regex_Regex = Fable.Core.RustInterop.emitRustExpr v236 v237
            let v239 : string = $"$0.replace_all(&amp;$1, &amp;*$2)"
            let v240 : std_borrow_Cow&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr struct (v238, v225, v226) v239
            let v241 : string = "String::from($0)"
            let v242 : std_string_String = Fable.Core.RustInterop.emitRustExpr v240 v241
            let v243 : string = "fable_library_rust::String_::fromString($0)"
            let v244 : string = Fable.Core.RustInterop.emitRustExpr v242 v243
            v244 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v245 : string = null |&gt; unbox&lt;string&gt;
            v245 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v246 : string = null |&gt; unbox&lt;string&gt;
            v246 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v247 : string = null |&gt; unbox&lt;string&gt;
            v247 
            #endif
#if FABLE_COMPILER_PYTHON
            let v248 : string = null |&gt; unbox&lt;string&gt;
            v248 
            #endif
#else
            let v249 : string = method21()
            let v250 : string = "^\\\\\\\\\\?\\\\"
            let v251 : string = System.Text.RegularExpressions.Regex.Replace (v223, v250, v249)
            v251 
            #endif
            |&gt; fun x -&gt; _v224 &lt;- Some x
            let v252 : string = _v224.Value
            let v253 : string = $"{v252.[0] |&gt; string |&gt; _.ToLower()}{v252.[1..]}"
            let v254 : string = "\\"
            let v255 : string = "/"
            let v256 : string = v253.Replace (v254, v255)
            let v257 : (string []) = v256.Split v255
            let v258 : (string []) = [||]
            let v259 : int32 = v257.Length
            let v260 : Mut4 = {l0 = 0; l1 = 0; l2 = v258} : Mut4
            while method22(v259, v260) do
                let v262 : int32 = v260.l0
                let v263 : int32 =  -v262
                let v264 : int32 = v263 + v259
                let v265 : int32 = v264 - 1
                let struct (v266 : int32, v267 : (string [])) = v260.l1, v260.l2
                let v268 : string = v257.[int v265]
                let v269 : bool = ".." = v268
                let struct (v311 : int32, v312 : (string [])) =
                    if v269 then
                        let v270 : int32 = v266 + 1
                        struct (v270, v267)
                    else
                        let v271 : bool = "." = v268
                        if v271 then
                            struct (v266, v267)
                        else
                            let v272 : bool = 0 = v266
                            if v272 then
                                let v273 : string = ":"
                                let v274 : bool = v268.EndsWith v273
                                if v274 then
                                    let v275 : string = $"{v222.[0]}:"
                                    let v276 : (string []) = [|v275|]
                                    let v277 : int32 = v276.Length
                                    let v278 : int32 = v267.Length
                                    let v279 : int32 = v277 + v278
                                    let v280 : (string []) = Array.zeroCreate&lt;string&gt; (v279)
                                    let v281 : Mut5 = {l0 = 0} : Mut5
                                    while method23(v279, v281) do
                                        let v283 : int32 = v281.l0
                                        let v284 : bool = v283 &lt; v277
                                        let v288 : string =
                                            if v284 then
                                                let v285 : string = v276.[int v283]
                                                v285
                                            else
                                                let v286 : int32 = v283 - v277
                                                let v287 : string = v267.[int v286]
                                                v287
                                        v280.[int v283] &lt;- v288
                                        let v289 : int32 = v283 + 1
                                        v281.l0 &lt;- v289
                                        ()
                                    struct (0, v280)
                                else
                                    let v290 : (string []) = [|v268|]
                                    let v291 : int32 = v290.Length
                                    let v292 : int32 = v267.Length
                                    let v293 : int32 = v291 + v292
                                    let v294 : (string []) = Array.zeroCreate&lt;string&gt; (v293)
                                    let v295 : Mut5 = {l0 = 0} : Mut5
                                    while method23(v293, v295) do
                                        let v297 : int32 = v295.l0
                                        let v298 : bool = v297 &lt; v291
                                        let v302 : string =
                                            if v298 then
                                                let v299 : string = v290.[int v297]
                                                v299
                                            else
                                                let v300 : int32 = v297 - v291
                                                let v301 : string = v267.[int v300]
                                                v301
                                        v294.[int v297] &lt;- v302
                                        let v303 : int32 = v297 + 1
                                        v295.l0 &lt;- v303
                                        ()
                                    struct (0, v294)
                            else
                                let v306 : int32 = v266 - 1
                                struct (v306, v267)
                let v313 : int32 = v262 + 1
                v260.l0 &lt;- v313
                v260.l1 &lt;- v311
                v260.l2 &lt;- v312
                ()
            let struct (v314 : int32, v315 : (string [])) = v260.l1, v260.l2
            let v316 : string seq = seq { for i = 0 to v315.Length - 1 do yield v315.[i] }
            let v317 : bool = true
            let mutable _v317 : char option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v318 : string = "std::path::MAIN_SEPARATOR"
            let v319 : char = Fable.Core.RustInterop.emitRustExpr () v318
            v319 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v320 : char = null |&gt; unbox&lt;char&gt;
            v320 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v321 : char = null |&gt; unbox&lt;char&gt;
            v321 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v322 : char = null |&gt; unbox&lt;char&gt;
            v322 
            #endif
#if FABLE_COMPILER_PYTHON
            let v323 : char = null |&gt; unbox&lt;char&gt;
            v323 
            #endif
#else
            let v324 : char = System.IO.Path.DirectorySeparatorChar
            v324 
            #endif
            |&gt; fun x -&gt; _v317 &lt;- Some x
            let v325 : char = _v317.Value
            let v326 : (char -&gt; string) = _.ToString()
            let v327 : string = v326 v325
            let v328 : string = method24(v327)
            let v329 : (string -&gt; (string seq -&gt; string)) = String.concat
            let v330 : (string seq -&gt; string) = v329 v328
            v330 v316
        else
            let v332 : string = "std::fs::canonicalize(&amp;*$0)"
            let v333 : Result&lt;std_path_PathBuf, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr v186 v332
            let v334 : string = "$0.unwrap()"
            let v335 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v333 v334
            let v336 : string = "$0.display()"
            let v337 : std_path_Display = Fable.Core.RustInterop.emitRustExpr v335 v336
            let v338 : bool = true
            let mutable _v338 : std_string_String option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v339 : string = "format!(\"{}\", $0)"
            let v340 : std_string_String = Fable.Core.RustInterop.emitRustExpr v337 v339
            v340 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v341 : string = "format!(\"{}\", $0)"
            let v342 : std_string_String = Fable.Core.RustInterop.emitRustExpr v337 v341
            v342 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v343 : string = "format!(\"{}\", $0)"
            let v344 : std_string_String = Fable.Core.RustInterop.emitRustExpr v337 v343
            v344 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v345 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v345 
            #endif
#if FABLE_COMPILER_PYTHON
            let v346 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v346 
            #endif
#else
            let v347 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v347 
            #endif
            |&gt; fun x -&gt; _v338 &lt;- Some x
            let v348 : std_string_String = _v338.Value
            let v349 : string = "fable_library_rust::String_::fromString($0)"
            let v350 : string = Fable.Core.RustInterop.emitRustExpr v348 v349
            v350
    v351 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v352 : string = null |&gt; unbox&lt;string&gt;
    v352 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v353 : string = null |&gt; unbox&lt;string&gt;
    v353 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v354 : string = null |&gt; unbox&lt;string&gt;
    v354 
    #endif
#if FABLE_COMPILER_PYTHON
    let v355 : string = null |&gt; unbox&lt;string&gt;
    v355 
    #endif
#else
    let v356 : string = method25(v2)
    let v357 : (string -&gt; string) = System.IO.Path.GetFullPath
    let v358 : string = v357 v356
    v358 
    #endif
    |&gt; fun x -&gt; _v185 &lt;- Some x
    let v359 : string = _v185.Value
    let v360 : bool = true
    let mutable _v360 : string option = None 
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v361 : string = method17(v1)
    let v362 : string = "&amp;*$0"
    let v363 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v361 v362
    let v364 : string = "String::from($0)"
    let v365 : std_string_String = Fable.Core.RustInterop.emitRustExpr v363 v364
    let v366 : string = "std::path::PathBuf::from($0)"
    let v367 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v365 v366
    let v368 : string = "$0.exists()"
    let v369 : bool = Fable.Core.RustInterop.emitRustExpr v367 v368
    let v370 : bool = v369 = false
    let v526 : string =
        if v370 then
            let v371 : bool = true
            let mutable _v371 : string option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v372 : string = "std::env::current_dir()"
            let v373 : Result&lt;std_path_PathBuf, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr () v372
            let v374 : string = "$0.unwrap()"
            let v375 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v373 v374
            let v376 : string = "$0.display()"
            let v377 : std_path_Display = Fable.Core.RustInterop.emitRustExpr v375 v376
            let v378 : bool = true
            let mutable _v378 : std_string_String option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v379 : string = "format!(\"{}\", $0)"
            let v380 : std_string_String = Fable.Core.RustInterop.emitRustExpr v377 v379
            v380 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v381 : string = "format!(\"{}\", $0)"
            let v382 : std_string_String = Fable.Core.RustInterop.emitRustExpr v377 v381
            v382 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v383 : string = "format!(\"{}\", $0)"
            let v384 : std_string_String = Fable.Core.RustInterop.emitRustExpr v377 v383
            v384 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v385 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v385 
            #endif
#if FABLE_COMPILER_PYTHON
            let v386 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v386 
            #endif
#else
            let v387 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v387 
            #endif
            |&gt; fun x -&gt; _v378 &lt;- Some x
            let v388 : std_string_String = _v378.Value
            let v389 : string = "fable_library_rust::String_::fromString($0)"
            let v390 : string = Fable.Core.RustInterop.emitRustExpr v388 v389
            v390 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v391 : string = null |&gt; unbox&lt;string&gt;
            v391 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v392 : string = null |&gt; unbox&lt;string&gt;
            v392 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v393 : string = null |&gt; unbox&lt;string&gt;
            v393 
            #endif
#if FABLE_COMPILER_PYTHON
            let v394 : string = null |&gt; unbox&lt;string&gt;
            v394 
            #endif
#else
            let v395 : (unit -&gt; string) = System.IO.Directory.GetCurrentDirectory
            let v396 : string = v395 ()
            v396 
            #endif
            |&gt; fun x -&gt; _v371 &lt;- Some x
            let v397 : string = _v371.Value
            let v398 : string = method11(v397, v361)
            let v399 : bool = true
            let mutable _v399 : string option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v400 : string = method18(v398)
            let v401 : string = method19()
            let v402 : bool = true
            let mutable _v402 : Result&lt;regex_Regex, regex_Error&gt; option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v403 : string = method20()
            let v404 : string = $"regex::Regex::new(&amp;$0)"
            let v405 : Result&lt;regex_Regex, regex_Error&gt; = Fable.Core.RustInterop.emitRustExpr v403 v404
            v405 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v406 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v406 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v407 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v407 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v408 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v408 
            #endif
#if FABLE_COMPILER_PYTHON
            let v409 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v409 
            #endif
#else
            let v410 : Result&lt;regex_Regex, regex_Error&gt; = null |&gt; unbox&lt;Result&lt;regex_Regex, regex_Error&gt;&gt;
            v410 
            #endif
            |&gt; fun x -&gt; _v402 &lt;- Some x
            let v411 : Result&lt;regex_Regex, regex_Error&gt; = _v402.Value
            let v412 : string = "$0.unwrap()"
            let v413 : regex_Regex = Fable.Core.RustInterop.emitRustExpr v411 v412
            let v414 : string = $"$0.replace_all(&amp;$1, &amp;*$2)"
            let v415 : std_borrow_Cow&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr struct (v413, v400, v401) v414
            let v416 : string = "String::from($0)"
            let v417 : std_string_String = Fable.Core.RustInterop.emitRustExpr v415 v416
            let v418 : string = "fable_library_rust::String_::fromString($0)"
            let v419 : string = Fable.Core.RustInterop.emitRustExpr v417 v418
            v419 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v420 : string = null |&gt; unbox&lt;string&gt;
            v420 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v421 : string = null |&gt; unbox&lt;string&gt;
            v421 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v422 : string = null |&gt; unbox&lt;string&gt;
            v422 
            #endif
#if FABLE_COMPILER_PYTHON
            let v423 : string = null |&gt; unbox&lt;string&gt;
            v423 
            #endif
#else
            let v424 : string = method21()
            let v425 : string = "^\\\\\\\\\\?\\\\"
            let v426 : string = System.Text.RegularExpressions.Regex.Replace (v398, v425, v424)
            v426 
            #endif
            |&gt; fun x -&gt; _v399 &lt;- Some x
            let v427 : string = _v399.Value
            let v428 : string = $"{v427.[0] |&gt; string |&gt; _.ToLower()}{v427.[1..]}"
            let v429 : string = "\\"
            let v430 : string = "/"
            let v431 : string = v428.Replace (v429, v430)
            let v432 : (string []) = v431.Split v430
            let v433 : (string []) = [||]
            let v434 : int32 = v432.Length
            let v435 : Mut4 = {l0 = 0; l1 = 0; l2 = v433} : Mut4
            while method22(v434, v435) do
                let v437 : int32 = v435.l0
                let v438 : int32 =  -v437
                let v439 : int32 = v438 + v434
                let v440 : int32 = v439 - 1
                let struct (v441 : int32, v442 : (string [])) = v435.l1, v435.l2
                let v443 : string = v432.[int v440]
                let v444 : bool = ".." = v443
                let struct (v486 : int32, v487 : (string [])) =
                    if v444 then
                        let v445 : int32 = v441 + 1
                        struct (v445, v442)
                    else
                        let v446 : bool = "." = v443
                        if v446 then
                            struct (v441, v442)
                        else
                            let v447 : bool = 0 = v441
                            if v447 then
                                let v448 : string = ":"
                                let v449 : bool = v443.EndsWith v448
                                if v449 then
                                    let v450 : string = $"{v397.[0]}:"
                                    let v451 : (string []) = [|v450|]
                                    let v452 : int32 = v451.Length
                                    let v453 : int32 = v442.Length
                                    let v454 : int32 = v452 + v453
                                    let v455 : (string []) = Array.zeroCreate&lt;string&gt; (v454)
                                    let v456 : Mut5 = {l0 = 0} : Mut5
                                    while method23(v454, v456) do
                                        let v458 : int32 = v456.l0
                                        let v459 : bool = v458 &lt; v452
                                        let v463 : string =
                                            if v459 then
                                                let v460 : string = v451.[int v458]
                                                v460
                                            else
                                                let v461 : int32 = v458 - v452
                                                let v462 : string = v442.[int v461]
                                                v462
                                        v455.[int v458] &lt;- v463
                                        let v464 : int32 = v458 + 1
                                        v456.l0 &lt;- v464
                                        ()
                                    struct (0, v455)
                                else
                                    let v465 : (string []) = [|v443|]
                                    let v466 : int32 = v465.Length
                                    let v467 : int32 = v442.Length
                                    let v468 : int32 = v466 + v467
                                    let v469 : (string []) = Array.zeroCreate&lt;string&gt; (v468)
                                    let v470 : Mut5 = {l0 = 0} : Mut5
                                    while method23(v468, v470) do
                                        let v472 : int32 = v470.l0
                                        let v473 : bool = v472 &lt; v466
                                        let v477 : string =
                                            if v473 then
                                                let v474 : string = v465.[int v472]
                                                v474
                                            else
                                                let v475 : int32 = v472 - v466
                                                let v476 : string = v442.[int v475]
                                                v476
                                        v469.[int v472] &lt;- v477
                                        let v478 : int32 = v472 + 1
                                        v470.l0 &lt;- v478
                                        ()
                                    struct (0, v469)
                            else
                                let v481 : int32 = v441 - 1
                                struct (v481, v442)
                let v488 : int32 = v437 + 1
                v435.l0 &lt;- v488
                v435.l1 &lt;- v486
                v435.l2 &lt;- v487
                ()
            let struct (v489 : int32, v490 : (string [])) = v435.l1, v435.l2
            let v491 : string seq = seq { for i = 0 to v490.Length - 1 do yield v490.[i] }
            let v492 : bool = true
            let mutable _v492 : char option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v493 : string = "std::path::MAIN_SEPARATOR"
            let v494 : char = Fable.Core.RustInterop.emitRustExpr () v493
            v494 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v495 : char = null |&gt; unbox&lt;char&gt;
            v495 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v496 : char = null |&gt; unbox&lt;char&gt;
            v496 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v497 : char = null |&gt; unbox&lt;char&gt;
            v497 
            #endif
#if FABLE_COMPILER_PYTHON
            let v498 : char = null |&gt; unbox&lt;char&gt;
            v498 
            #endif
#else
            let v499 : char = System.IO.Path.DirectorySeparatorChar
            v499 
            #endif
            |&gt; fun x -&gt; _v492 &lt;- Some x
            let v500 : char = _v492.Value
            let v501 : (char -&gt; string) = _.ToString()
            let v502 : string = v501 v500
            let v503 : string = method24(v502)
            let v504 : (string -&gt; (string seq -&gt; string)) = String.concat
            let v505 : (string seq -&gt; string) = v504 v503
            v505 v491
        else
            let v507 : string = "std::fs::canonicalize(&amp;*$0)"
            let v508 : Result&lt;std_path_PathBuf, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr v361 v507
            let v509 : string = "$0.unwrap()"
            let v510 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v508 v509
            let v511 : string = "$0.display()"
            let v512 : std_path_Display = Fable.Core.RustInterop.emitRustExpr v510 v511
            let v513 : bool = true
            let mutable _v513 : std_string_String option = None 
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v514 : string = "format!(\"{}\", $0)"
            let v515 : std_string_String = Fable.Core.RustInterop.emitRustExpr v512 v514
            v515 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v516 : string = "format!(\"{}\", $0)"
            let v517 : std_string_String = Fable.Core.RustInterop.emitRustExpr v512 v516
            v517 
            #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v518 : string = "format!(\"{}\", $0)"
            let v519 : std_string_String = Fable.Core.RustInterop.emitRustExpr v512 v518
            v519 
            #endif
#if FABLE_COMPILER_TYPESCRIPT
            let v520 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v520 
            #endif
#if FABLE_COMPILER_PYTHON
            let v521 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v521 
            #endif
#else
            let v522 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v522 
            #endif
            |&gt; fun x -&gt; _v513 &lt;- Some x
            let v523 : std_string_String = _v513.Value
            let v524 : string = "fable_library_rust::String_::fromString($0)"
            let v525 : string = Fable.Core.RustInterop.emitRustExpr v523 v524
            v525
    v526 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v527 : string = null |&gt; unbox&lt;string&gt;
    v527 
    #endif
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v528 : string = null |&gt; unbox&lt;string&gt;
    v528 
    #endif
#if FABLE_COMPILER_TYPESCRIPT
    let v529 : string = null |&gt; unbox&lt;string&gt;
    v529 
    #endif
#if FABLE_COMPILER_PYTHON
    let v530 : string = null |&gt; unbox&lt;string&gt;
    v530 
    #endif
#else
    let v531 : string = method25(v1)
    let v532 : (string -&gt; string) = System.IO.Path.GetFullPath
    let v533 : string = v532 v531
    v533 
    #endif
    |&gt; fun x -&gt; _v360 &lt;- Some x
    let v534 : string = _v360.Value
    let v535 : US0 = US0_1
    let v536 : (unit -&gt; string) = closure9()
    let v537 : (unit -&gt; string) = closure10(v0, v184, v359, v534)
    method3(v535, v536, v537)
    let v538 : string = "let __result = Box::pin(async move { //"
    Fable.Core.RustInterop.emitRustExpr () v538
    let v539 : string = "async_walkdir::WalkDir::new(&amp;*$0)"
    let v540 : async_walkdir_WalkDir = Fable.Core.RustInterop.emitRustExpr v359 v539
    let v541 : string = "async_walkdir::WalkDir::filter($0, |x| $1(x))"
    let v542 : (async_walkdir_DirEntry -&gt; std_pin_Pin&lt;Box&lt;Send&lt;Dyn&lt;std_future_Future&lt;async_walkdir_Filtering&gt;&gt;&gt;&gt;&gt;) = closure11()
    let v543 : async_walkdir_WalkDir = Fable.Core.RustInterop.emitRustExpr struct (v540, v542) v541
    let v544 : (Result&lt;async_walkdir_DirEntry, std_io_Error&gt; -&gt; string option) = method33()
    let v545 : string = "futures_lite::stream::StreamExt::collect(futures_lite::stream::StreamExt::filter_map(v543, |x| v544(x))).await"
    let v546 : Vec&lt;string&gt; = Fable.Core.RustInterop.emitRustExpr () v545
    let v547 : US0 = US0_1
    let v548 : (unit -&gt; string) = closure20()
    let v549 : (unit -&gt; string) = closure21(v546)
    method3(v547, v548, v549)
    let v550 : string = "rayon::iter::IntoParallelIterator::into_par_iter(v546)"
    let v551 : rayon_vec_IntoIter&lt;string&gt; = Fable.Core.RustInterop.emitRustExpr () v550
    let v552 : string = "rayon::iter::ParallelIterator::map($0, |x| $1(x))"
    let v553 : (string -&gt; Result&lt;(string * Vec&lt;Result&lt;string, (string * string)&gt; option&gt;), std_string_String&gt;) = closure22(v0, v9, v184, v359, v534)
    let v554 : rayon_iter_Map&lt;rayon_vec_IntoIter&lt;string&gt;&gt; = Fable.Core.RustInterop.emitRustExpr struct (v551, v553) v552
    let v555 : string = "rayon::iter::ParallelIterator::collect($0)"
    let v556 : Vec&lt;Result&lt;(string * Vec&lt;Result&lt;string, (string * string)&gt; option&gt;), std_string_String&gt;&gt; = Fable.Core.RustInterop.emitRustExpr v554 v555
    let v557 : US0 = US0_2
    let v558 : (unit -&gt; string) = closure67()
    let v559 : (unit -&gt; string) = closure68(v556)
    method3(v557, v558, v559)
    let v560 : Result&lt;Vec&lt;Result&lt;(string * Vec&lt;Result&lt;string, (string * string)&gt; option&gt;), std_string_String&gt;&gt;, std_string_String&gt; = Ok v556
    let v561 : Result&lt;Vec&lt;Result&lt;(string * Vec&lt;Result&lt;string, (string * string)&gt; option&gt;), std_string_String&gt;&gt;, std_string_String&gt; = method66(v560)
    let v562 : string = "v561 }}}})"
    Fable.Core.RustInterop.emitRustExpr () v562
    let v563 : string = "{{{ //"
    Fable.Core.RustInterop.emitRustExpr () v563
    let v564 : string = "__result"
    let v565 : std_pin_Pin&lt;Box&lt;Dyn&lt;std_future_Future&lt;Result&lt;Vec&lt;Result&lt;(string * Vec&lt;Result&lt;string, (string * string)&gt; option&gt;), std_string_String&gt;&gt;, std_string_String&gt;&gt;&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v564
    v565
and closure1 () (v0 : (string [])) : int32 =
    let v1 : (US0 -&gt; struct (Mut0 * Mut1 * Mut2 * int64 option * Mut3)) = closure2()
    let v2 : US0 = US0_2
    if State.trace_state.IsNone then State.trace_state &lt;- v1 v2 |&gt; Some
    let v3 : US0 = US0_2
    let v4 : (unit -&gt; string) = closure4()
    let v5 : (unit -&gt; string) = closure5(v0)
    method3(v3, v4, v5)
    let v6 : clap_Command = method0()
    let v7 : string = "clap::Command::get_matches($0)"
    let v8 : clap_ArgMatches = Fable.Core.RustInterop.emitRustExpr v6 v7
    let v9 : string = method6()
    let v10 : string = "&amp;*$0"
    let v11 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v9 v10
    let v12 : string = "clap::ArgMatches::get_one(&amp;$0, v11).cloned()"
    let v13 : std_string_String option = Fable.Core.RustInterop.emitRustExpr v8 v12
    let v14 : US2 option = None
    let _v14 = ref v14 
    match v13 with
    | Some x -&gt; (
    (fun () -&gt;
    (fun () -&gt;
    let v15 : std_string_String = x
    let v16 : US2 = US2_0(v15)
    v16 
    )
    |&gt; fun x -&gt; x () |&gt; Some
    ) () ) | None -&gt; None
    |&gt; fun x -&gt; _v14.Value &lt;- x
    let v17 : US2 option = _v14.Value 
    let v18 : US2 = US2_1
    let v19 : US2 = v17 |&gt; Option.defaultValue v18 
    let v23 : std_string_String =
        match v19 with
        | US2_1 -&gt; (* None *)
            failwith&lt;std_string_String&gt; "Option does not have a value."
        | US2_0(v20) -&gt; (* Some *)
            v20
    let v24 : string = "fable_library_rust::String_::fromString($0)"
    let v25 : string = Fable.Core.RustInterop.emitRustExpr v23 v24
    let v26 : string = method7()
    let v27 : string = "&amp;*$0"
    let v28 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v26 v27
    let v29 : string = "clap::ArgMatches::get_one(&amp;$0, v28).cloned()"
    let v30 : std_string_String option = Fable.Core.RustInterop.emitRustExpr v8 v29
    let v31 : US2 option = None
    let _v31 = ref v31 
    match v30 with
    | Some x -&gt; (
    (fun () -&gt;
    (fun () -&gt;
    let v32 : std_string_String = x
    let v33 : US2 = US2_0(v32)
    v33 
    )
    |&gt; fun x -&gt; x () |&gt; Some
    ) () ) | None -&gt; None
    |&gt; fun x -&gt; _v31.Value &lt;- x
    let v34 : US2 option = _v31.Value 
    let v35 : US2 = US2_1
    let v36 : US2 = v34 |&gt; Option.defaultValue v35 
    let v40 : std_string_String =
        match v36 with
        | US2_1 -&gt; (* None *)
            failwith&lt;std_string_String&gt; "Option does not have a value."
        | US2_0(v37) -&gt; (* Some *)
            v37
    let v41 : string = "fable_library_rust::String_::fromString($0)"
    let v42 : string = Fable.Core.RustInterop.emitRustExpr v40 v41
    let v43 : string = method8()
    let v44 : string = "&amp;*$0"
    let v45 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v43 v44
    let v46 : string = "clap::ArgMatches::get_one(&amp;$0, v45).cloned()"
    let v47 : std_string_String option = Fable.Core.RustInterop.emitRustExpr v8 v46
    let v48 : US2 option = None
    let _v48 = ref v48 
    match v47 with
    | Some x -&gt; (
    (fun () -&gt;
    (fun () -&gt;
    let v49 : std_string_String = x
    let v50 : US2 = US2_0(v49)
    v50 
    )
    |&gt; fun x -&gt; x () |&gt; Some
    ) () ) | None -&gt; None
    |&gt; fun x -&gt; _v48.Value &lt;- x
    let v51 : US2 option = _v48.Value 
    let v52 : US2 = US2_1
    let v53 : US2 = v51 |&gt; Option.defaultValue v52 
    let v57 : std_string_String =
        match v53 with
        | US2_1 -&gt; (* None *)
            failwith&lt;std_string_String&gt; "Option does not have a value."
        | US2_0(v54) -&gt; (* Some *)
            v54
    let v58 : string = "fable_library_rust::String_::fromString($0)"
    let v59 : string = Fable.Core.RustInterop.emitRustExpr v57 v58
    let v60 : string = method9()
    let v61 : string = "&amp;*$0"
    let v62 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v60 v61
    let v63 : string = "clap::ArgMatches::get_one(&amp;$0, v62).cloned()"
    let v64 : std_string_String option = Fable.Core.RustInterop.emitRustExpr v8 v63
    let v65 : US2 option = None
    let _v65 = ref v65 
    match v64 with
    | Some x -&gt; (
    (fun () -&gt;
    (fun () -&gt;
    let v66 : std_string_String = x
    let v67 : US2 = US2_0(v66)
    v67 
    )
    |&gt; fun x -&gt; x () |&gt; Some
    ) () ) | None -&gt; None
    |&gt; fun x -&gt; _v65.Value &lt;- x
    let v68 : US2 option = _v65.Value 
    let v69 : US2 = US2_1
    let v70 : US2 = v68 |&gt; Option.defaultValue v69 
    let v74 : std_string_String =
        match v70 with
        | US2_1 -&gt; (* None *)
            failwith&lt;std_string_String&gt; "Option does not have a value."
        | US2_0(v71) -&gt; (* Some *)
            v71
    let v75 : string = "fable_library_rust::String_::fromString($0)"
    let v76 : string = Fable.Core.RustInterop.emitRustExpr v74 v75
    let v77 : std_pin_Pin&lt;Box&lt;Dyn&lt;std_future_Future&lt;Result&lt;Vec&lt;Result&lt;(string * Vec&lt;Result&lt;string, (string * string)&gt; option&gt;), std_string_String&gt;&gt;, std_string_String&gt;&gt;&gt;&gt;&gt; = method10(v76, v59, v42, v25)
    let v78 : string = "futures_lite::future::block_on($0)"
    let v79 : Result&lt;Vec&lt;Result&lt;(string * Vec&lt;Result&lt;string, (string * string)&gt; option&gt;), std_string_String&gt;&gt;, std_string_String&gt; = Fable.Core.RustInterop.emitRustExpr v77 v78
    let v80 : string = "$0.unwrap()"
    let v81 : Vec&lt;Result&lt;(string * Vec&lt;Result&lt;string, (string * string)&gt; option&gt;), std_string_String&gt;&gt; = Fable.Core.RustInterop.emitRustExpr v79 v80
    0
let v0 : (unit -&gt; unit) = closure0()
let tests () = v0 ()
let v1 : ((string []) -&gt; int32) = closure1()
let main args = v1 args
()


</pre>
</div>
</div>
</div>
</div>
</div>
</main>
</body>
</html>

