<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="generator" content="crowbook">
    <meta name="viewport" content="width=device-width">
    <meta name="author" content="">
    
    <title></title>
    <style type = "text/css">
      body {
    font-family: "Linux Libertine", "Georgia", serif;
    text-align: justify;
    font-size: 100%;
}

p {
    text-indent: 1.25em;
    margin:0;
    hyphens: auto;
}

blockquote {
    margin: 1em;
    font-style: italic;
}
code {
    font-size: 80%;
    font-family: "Linux Libertine Mono", monospace;
    background-color: #F0F0F0;
}
pre {
    font-family: "Linux Libertine Mono", monospace;
    text-align: left;
    margin: 1em;
    padding-top: 0;
    background-color: #F0F0F0;
    white-space: pre-wrap;
    word-wrap: break-word;
}
/* Try to disable hyphenation in titles */
h1, h2, h3, h4, h5, h5 {
    adobe-hyphenate: none;
    -ms-hyphens: none; /* Trident (Windows) */
    -moz-hyphens: none; /* Gecko (Firefox) */
    -webkit-hyphens: none; /* Webkit */
    -epub-hyphens: none; /* EPUB 3 */
    hyphens: none; /* Futur standard */
}

h1, h2, h3, h4, h5, h6 {
    text-align: left;
    font-family: Linux Biolinum, sans-serif;
    font-variant: small-caps;
}

/* Title of a part */
h1.part {
    font-size: 250%;
    text-align: center;
}

/* The `Part X` section of a part */
h2.part {
    font-size: 175%;
    text-align: center;
}

/* The "Chapter X" section of a chapter */
span.chapter-header {
    font-size: 75%;
}

/* Title of the book */
h1.title {
    text-align: center;
    font-size: 300%;
}
/* Author */
h2.author {
    text-align: right;
    font-size:  200%;
}

/* Subtitle */
h2.subtitle {
    text-align: center;
    font-size: 200%;
}

/* When toc is displayed inlined */
#toc ol, #toc ul {
    padding: 0;
    margin-left: 1em;
}
#toc li {
    list-style-type: none;
    margin: 0; padding: 0;
}

#toc li:before {
    content: none;
}

#cover img {
    width: 100%;
    max-height: 100%;
}

.image {
    margin: auto;
    width: 80%;
}

.image img {
    width: 100%;
    max-height: 100%;
}

.rule {
    text-align: center !important;
    margin-top: 1em;
    margin-bottom: 1em;
    font-weight: bold;
    page-break-inside: avoid;
    break-inside: avoid;
    page-break-after: avoid;
    break-after: avoid;
}

/* The number of the note in an expanded footnote (e.g. [3]) */
.note-number {
    font-weight: bold;
    margin-right: 1em;
}

td.note-number {
    vertical-align: top;
}

/* When footnotes (try to) be displayed as margin notes */
.sidenote {
    display: block;
    float: right;
    width: 30%;
    border: 1px solid black;
    margin: 1em;
    padding: .5em;
    margin-right: -1.5em;
}

.sidenote .note-number {
    float: left;
}

/* The div class displaying notes at the end of a chapter */
div.notes {
    text-align: justify;
    border-top: thin dashed black;
    margin-top: 1em;
}

table.notes {
    border-collapse: collapse;
    border-style: hidden;
}

table.notes tr td {
    margin-left: 1em;
    margin-right: 1em;
}

table.notes tr td p {
    text-indent: 0;
}
                 
/* Every markdown table is included in a <div class = "table"> */
.table {
    margin: 1em;
}

.table table {
    width: 80%;
    margin: 0 auto;
    border-style: solid;
    border-width: thin;
    border-color: black;
    border-collapse: collapse;
}

.table table th, .table table td {
    border-style: solid;
    border-width: 1px;
    text-align: center;
}

.table table th {
    font-weight: bold;
    font-variant: small-caps;
}



span.initial { 
    float: left;
    font-size: 285%;
    font-weight: bold;
    margin-right: 0.05em;
    line-height: 0.8em;
}

p.first-para {
    text-indent: 0;
}

/* Use this for escape narrow space so it is non-breaking */
.nnbsp {
    /* white-space: nowrap;*/
    word-spacing: -0.13em;
    /* Following necessary for Kobo EPUB3 reader??? */
    margin: 0;
    padding: 0;
}

 body { color: #e8e6e3; background-color: #202324; } a { color: #989693; } pre { background-color: #1b1b1b; padding: 10px; } 
/* Default  HTML CSS file includes default EPUB CSS file */

/* Colors for the navigation menu (toc) */
nav {
    background: #dfcae6;
    color: black;
    border-right-color: black;
}

#nav a:link {
    color: black;
}

#nav a:visited {
    color: black;
}

/* Colors for top and footer */
#top {
    background-color: #444343;
    color: white;
}

footer {
    background-color: #444343;
    color: white;
}

footer a, #top a {
    color: #fc71ff;
}

footer a:hover, #top a:hover {
    color: #b743fe;
}

/* Additional elements, only use for proofreading */
/* Grammar error */
.grammar-error {
    color: red;
    text-decoration-line: underline;
    text-decoration-style: double;
/*    background: #d966ff;*/
}

.popup_footnote {
    background-color: #e8e897;
}


p.first-para:first-letter {
    font-size: 300%;
    float: left;
    font-weight: bold;
    margin-right: 0.05em;
    line-height: 1em;
}

/* The nav element corresponding to the navigation menu */
nav {
    z-index: 2;
    position: fixed;
    left: 0;
    top: 0;
    bottom: 0;
    width: 20%;
    overflow-y: auto;
    font-size: 80%;
    margin-left: 0;
    border-right-width: 2px;
    border-right-style: dashed;
}

#nav code {
    background-color: transparent;
}

#nav a:link {
    text-decoration: none;
}

#nav a:visited {
    text-decoration: none;
}

#nav {
    text-align: left;
}

#nav h2 {
    text-align: center;
}

#nav li {
    list-style-type: none;
    text-indent: -1em;
}

#nav li:before {
    content: none;
}

#nav ul {
    padding-right: 1em;
    padding-left: 1.5em;
}

/* The menu containing the button to display the navigation bar */
#menu {
    position: fixed;
    z-index: 2;
    top: 0em;
    left: 1em;
    transition: left 1s;
}

#menu img {
    opacity: 0.5;
}

#menu img:hover {
    opacity: 1.0;
    cursor: pointer;
}

#menu-button {
    height: 1.5em;
    padding: 0.5em;
}

#book-button {
    height: 1.5em;
    padding: 0.5em;
    float: left;
}

/* Hide navigation bar */
#nav {
    left: -21%;
    transition: left 1s;
}

/* The main content of the book */
#content {
    overflow-y: auto;
    margin-left: 0;
    margin-right: 0;
    margin-top: 0;
    margin-bottom: 0;
    transition: margin-left 1s;
}

/* Used for multifiles HTML */
.prev_chapter {
    text-align: left;
    text-indent: 0;
    margin-bottom: 1em;
    font-size: 120%;
    font-variant: small-caps;
    font-weight: bold;
}

.next_chapter {
    text-align: right;
    margin-top: 1em;
    margin-bottom: 1em;
    font-size: 120%;
    font-variant: small-caps;
    font-weight: bold;
}

/* Improving readability for the HTML format only */
p, blockquote, li, .image  {
    margin-right: auto;
    max-width: 33em;
}

blockquote {
    padding: 1em;
}

#content {
    text-align: center;
}

#page {
    display: inline-block;
    text-align: justify;
    max-width: 33em;
}

#nav-container {
    top: 0;
    width: 100%;
}

#nav-title {
    top: 0;
}

#toolbar {
    top: 0;
    float: left;
}

#toolbar img {
    cursor: pointer;
}

footer {
    margin-top: 2em;
    margin-bottom: 0;
}

#top {
    margin-top: 0;
    margin-bottom: 1em;
}

#top p {
    font-family: "Linux Biolinum";
    font-weight: bold;
    font-variant: small-caps;
}

footer, #top {
    padding-top: .25em;
    padding-bottom: .25em;
    margin-left: 0;
    margin-right: 0;
    text-align: center;
    transition: margin-left 1s;
}

footer a, #top a {
    text-decoration: none;
}

footer p, #top p {
    text-indent: 0;
    margin-left: auto;
    margin-right: auto;
    margin-bottom: 0.5em;
    margin-top: 0.5em;
    max-width: 33em;
}

.popup_footnote {
    margin: 2em;
    padding : 1em;
    right: 2em;
    max-width: 20em;
}


 body { color: #e8e6e3; background-color: #202324; } a { color: #989693; } pre { background-color: #1b1b1b; padding: 10px; } 

    </style>
    <style type = "text/css" media = "print">
      #page {
    display: block;
}

.chapter {
    page-break-before: always;
}

#menu {
    display: none;
}

#nav {
    display: none;
}
    </style>
    
   <script>
    function on(name) {
    var elements = document.getElementsByClassName(name);
    for (var i = 0; i < elements.length; i++) {
        var elem = elements[i];
        elem.style.backgroundColor = "pink";
    }
}
function off(name) {
    var elements = document.getElementsByClassName(name);
    for (var i = 0; i < elements.length; i++) {
        var elem = elements[i];
        elem.style.backgroundColor = "white";
    }
}

var display_menu = false;
function toggle() {
    if (display_menu == true) {
        display_menu = false;
        document.getElementById("nav").style.left = "-21%";
        document.getElementById("content").style.marginLeft = "0%";
        document.getElementById("menu").style.left = "1em";
/*        if(document.getElementById("top")) {
            document.getElementById("top").style.left = "0";
        }
        if(document.getElementById("footer")) {
            document.getElementById("footer").style.marginLeft = "0%";
        }*/
    } else {
        display_menu = true;
        document.getElementById("nav").style.left = "0";
        document.getElementById("content").style.marginLeft = "20%";
        document.getElementById("menu").style.left = "20%";
/*        if(document.getElementById("top")) {
            document.getElementById("top").style.left = "20%";
        }
        if(document.getElementById("footer")) {
            document.getElementById("footer").style.marginLeft = "20%";
        }*/
    }
}

function remove_footnotes() {
    var footnotes = document.querySelectorAll('.popup_footnote');
    for (var i = 0; i < footnotes.length; i++) {
        var f = footnotes[i];
        if (f.parentNode) {
            f.parentNode.removeChild(f);
        }
    }
}

function show_footnote(event) {
    remove_footnotes();
    var id = event.target.getAttribute("id");
    var target_id = id.replace("source", "dest");
    var content = document.getElementById(target_id).innerHTML;
    var top = Math.round(event.target.getBoundingClientRect().top + event.target.getBoundingClientRect().height);
    event.target.insertAdjacentHTML('afterend', '<aside class = "popup_footnote" style = "position: fixed; top: '+ top + 'px; ">' + content + '</aside>')
}


document.addEventListener('DOMContentLoaded', function() {
    var anchors = document.querySelectorAll('.footnote_reference');

    for (var i = 0; i < anchors.length; i++) {
        var anchor = anchors[i];
        anchor.addEventListener(
            "mouseenter",
            (event) => {
                show_footnote(event);
            }
        );
        anchor.addEventListener(
            "mouseleave",
            (event) => {
                remove_footnotes();
            }
        );
    }
});




   </script>


  </head>
  <body>
    
<script type = 'application/ld+json'>
{
    "@context": "http://schema.org/",
    "@type": "Book",
    "author": "",
    "name": "",
    
    
    
    
    
    "inLanguage": "en"
}
</script>
    

    <div id = "content">
      
      <div id = "page">
        <header>

          <div id = "menu">
	        
          </div>
	  <h2 class="author"></h2>
          <h1 id = "link-0" class="title" ></h1>
	  
	  
        </header>

        <div id = "chapter-0" class = "chapter">
  <pre><span style="color:#323232;">```sh</span>
<span style="color:#323232;">응/.카르구/빙</span>
<span style="color:#323232;">~/.cargo/bin</span>

</pre><pre>
<span style="color:#323232;">---</span>
<span style="color:#323232;">---</span>

<span style="color:#323232;">## 리스트 오테르 헬레반트 마크루스 타트 캉 비 헤아드 잉 부이우드 치미</span>
<span style="color:#323232;">## list other relevant macros that can be read in build time</span>

<span style="color:#323232;">&lt; 잉 아지치옹 투 티 인브!(&quot;카르구_프크그_베르시옹&quot;) 마크루, 테리 아리 세베라우 오테르 부이우트-잉 마크루스 타트 캉 비 우제드 투 아세스 인포르마치옹 아보트 티 쿠헨트 부이우드 인비론멘트 잉 후스트. 에리 아리 아 페 오프 티 모스트 코몬리 우제드 오니스:</span>
<span style="color:#323232;">&lt; In addition to the env!(&quot;CARGO_PKG_VERSION&quot;) macro, there are several other built-in macros that can be used to access information about the current build environment in Rust. Here are a few of the most commonly used ones:</span>

<span style="color:#323232;">인브!(&quot;카르구_마니페스트_지르&quot;): 티스 마크루 헤투릉스 티 파트 투 티 지렉토리 콘타이닝그 티 카르구.토무 필리 포르 티 쿠헨트 파카지.</span>
<span style="color:#323232;">env!(&quot;CARGO_MANIFEST_DIR&quot;): This macro returns the path to the directory containing the Cargo.toml file for the current package.</span>
<span style="color:#323232;">필리!(): 티스 마크루 헤투릉스 티 파트 투 티 쿠헨트 소르시 필리 아트 콤필리-치미.</span>
<span style="color:#323232;">file!(): This macro returns the path to the current source file at compile-time.</span>
<span style="color:#323232;">리니!(): 티스 마크루 헤투릉스 티 리니 눔베르 오프 티 쿠헨트 소르시 코지 로카치옹 아트 콤필리-치미.</span>
<span style="color:#323232;">line!(): This macro returns the line number of the current source code location at compile-time.</span>
<span style="color:#323232;">콜룸응!(): 티스 마크루 헤투릉스 티 콜룸응 눔베르 오프 티 쿠헨트 소르시 코지 로카치옹 아트 콤필리-치미.</span>
<span style="color:#323232;">column!(): This macro returns the column number of the current source code location at compile-time.</span>
<span style="color:#323232;">모둘리_파트!(): 티스 마크루 헤투릉스 티 나미 오프 티 쿠헨트 모둘리 아트 콤필리-치미.</span>
<span style="color:#323232;">module_path!(): This macro returns the name of the current module at compile-time.</span>
<span style="color:#323232;">콩카트!(): 티스 마크루 콩카테나치스 무우치플리 스트링그 리테라우스 아트 콤필리-치미.</span>
<span style="color:#323232;">concat!(): This macro concatenates multiple string literals at compile-time.</span>
<span style="color:#323232;">스트린지피!(): 티스 마크루 콘베르트스 아니 후스트 이스프레시옹 인투 아 스트링그 리테라우 아트 콤필리-치미.</span>
<span style="color:#323232;">stringify!(): This macro converts any Rust expression into a string literal at compile-time.</span>
<span style="color:#323232;">크프그!(...): 티스 마크루 테스트스 에테르 아 지벵 콘피구라치옹 오프치옹 이스 세트 아트 콤필리-치미. 포르 이잠플리, 크프그!(타르제트_우스 = &quot;리누스&quot;) 테스트스 에테르 티 쿠헨트 타르제트 오페라칭그 시스텡 이스 리누스.</span>
<span style="color:#323232;">cfg!(...): This macro tests whether a given configuration option is set at compile-time. For example, cfg!(target_os = &quot;linux&quot;) tests whether the current target operating system is Linux.</span>

<span style="color:#323232;">테지 부이우트-잉 마크루스 캉 비 우제풀 포르 제네라칭그 콘지치오나우 코지, 부이우징그 필리 파트스, 오르 아세싱그 오테르 인포르마치옹 아보트 티 쿠헨트 부이우드 인비론멘트 아트 콤필리-치미.</span>
<span style="color:#323232;">These built-in macros can be useful for generating conditional code, building file paths, or accessing other information about the current build environment at compile-time.</span>

<span style="color:#323232;">## 리스트 소미 오테르 이드기 마크루스 타트 아우수 캉 에우프</span>
<span style="color:#323232;">## list some other edgy macros that also can help</span>

<span style="color:#323232;">&lt; 수리, 에리 아리 아 페 오테르 후스트 마크루스 타트 캉 비 에우프풀 잉 바리오스 시투아치옹스:</span>
<span style="color:#323232;">&lt; Sure, here are a few other Rust macros that can be helpful in various situations:</span>

<span style="color:#323232;">드브그!(...): 티스 마크루 이스 아 콘베니엔트 와이 투 프린트 데부그 인포르마치옹 두링그 데벨로프멘트. 이트 타키스 앙 이스프레시옹 아스 앙 아르구멘트, 이발루아치스 이트, 안드 프린트스 티 헤주우칭그 발루이 투 티 콘솔리. 포르 이잠플리, 드브그!(스) 워우드 프린트 티 발루이 오프 스 투 티 콘솔리.</span>
<span style="color:#323232;">dbg!(...): This macro is a convenient way to print debug information during development. It takes an expression as an argument, evaluates it, and prints the resulting value to the console. For example, dbg!(x) would print the value of x to the console.</span>

<span style="color:#323232;">트리!(): 티스 마크루 이스 아 소르탄드 포르 리칭그 이호르-안들링그 코지 위트 헤주우트. 이트 타키스 아 헤주우트 이스프레시옹 아스 앙 아르구멘트, 안드 이프 티 헤주우트 이스 앙 이흐, 이트 헤투릉스 이아를리 위트 티 이호르. 포르 이잠플리, 트리!(소미_헤주우트) 워우드 헤투릉 티 이호르 이프 소미_헤주우트 이스 앙 이흐.</span>
<span style="color:#323232;">try!(): This macro is a shorthand for writing error-handling code with Result. It takes a Result expression as an argument, and if the result is an Err, it returns early with the error. For example, try!(some_result) would return the error if some_result is an Err.</span>

<span style="color:#323232;">아세르트!(...): 티스 마크루 이스 우제드 투 리치 테스트스 안드 인수리 타트 세르타잉 콘지치옹스 아리 메트. 이트 타키스 아 볼레앙 이스프레시옹 아스 앙 아르구멘트, 안드 이프 티 이스프레시옹 이스 파우시, 이트 파닉스 위트 앙 이호르 메사지. 포르 이잠플리, 아세르트!(스 &gt; 0) 워우드 파니크 이프 스 이스 노트 그레아테르 탕 0.</span>
<span style="color:#323232;">assert!(...): This macro is used to write tests and ensure that certain conditions are met. It takes a boolean expression as an argument, and if the expression is false, it panics with an error message. For example, assert!(x &gt; 0) would panic if x is not greater than 0.</span>

<span style="color:#323232;">잉클루지!(...): 티스 마크루 이스 우제드 투 잉클루지 티 콘텐트스 오프 아 필리 아트 콤필리-치미. 이트 타키스 아 필리 파트 아스 앙 아르구멘트, 안드 잉클루지스 티 콘텐트스 오프 티 필리 아스 아 스트링그 콘스탄트 잉 티 콤필레드 비나리. 포르 이잠플리, 잉클루지!(&quot;다타.트스트&quot;) 워우드 잉클루지 티 콘텐트스 오프 다타.트스트 아스 아 스트링그 콘스탄트.</span>
<span style="color:#323232;">include!(...): This macro is used to include the contents of a file at compile-time. It takes a file path as an argument, and includes the contents of the file as a string constant in the compiled binary. For example, include!(&quot;data.txt&quot;) would include the contents of data.txt as a string constant.</span>

<span style="color:#323232;">콩카트_이덴트스!(...): 티스 마크루 이스 우제드 투 콩카테나치 이덴치피에르스 아트 콤필리-치미. 이트 타키스 아 세리스 오프 이덴치피에르 이스프레시옹스 아스 아르구멘트스, 안드 콩카테나치스 텡 인투 아 싱글리 이덴치피에르. 포르 이잠플리, 콩카트_이덴트스!(미_스트룩트, _피에우드) 워우드 프로두시 티 이덴치피에르 미_스트룩트_피에우드.</span>
<span style="color:#323232;">concat_idents!(...): This macro is used to concatenate identifiers at compile-time. It takes a series of identifier expressions as arguments, and concatenates them into a single identifier. For example, concat_idents!(my_struct, _field) would produce the identifier my_struct_field.</span>

<span style="color:#323232;">스트린지피_이덴트!(...): 티스 마크루 이스 우제드 투 콘베르트 앙 이덴치피에르 투 아 스트링그 아트 콤필리-치미. 이트 타키스 앙 이덴치피에르 이스프레시옹 아스 앙 아르구멘트, 안드 헤투릉스 아 스트링그 헤프레젠타치옹 오프 티 이덴치피에르. 포르 이잠플리, 스트린지피_이덴트!(미_바리아블리) 워우드 헤투릉 티 스트링그 &quot;미_바리아블리&quot;.</span>
<span style="color:#323232;">stringify_ident!(...): This macro is used to convert an identifier to a string at compile-time. It takes an identifier expression as an argument, and returns a string representation of the identifier. For example, stringify_ident!(my_variable) would return the string &quot;my_variable&quot;.</span>

<span style="color:#323232;">테지 마크루스 캉 비 에우프풀 잉 바리오스 시투아치옹스, 프롱 데부징그 안드 테스칭그 투 코지 제네라치옹 안드 메타프로그라밍그.</span>
<span style="color:#323232;">These macros can be helpful in various situations, from debugging and testing to code generation and metaprogramming.</span>

<span style="color:#323232;">## 지비 2 프라그마치크 이잠플리스</span>
<span style="color:#323232;">## give 2 pragmatic examples</span>

<span style="color:#323232;">&lt; 수리, 에리 아리 트우 프라그마치크 이잠플리스 오프 후스트 마크루스:</span>
<span style="color:#323232;">&lt; Sure, here are two pragmatic examples of Rust macros:</span>

<span style="color:#323232;">드브그!: 수포지 요&#39;히 데부징그 아 후스트 프로그랑 안드 요 완트 투 프린트 티 발루이 오프 아 바리아블리 투 티 콘솔리. 인스테아드 오프 리칭그 아 세파라치 프린틀릉! 스타테멘트 포르 이아시 바리아블리, 요 캉 우지 티 드브그! 마크루 투 프린트 티 발루이 오프 티 바리아블리 안드 이트스 나미 아트 티 사미 치미. 포르 이잠플리:</span>
<span style="color:#323232;">dbg!: Suppose you&#39;re debugging a Rust program and you want to print the value of a variable to the console. Instead of writing a separate println! statement for each variable, you can use the dbg! macro to print the value of the variable and its name at the same time. For example:</span>

<span style="color:#323232;">```후스트</span>
<span style="color:#323232;">```rust</span>
<span style="color:#323232;">레트 스 = 42</span>
<span style="color:#323232;">let x = 42;</span>
<span style="color:#323232;">드브그!(스) // 프린트스 &quot;스흐크/마잉.흐스:3:4: 스 = 42&quot;</span>
<span style="color:#323232;">dbg!(x); // prints &quot;src/main.rs:3:4: x = 42&quot;</span>

</pre><pre>
<span style="color:#323232;">티스 프린트스 티 필리 나미, 리니 눔베르, 콜룸응 눔베르, 바리아블리 나미, 안드 바리아블리 발루이 투 티 콘솔리, 마킹그 이트 이아지 투 데부그 요르 프로그랑.</span>
<span style="color:#323232;">This prints the file name, line number, column number, variable name, and variable value to the console, making it easy to debug your program.</span>

<span style="color:#323232;">잉클루지!: 수포지 요 아비 아 라르지 다타 필리, 수시 아스 아 크스브 오르 즈송 필리, 타트 요 완트 투 잉클루지 잉 요르 후스트 프로그랑. 인스테아드 오프 헤아징그 티 필리 아트 훈치미, 요 캉 우지 티 잉클루지! 마크루 투 잉클루지 티 콘텐트스 오프 티 필리 아트 콤필리-치미. 포르 이잠플리:</span>
<span style="color:#323232;">include!: Suppose you have a large data file, such as a CSV or JSON file, that you want to include in your Rust program. Instead of reading the file at runtime, you can use the include! macro to include the contents of the file at compile-time. For example:</span>

<span style="color:#323232;">```후스트</span>
<span style="color:#323232;">```rust</span>
<span style="color:#323232;">레트 다타: &amp;&#39;스타치크 스트르 = 잉클루지_스트르!(&quot;다타.크스브&quot;)</span>
<span style="color:#323232;">let data: &amp;&#39;static str = include_str!(&quot;data.csv&quot;);</span>

</pre><pre>
<span style="color:#323232;">티스 헤아드스 티 콘텐트스 오프 다타.크스브 안드 잉클루지스 텡 아스 아 스타치크 스트링그 잉 티 콤필레드 비나리. 티스 캉 마키 요르 프로그랑 파스테르 안드 모리 이피시엔트, 신시 이트 도에증&#39;트 네드 투 헤아드 티 필리 아트 훈치미.</span>
<span style="color:#323232;">This reads the contents of data.csv and includes them as a static string in the compiled binary. This can make your program faster and more efficient, since it doesn&#39;t need to read the file at runtime.</span>

<span style="color:#323232;">이 오피 테지 이잠플리스 에우프 일루스트라치 티 프락치카우 우지스 오프 후스트 마크루스!</span>
<span style="color:#323232;">I hope these examples help illustrate the practical uses of Rust macros!</span>

<span style="color:#323232;">## 2 모리 이잠플리스, 포르 티 나스치 카지스</span>
<span style="color:#323232;">## 2 more examples, for the nasty cases</span>

<span style="color:#323232;">&lt; 수리, 에리 아리 트우 모리 이잠플리스 오프 후스트 마크루스 포르 티 &quot;나스치&quot; 카지스:</span>
<span style="color:#323232;">&lt; Sure, here are two more examples of Rust macros for the &quot;nasty&quot; cases:</span>

<span style="color:#323232;">트리!: 수포지 요&#39;히 워르킹그 위트 아 레가키 후스트 코데바지 타트 우지스 티 트리! 마크루, 이시 아스 신시 벵 데프레카테드 잉 파보르 오프 티 ? 오페라토르. 인스테아드 오프 헤팍토링그 티 인치리 코데바지, 요 캉 우지 티 트리! 마크루 아스 아 소르탄드 포르 티 ? 오페라토르. 포르 이잠플리:</span>
<span style="color:#323232;">try!: Suppose you&#39;re working with a legacy Rust codebase that uses the try! macro, which has since been deprecated in favor of the ? operator. Instead of refactoring the entire codebase, you can use the try! macro as a shorthand for the ? operator. For example:</span>

<span style="color:#323232;">```후스트</span>
<span style="color:#323232;">```rust</span>
<span style="color:#323232;">레트 헤주우트 = 트리!(소미_풍크치옹())</span>
<span style="color:#323232;">let result = try!(some_function());</span>

</pre><pre>
<span style="color:#323232;">티스 이스 이키발렌트 투:</span>
<span style="color:#323232;">This is equivalent to:</span>

<span style="color:#323232;">```후스트</span>
<span style="color:#323232;">```rust</span>
<span style="color:#323232;">레트 헤주우트 = 소미_풍크치옹()?</span>
<span style="color:#323232;">let result = some_function()?;</span>

</pre><pre>
<span style="color:#323232;">티스 캉 사비 요 아 로트 오프 치미 안드 이포르트 엥 데알링그 위트 레가키 코지.</span>
<span style="color:#323232;">This can save you a lot of time and effort when dealing with legacy code.</span>

<span style="color:#323232;">콩카트_이덴트스!: 수포지 요&#39;히 워르킹그 옹 아 코지 제네라토르 타트 네드스 투 제네라치 아 라르지 눔베르 오프 이덴치피에르스 바제드 옹 인푸트 다타. 인스테아드 오프 리칭그 헤페치치비 코지 투 제네라치 이아시 이덴치피에르, 요 캉 우지 티 콩카트_이덴트스! 마크루 투 제네라치 티 이덴치피에르스 아트 콤필리-치미. 포르 이잠플리:</span>
<span style="color:#323232;">concat_idents!: Suppose you&#39;re working on a code generator that needs to generate a large number of identifiers based on input data. Instead of writing repetitive code to generate each identifier, you can use the concat_idents! macro to generate the identifiers at compile-time. For example:</span>

<span style="color:#323232;">```후스트</span>
<span style="color:#323232;">```rust</span>
<span style="color:#323232;">마크루_훌리스! 제네라치_이덴치피에르스 {</span>
<span style="color:#323232;">macro_rules! generate_identifiers {</span>
<span style="color:#323232;">($프레피스:이스프르, $콘트:이스프르) =&gt; {</span>
<span style="color:#323232;">($prefix:expr, $count:expr) =&gt; {</span>
<span style="color:#323232;">$(</span>
<span style="color:#323232;">$(</span>
<span style="color:#323232;">콩카트_이덴트스!($프레피스, $콘트)</span>
<span style="color:#323232;">concat_idents!($prefix, $count);</span>
<span style="color:#323232;">)*</span>
<span style="color:#323232;">)*</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">제네라치_이덴치피에르스!(&quot;미_이덴치피에르_&quot;, 1, 2, 3, 4, 5)</span>
<span style="color:#323232;">generate_identifiers!(&quot;my_identifier_&quot;, 1, 2, 3, 4, 5);</span>

</pre><pre>
<span style="color:#323232;">티스 제네라치스 티 이덴치피에르스 미_이덴치피에르_1, 미_이덴치피에르_2, 미_이덴치피에르_3, 미_이덴치피에르_4, 안드 미_이덴치피에르_5 아트 콤필리-치미. 티스 캉 사비 요 아 로트 오프 헤페치치비 코지 안드 마키 요르 코지 제네라토르 모리 이피시엔트.</span>
<span style="color:#323232;">This generates the identifiers my_identifier_1, my_identifier_2, my_identifier_3, my_identifier_4, and my_identifier_5 at compile-time. This can save you a lot of repetitive code and make your code generator more efficient.</span>

<span style="color:#323232;">이 오피 테지 이잠플리스 에우프 일루스트라치 티 포웨르 안드 플레시빌리치 오프 후스트 마크루스, 이벵 잉 &quot;나스치&quot; 오르 에드지 카지스.</span>
<span style="color:#323232;">I hope these examples help illustrate the power and flexibility of Rust macros, even in &quot;nasty&quot; or edge cases.</span>

<span style="color:#323232;">## 이프 위 웨리 투 헤리치 티 리누스 케르네우 프롱 스크라트시 잉 후스트, 이시 다타 스트룩투리스 워우드 위 스타르트 위트? (치페스/이눔스)</span>
<span style="color:#323232;">## if we were to rewrite the linux kernel from scratch in rust, which data structures would we start with? (types/enums)</span>

<span style="color:#323232;">&lt; 이프 요 웨리 투 헤리치 티 리누스 케르네우 프롱 스크라트시 잉 후스트, 요 워우드 리켈리 스타르트 위트 티 다타 스트룩투리스 타트 아리 코몬리 우제드 잉 오페라칭그 시스템스 케르네우스, 수시 아스 링케드 리스트스, 트레이스 (이.그. 헤드-블라크 트레이스, 아부 트레이스), 아즈 타블리스, 안드 케우이스. 소미 이잠플리스 오프 스페시피크 치페스 오르 이눔스 타트 요 미그트 우지 잉 아 후스트 케르네우 잉클루지 `링케들리스트&lt;트&gt;`, `브트레마프&lt;크, 브&gt;`, 안드 `벡데키&lt;트&gt;`. 아지치오날리, 티 케르네우 워우드 리켈리 우지 아 바리에치 오프 로-레베우 치페스 포르 메모리 마나제멘트 안드 인테르-프로세스 코무니카치옹, 수시 아스 아토미쿠지지, 무테스, 안드 므프스크::샤네우().</span>
<span style="color:#323232;">&lt; If you were to rewrite the Linux kernel from scratch in Rust, you would likely start with the data structures that are commonly used in operating systems kernels, such as linked lists, trees (e.g. red-black trees, AVL trees), hash tables, and queues. Some examples of specific types or enums that you might use in a Rust kernel include `LinkedList&lt;T&gt;`, `BTreeMap&lt;K, V&gt;`, and `VecDeque&lt;T&gt;`. Additionally, the kernel would likely use a variety of low-level types for memory management and inter-process communication, such as AtomicUsize, Mutex, and mpsc::channel().</span>

<span style="color:#323232;">케프 잉 민드 타트 헤리칭그 아 케르네우 이스 아 우지 타스크, 안드 노트 온리 포르 후스트 이트 워우드 헤키리 치미 안드 아 로트 오프 크놀레드지 투 아시에비 이트.</span>
<span style="color:#323232;">Keep in mind that rewritting a kernel is a huge task, and not only for Rust; it would require time and a lot of knowledge to achieve it.</span>

<span style="color:#323232;">## 이시 치피/이눙 워우드 비 티 피르스트 텡? 투 스타르트 티 마잉 풍크치옹</span>
<span style="color:#323232;">## which type/enum would be the first then? to start the main function</span>

<span style="color:#323232;">&lt; 티 피르스트 치피 오르 이눙 타트 워우드 비 우제드 잉 티 마잉 풍크치옹 오프 아 후스트 케르네우 워우드 리켈리 비 아 치피 타트 헤프레젠트스 티 시스텡&#39;스 쿠헨트 스타치, 수시 아스 앙 이누메라치옹 (이눙) 오르 아 세트 오프 글로바우 바리아블리스. 티스 치피 코우드 콘타잉 인포르마치옹 수시 아스 티 쿠헨트 프로세스, 티 스타치 오프 티 시스텡&#39;스 메모리, 안드 오테르 인포르마치옹 타트 이스 네데드 투 마나지 티 시스텡&#39;스 헤조르시스. 데펜징그 옹 티 데지긍 오프 티 케르네우, 이트 미그트 아우수 잉클루지 피에우드스 포르 티 시스텡&#39;스 스셰둘레르, 메모리 마나제르, 안드 오테르 임포르탄트 수브시스템스.</span>
<span style="color:#323232;">&lt; The first type or enum that would be used in the main function of a Rust kernel would likely be a type that represents the system&#39;s current state, such as an enumeration (enum) or a set of global variables. This type could contain information such as the current process, the state of the system&#39;s memory, and other information that is needed to manage the system&#39;s resources. Depending on the design of the kernel, it might also include fields for the system&#39;s scheduler, memory manager, and other important subsystems.</span>

<span style="color:#323232;">아우수 이트 이스 임포르탄트 투 포인트 오트 타트 티 마잉 풍크치옹 잉 아 후스트 케르네우 워우드 비 티 \_스타르트 오르 \_스타르트_후스트 심보우, 이트 워우드 안들리 로-레베우 이니치알리자치옹 수시 아스 세칭그 우프 티 스타크, 칼링그 콘스트룩토르스, 제로잉그 브스 안드 수 옹, 베포리 트란스페힝그 콘트로우 투 티 케르네우 프로페르.</span>
<span style="color:#323232;">Also it is important to point out that the main function in a Rust kernel would be the \_start or \_start_rust symbol, it would handle low-level initialization such as setting up the stack, calling constructors, zeroing BSS and so on, before transferring control to the kernel proper.</span>

<span style="color:#323232;">## 캉 요 지비 미 아 스케트시 오프 티스 이눙 잉 아 후스트 코지 블로크?</span>
<span style="color:#323232;">## can you give me a sketch of this enum in a rust code block?</span>

<span style="color:#323232;">&lt; 수리! 에리&#39;스 앙 이잠플리 오프 아트 아 심플리 이눙 포르 아 케르네우&#39;스 스타치 미그트 로크 리키 잉 후스트:</span>
<span style="color:#323232;">&lt; Sure! Here&#39;s an example of what a simple enum for a kernel&#39;s state might look like in Rust:</span>

<span style="color:#323232;">```후스트</span>
<span style="color:#323232;">```rust</span>
<span style="color:#323232;">이눙 케르네우스타치 {</span>
<span style="color:#323232;">enum KernelState {</span>
<span style="color:#323232;">후닝그(프로세스),</span>
<span style="color:#323232;">Running(Process),</span>
<span style="color:#323232;">슬레핑그(치메르),</span>
<span style="color:#323232;">Sleeping(Timer),</span>
<span style="color:#323232;">아우테드,</span>
<span style="color:#323232;">Halted,</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

</pre><pre>
<span style="color:#323232;">티스 이눙 아스 트레이 바리안트스:</span>
<span style="color:#323232;">This enum has three variants:</span>

<span style="color:#323232;">후닝그(프로세스): 인지카치스 타트 티 케르네우 이스 쿠헨틀리 후닝그 아 프로세스. 티 프로세스 치피 워우드 네드 투 비 데피네드 이우세에리 잉 티 코지, 안드 코우드 콘타잉 인포르마치옹 아보트 티 쿠헨트 프로세스, 수시 아스 이트스 메모리 라요트 안드 오펭 필리 데스크리프토르스.</span>
<span style="color:#323232;">Running(Process): Indicates that the kernel is currently running a process. The Process type would need to be defined elsewhere in the code, and could contain information about the current process, such as its memory layout and open file descriptors.</span>

<span style="color:#323232;">슬레핑그(치메르): 인지카치스 타트 티 케르네우 아스 인테레드 아 슬레프 스타치, 포시블리 와이칭그 포르 아 스페시피크 이벤트 오르 치미 투 오쿠르. 티 치메르 치피 워우드 아우수 네드 투 비 데피네드 이우세에리 잉 티 코지, 안드 코우드 콘타잉 인포르마치옹 아보트 티 두라치옹 오프 티 슬레프, 오르 티 스페시피크 이벤트 타트 티 케르네우 이스 와이칭그 포르.</span>
<span style="color:#323232;">Sleeping(Timer): Indicates that the kernel has entered a sleep state, possibly waiting for a specific event or time to occur. The Timer type would also need to be defined elsewhere in the code, and could contain information about the duration of the sleep, or the specific event that the kernel is waiting for.</span>

<span style="color:#323232;">아우테드: 인지카치스 타트 티 케르네우 아스 아우테드, 메아닝그 이트 이스 노트 후닝그 아니 프로세스 안드 노트 페르포르밍그 아니 타스크.</span>
<span style="color:#323232;">Halted: Indicates that the kernel has halted, meaning it is not running any process and not performing any task.</span>

<span style="color:#323232;">티스 이스 주스트 아 심플리 이잠플리 안드 마니 모리 피에우드스 캉 비 아데드 투 이트 안드 마니 모리 치페스 오프 스타치스 캉 비 아데드 투 이트, 티스 위우 비 데펜드 옹 티 헤키레멘트스 안드 데지긍 오프 티 케르네우.</span>
<span style="color:#323232;">This is just a simple example and many more fields can be added to it and many more types of states can be added to it, this will be depend on the requirements and design of the kernel.</span>

<span style="color:#323232;">## 아트 에우시 코우드 비 부이우트 텡. 타트 도에증&#39;트 브링그 지젱코라제멘트</span>
<span style="color:#323232;">## what else could be built then. that doesn&#39;t bring disencouragement</span>

<span style="color:#323232;">&lt; 이프 요&#39;히 인테레스테드 잉 워르킹그 옹 아 후스트 오페라칭그 시스텡 케르네우, 테리 아리 세베라우 오테르 팅그스 타트 요 코우드 부이우드 타트 동&#39;트 헤키리 아 콤플레치 헤리치 프롱 스크라트시. 소미 이잠플리스 잉클루지:</span>
<span style="color:#323232;">&lt; If you&#39;re interested in working on a Rust operating system kernel, there are several other things that you could build that don&#39;t require a complete rewrite from scratch. Some examples include:</span>

<span style="color:#323232;">임플레멘칭그 아 심플리 스셰둘레르 잉 후스트 타트 캉 비 우제드 투 마나지 티 이제쿠치옹 오프 프로세시스 옹 아 리누스-바제드 시스텡. 티스 코우드 비 아 고드 와이 투 레아릉 모리 아보트 오 오페라칭그 시스템스 스셰둘리 프로세시스 안드 투 가잉 이스페리엔시 워르킹그 위트 후스트&#39;스 로-레베우 페아투리스.</span>
<span style="color:#323232;">Implementing a simple scheduler in Rust that can be used to manage the execution of processes on a Linux-based system. This could be a good way to learn more about how operating systems schedule processes and to gain experience working with Rust&#39;s low-level features.</span>

<span style="color:#323232;">데벨로핑그 아 네 시스텡 카우 오르 리브라리 잉 후스트 타트 캉 비 우제드 투 인테르파시 위트 티 케르네우&#39;스 이지스칭그 풍크치오날리치. 티스 코우드 비 우제풀 포르 아징그 네 풍크치오날리치 투 앙 이지스칭그 오페라칭그 시스텡, 수시 아스 아 모리 이피시엔트 메모리 마나제멘트 시스텡 오르 아 네 필레지스텡.</span>
<span style="color:#323232;">Developing a new system call or library in Rust that can be used to interface with the kernel&#39;s existing functionality. This could be useful for adding new functionality to an existing operating system, such as a more efficient memory management system or a new filesystem.</span>

<span style="color:#323232;">리칭그 아 후스트-바제드 데비시 드리베르 포르 아 스페시피크 피에시 오프 아르드와리, 수시 아스 아 네트워르크 카르드 오르 스토라지 데비시. 티스 워우드 알로 요 투 워르크 위트 후스트&#39;스 로-레베우 페아투리스 안드 코우드 에우프 요 레아릉 모리 아보트 오 지페렌트 치페스 오프 아르드와리 워르크.</span>
<span style="color:#323232;">Writing a Rust-based device driver for a specific piece of hardware, such as a network card or storage device. This would allow you to work with Rust&#39;s low-level features and could help you learn more about how different types of hardware work.</span>

<span style="color:#323232;">임플레멘칭그 아 우제르스파시 리브라리 타트 인테락트스 위트 티 리누스 케르네우. 티스 캉 알로 부이우징그 네 풍크치오날리치스 우징그 후스트&#39;스 이게르-레베우 페아투리스 수시 아스 이호르 안들링그 안드 메모리 사페치 타트 아리 노트 프레젠트 잉 티 케르네우.</span>
<span style="color:#323232;">Implementing a userspace library that interacts with the Linux kernel. This can allow building new functionalities using Rust&#39;s higher-level features such as error handling and memory safety that are not present in the kernel.</span>

<span style="color:#323232;">부이우징그 아 후스트-바제드 아플리카치옹 타트 훙스 옹 토프 오프 앙 이지스칭그 오페라칭그 시스텡, 리키 아 쿠스통 웨브 세르베르 오르 아 코만드-리니 토우. 티스 위우 에우프 요 레아릉 티 랑구아지, 안드 프락치시 후스트 시스텡 프로그라밍그</span>
<span style="color:#323232;">Building a Rust-based application that runs on top of an existing operating system, like a custom web server or a command-line tool. This will help you learn the language, and practice rust system programming</span>

<span style="color:#323232;">아우 테지 아리 스말레르 부트 스치우 샬렌징그 타스크스, 안드 위우 에우프 요 잉 운데르스탄징그 티 비제르 픽투리 오프 오 앙 오페라칭그 시스텡 워르크스,안드 아우수 오 후스트 캉 비 우제드 이펙치벨리 잉 로-레베우 시스템스 프로그라밍그.</span>
<span style="color:#323232;">All these are smaller but still challenging tasks, and will help you in understanding the bigger picture of how an operating system works,and also how Rust can be used effectively in low-level systems programming.</span>

<span style="color:#323232;">## 오 아 토우 우징그 잉크리프테드 텔레그랑 메사지스 오르 필리스 코미테드 트로그 지트 코우드 비 부이우트?</span>
<span style="color:#323232;">## how a tool using encrypted telegram messages or files committed through git could be built?</span>

<span style="color:#323232;">&lt; 부이우징그 아 토우 타트 우지스 잉크리프테드 텔레그랑 메사지스 오르 필리스 코미테드 트로그 지트 투 스토리 안드 트란즈미트 다타 워우드 리켈리 인보우비 아 페 지페렌트 스테프스 안드 콤포넨트스.</span>
<span style="color:#323232;">&lt; Building a tool that uses encrypted Telegram messages or files committed through Git to store and transmit data would likely involve a few different steps and components.</span>

<span style="color:#323232;">잉크리프치옹: 티 토우 워우드 네드 투 우지 아 스트롱그 잉크리프치옹 아우고리틍 투 잉크리프트 티 다타 베포리 이트 이스 센트 오베르 텔레그랑 오르 코미테드 투 지트. 테리 아리 마니 잉크리프치옹 리브라리스 아바일라블리 잉 바리오스 프로그라밍그 랑구아지스 타트 캉 비 우제드 투 잉크리프트 다타.</span>
<span style="color:#323232;">Encryption: The tool would need to use a strong encryption algorithm to encrypt the data before it is sent over Telegram or committed to Git. There are many encryption libraries available in various programming languages that can be used to encrypt data.</span>

<span style="color:#323232;">텔레그랑 아피: 투 센드 안드 헤세이비 텔레그랑 메사지스, 티 토우 워우드 네드 투 우지 티 텔레그랑 보트 아피. 티스 아피 알로스 데벨로페르스 투 인테락트 위트 티 텔레그랑 플라트포릉 안드 크레아치 보트스 타트 캉 센드 안드 헤세이비 메사지스. 티 토우 코우드 우지 티스 아피 투 센드 안드 헤세이비 티 잉크리프테드 다타 아스 메사지스.</span>
<span style="color:#323232;">Telegram API: To send and receive Telegram messages, the tool would need to use the Telegram Bot API. This API allows developers to interact with the Telegram platform and create bots that can send and receive messages. The tool could use this API to send and receive the encrypted data as messages.</span>

<span style="color:#323232;">지트 인테그라치옹: 투 코미트 티 잉크리프테드 다타 투 아 지트 헤포지토리, 티 토우 워우드 네드 투 우지 아 지트 리브라리 오르 코만드 리니 인테르파시 (클리) 타트 알로스 프로그라마치크 아세스 투 지트. 티스 코우드 비 도니 비 우징그 지트 코만드 안드 세우 스크리프칭그. 오르 비 우징그 지트 리브라리스, 수시 아스 리브지트2, 투 인테락트 위트 지트 헤포지토리스.</span>
<span style="color:#323232;">Git integration: To commit the encrypted data to a Git repository, the tool would need to use a Git library or command line interface (CLI) that allows programmatic access to Git. This could be done by using git command and shell scripting. Or by using Git libraries, such as libgit2, to interact with Git repositories.</span>

<span style="color:#323232;">케이 마나제멘트: 투 잉크리프트 안드 데크리프트 티 다타, 티 토우 워우드 네드 투 우지 아 케이 마나제멘트 시스텡. 티 케이 캉 비 제네라테드, 스토리 로칼리 안드 사레드 세쿠렐리 위트 티 파르치 티 다타 이스 베잉그 사레드 위트.</span>
<span style="color:#323232;">Key Management: To encrypt and decrypt the data, the tool would need to use a key management system. The key can be generated, store locally and shared securely with the party the data is being shared with.</span>

<span style="color:#323232;">우제르 인테르파시: 티 토우 코우드 아비 아 우제르 인테르파시 (우이) 타트 알로스 우제르스 투 이아질리 센드 안드 헤세이비 잉크리프테드 메사지스 트로그 텔레그랑, 오르 코미트 안드 헤트리에비 필리스 프롱 티 지트 헤포지토리.</span>
<span style="color:#323232;">User Interface: The tool could have a user interface (UI) that allows users to easily send and receive encrypted messages through Telegram, or commit and retrieve files from the Git repository.</span>

<span style="color:#323232;">이호르 안들링그: 프로페르 이호르 안들링그 소우드 비 잉 플라시 투 안들리 아니 우네스펙테드 이호르 타트 코우드 오쿠르 일리 센징그, 헤세이빙그 오르 코미칭그 티 다타.</span>
<span style="color:#323232;">Error Handling: Proper error handling should be in place to handle any unexpected error that could occur while sending, receiving or committing the data.</span>

<span style="color:#323232;">로징그: 아빙그 아 로징그 메샤니증 투 트라시 안드 트로블레조트 아니 이수이 타트 마이 아리지 두링그 티 오페라치옹 오프 티 토우.</span>
<span style="color:#323232;">Logging: Having a logging mechanism to trace and troubleshoot any issue that may arise during the operation of the tool.</span>

<span style="color:#323232;">아우 오프 테지 스테프스 코우드 비 임플레멘테드 우징그 아 바리에치 오프 프로그라밍그 랑구아지스 안드 프라메워르크스, 데펜징그 옹 티 스페시피크 헤키레멘트스 오프 티 토우.</span>
<span style="color:#323232;">All of these steps could be implemented using a variety of programming languages and frameworks, depending on the specific requirements of the tool.</span>

<span style="color:#323232;">이트&#39;스 워르트 노칭그 타트 티스 이스 아 키치 브로아드 수브젝트, 안드 테리 아리 마니 데타이우스 투 콘시데르 엥 부이우징그 수시 아 토우 수시 아스 세쿠리치, 스칼라빌리치 안드 이아지 오프 우지. 이트&#39;스 아우수 임포르탄트 투 콘시데르 레가우, 콤플리안시 안드 헤굴라치옹 이수이스 베포리 부이우징그 안드 우징그 수시 아 토우.</span>
<span style="color:#323232;">It&#39;s worth noting that this is a quite broad subject, and there are many details to consider when building such a tool such as security, scalability and ease of use. It&#39;s also important to consider legal, compliance and regulation issues before building and using such a tool.</span>

<span style="color:#323232;">## 레트스 포르제트 티 잉크리프치옹 포르 노, 안드 포쿠스 옹 후스트 안드 웨바셈블리. 코우드 티 텔레그랑 아피 비 아세세드 프롱 이트?</span>
<span style="color:#323232;">## lets forget the encryption for now, and focus on rust and webassembly. could the telegram api be accessed from it?</span>

<span style="color:#323232;">&lt; 이스, 이트 이스 포시블리 투 아세스 티 텔레그랑 아피 프롱 아 후스트/웨바셈블리 아플리카치옹.</span>
<span style="color:#323232;">&lt; Yes, it is possible to access the Telegram API from a Rust/WebAssembly application.</span>

<span style="color:#323232;">투 아세스 티 텔레그랑 아피 프롱 아 후스트 아플리카치옹, 요 캉 우지 아 리브라리 수시 아스 텔로시지, 이시 이스 아 후스트 라페르 아론드 티 텔레그랑 보트 아피. 텔로시지 이스 부이우트 옹 토프 오프 티 헥으웨스트 리브라리, 이시 이스 아 후스치크 리브라리 포르 마킹그 트프 헤케스트스. 우징그 텔로시지, 요 캉 크레아치 텔레그랑 보트스, 센드 안드 헤세이비 메사지스, 안드 우지 오테르 페아투리스 프로비데드 비 티 텔레그랑 아피.</span>
<span style="color:#323232;">To access the Telegram API from a Rust application, you can use a library such as teloxide, which is a Rust wrapper around the Telegram Bot API. Teloxide is built on top of the reqwest library, which is a rustic library for making HTTP requests. Using Teloxide, you can create Telegram bots, send and receive messages, and use other features provided by the Telegram API.</span>

<span style="color:#323232;">투 우지 아 후스트 리브라리 잉 아 웨바셈블리 아플리카치옹, 요 위우 네드 투 우지 아 토우 수시 아스 와증-빈드젱 타트 알로스 요 투 임포르트 안드 우지 후스트 풍크치옹스 프롱 자바스크리프트. 아지치오날리, 요 캉 우지 웨브-시스 크라치 투 인테락트 위트 자바스크리프트 동 아피 포르 부이우징그 아 우이 포르 요르 아플리카치옹</span>
<span style="color:#323232;">To use a Rust library in a WebAssembly application, you will need to use a tool such as wasm-bindgen that allows you to import and use Rust functions from JavaScript. Additionally, you can use web-sys crate to interact with JavaScript DOM API for building a UI for your application</span>

<span style="color:#323232;">온시 요 아비 티 텔레그랑 아피 아세시블리 잉 후스트, 요 캉 텡 우지 티 와증-빈드젱 투 이스포지 토지 풍크치옹스 투 자바스크리프트 안드 마키 우지 오프 티 텔레그랑 아피 잉 요르 웨바셈블리 아플리카치옹.</span>
<span style="color:#323232;">Once you have the Telegram API accessible in Rust, you can then use the wasm-bindgen to expose those functions to JavaScript and make use of the Telegram API in your WebAssembly application.</span>

<span style="color:#323232;">이트&#39;스 워르트 노칭그 타트 일리 티스 이스 포시블리, 부이우징그 티 올리 아플리카치옹 잉 후스트 안드 웨바셈블리 이스 노트 트리비아우, 이트 코우드 헤키리 아 솔리드 운데르스탄징그 오프 후스트 안드 웨바셈블리, 텔레그랑 아피 안드 자바스크리프트.</span>
<span style="color:#323232;">It&#39;s worth noting that while this is possible, building the whole application in Rust and WebAssembly is not trivial, it could require a solid understanding of Rust and WebAssembly, Telegram API and JavaScript.</span>

<span style="color:#323232;">아우수, 케프 잉 민드 타트 요 위우 네드 투 안들리 티 콤플레시치스 오프 티 텔레그랑 아피, 수시 아스 세쿠리치 안드 하치 리미칭그, 잉 요르 아플리카치옹 안드 마키 수리 타트 요 폴로 텔레그랑&#39;스 테름스 오프 세르비시 엥 부이우징그 요르 아플리카치옹.</span>
<span style="color:#323232;">Also, keep in mind that you will need to handle the complexities of the Telegram API, such as security and rate limiting, in your application and make sure that you follow Telegram&#39;s terms of service when building your application.</span>

<span style="color:#323232;">## 코우드 아 지트 세르베르 비 부이우트 프롱 스크라트시 에리 티 필리 스토라지 이스 앙 이벤트 소르싱그 로그 우징그 티 텔레그랑 아피?</span>
<span style="color:#323232;">## could a git server be built from scratch where the file storage is an event sourcing log using the telegram api?</span>

<span style="color:#323232;">&lt; 이스, 이트 이스 포시블리 투 부이우드 아 지트 세르베르 프롱 스크라트시 에리 티 필리 스토라지 이스 앙 이벤트 소르싱그 로그 우징그 티 텔레그랑 아피. 티스 워우드 인보우비 세베라우 지페렌트 콤포넨트스:</span>
<span style="color:#323232;">&lt; Yes, it is possible to build a Git server from scratch where the file storage is an event sourcing log using the Telegram API. This would involve several different components:</span>

<span style="color:#323232;">텔레그랑 아피: 티 텔레그랑 아피 워우드 비 우제드 투 트란즈미트 이벤트스 베트웽 티 클리엔트스 안드 티 세르베르. 클리엔트스 워우드 센드 지트 오페라치옹스 아스 메사지스 투 티 텔레그랑 보트, 안드 티 세르베르 워우드 헤스폰드 위트 티 이벤트 소르싱그 로그 오프 티 샨지스 투 티 헤포지토리.</span>
<span style="color:#323232;">Telegram API: The Telegram API would be used to transmit events between the clients and the server. Clients would send git operations as messages to the Telegram bot, and the server would respond with the event sourcing log of the changes to the repository.</span>

<span style="color:#323232;">이벤트 소르싱그: 티 필리 스토라지 워우드 비 바제드 옹 앙 이벤트 소르싱그 로그, 에리 이베리 샨지 투 티 헤포지토리 이스 스토레드 아스 앙 이벤트. 티스 코우드 인보우비 크레아칭그 아 네 다타 스트룩투리 포르 스토링그 티 이벤트스, 수시 아스 앙 아펜드-온리 로그 오르 아 세트 오프 이벤트-소르세드 아그레가치스.</span>
<span style="color:#323232;">Event Sourcing: The file storage would be based on an event sourcing log, where every change to the repository is stored as an event. This could involve creating a new data structure for storing the events, such as an append-only log or a set of event-sourced aggregates.</span>

<span style="color:#323232;">지트 오페라치옹스: 티 세르베르 워우드 네드 투 임플레멘트 티 지트 오페라치옹스 수시 아스 코미트, 푸즈, 풀, 메르지 이트크. 티스 캉 비 도니 우징그 후스트 오르 아니 오테르 프로그라밍그 랑구아지 안드 우징그 리브라리스 수시 아스 리브지트2 투 안들리 지트 오페라치옹스.</span>
<span style="color:#323232;">Git Operations: The server would need to implement the git operations such as commit, push, pull, merge etc. this can be done using Rust or any other programming language and using libraries such as libgit2 to handle git operations.</span>

<span style="color:#323232;">스타치 마나제멘트: 티 세르베르 워우드 네드 투 케프 트라크 오프 티 스타치 오프 티 헤포지토리, 비 헤플라잉그 티 이벤트스 투 데리비 티 쿠헨트 스타치 오프 티 헤포지토리.</span>
<span style="color:#323232;">State Management: The server would need to keep track of the state of the repository, by replaying the events to derive the current state of the repository.</span>

<span style="color:#323232;">아우텐치카치옹: 티 세르베르 워우드 네드 투 안들리 아우텐치카치옹 오프 클리엔트스, 수 타트 온리 아우토리제드 클리엔트스 캉 인테락트 위트 티 헤포지토리. 티스 코우드 비 도니 비 임플레멘칭그 아 심플리 토켕-바제드 아우텐치카치옹 시스텡, 오르 비 우징그 텔레그랑&#39;스 부이우트-잉 아우텐치카치옹 메샤니즘스 수시 아스 우제르-보트 샤트.</span>
<span style="color:#323232;">Authentication: The server would need to handle authentication of clients, so that only authorized clients can interact with the repository. This could be done by implementing a simple token-based authentication system, or by using Telegram&#39;s built-in authentication mechanisms such as user-bot chat.</span>

<span style="color:#323232;">이호르 안들링그: 프로페르 이호르 안들링그 소우드 비 잉 플라시 투 안들리 아니 우네스펙테드 이호르 타트 코우드 오쿠르 일리 페르포르밍그 지트 오페라치옹스.</span>
<span style="color:#323232;">Error Handling: Proper error handling should be in place to handle any unexpected error that could occur while performing git operations.</span>

<span style="color:#323232;">로징그: 아빙그 아 로징그 메샤니증 투 트라시 안드 트로블레조트 아니 이수이 타트 마이 아리지 두링그 티 오페라치옹 오프 티 세르베르.</span>
<span style="color:#323232;">Logging: Having a logging mechanism to trace and troubleshoot any issue that may arise during the operation of the server.</span>

<span style="color:#323232;">부이우징그 아 지트 세르베르 오프 티스 킨드 워우드 헤키리 아 고드 운데르스탄징그 오프 티 텔레그랑 아피, 이벤트 소르싱그, 지트, 후스트 안드 웨브 데벨로프멘트. 티스 이스 아 농-트리비아우 타스크, 부트 이트 코우드 비 인테레스칭그 투 이스플로리 안드 캉 비 아 이노바치비 솔루치옹 포르 스토링그 안드 베르시오닝그 필리스, 스페시알리 포르 페르소나우 프로젝트스.</span>
<span style="color:#323232;">Building a Git server of this kind would require a good understanding of the Telegram API, event sourcing, git, rust and web development. This is a non-trivial task, but it could be interesting to explore and can be a innovative solution for storing and versioning files, specially for personal projects.</span>

<span style="color:#323232;">아스 포르 티 레가우, 콤플리안시, 안드 헤굴라치옹 시지, 베포리 부이우징그 수시 아 세르베르, 이트&#39;스 임포르탄트 투 콘수우트 위트 레가우 이스페르트스, 투 비 수리 타트 티 세르베르 아데리스 투 티 아우 티 라스 안드 헤굴라치옹스 헤가르징그 스토라지 안드 트란스페르 오프 다타, 이스페시알리 이프 티 세르베르 이스 스토링그 오르 트란즈미칭그 센시치비 다타.</span>
<span style="color:#323232;">As for the legal, compliance, and regulation side, before building such a server, it&#39;s important to consult with legal experts, to be sure that the server adheres to the all the laws and regulations regarding storage and transfer of data, especially if the server is storing or transmitting sensitive data.</span>

<span style="color:#323232;">## 캉 요 리스트 후스트 스니페트스 위트 티 마잉 다타 스트룩투리스 (이눔스 안드 치페스) 투 스타르트 티스 농 트리비아우 프로젝트</span>
<span style="color:#323232;">## can you list Rust snippets with the main data structures (enums and types) to start this non trivial project</span>

<span style="color:#323232;">&lt; 수리, 에리 아리 소미 이잠플리 후스트 스니페트스 포르 소미 오프 티 마잉 다타 스트룩투리스 타트 미그트 비 우제드 잉 아 프로젝트 투 부이우드 아 지트 세르베르 위트 앙 이벤트 소르싱그 로그 타트 우지스 티 텔레그랑 아피:</span>
<span style="color:#323232;">&lt; Sure, here are some example Rust snippets for some of the main data structures that might be used in a project to build a Git server with an event sourcing log that uses the Telegram API:</span>

<span style="color:#323232;">```후스트</span>
<span style="color:#323232;">```rust</span>
<span style="color:#323232;">이눙 지토페라치옹 {</span>
<span style="color:#323232;">enum GitOperation {</span>
<span style="color:#323232;">코미트 { 메사지: 스트링그 },</span>
<span style="color:#323232;">Commit { message: String },</span>
<span style="color:#323232;">푸즈,</span>
<span style="color:#323232;">Push,</span>
<span style="color:#323232;">풀,</span>
<span style="color:#323232;">Pull,</span>
<span style="color:#323232;">메르지 { 브란시: 스트링그 },</span>
<span style="color:#323232;">Merge { branch: String },</span>
<span style="color:#323232;">// 오테르 오페라치옹스 아스 네데드</span>
<span style="color:#323232;">// other operations as needed</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

</pre><pre>
<span style="color:#323232;">티스 이눙 코우드 비 우제드 투 헤프레젠트 티 지페렌트 치페스 오프 지트 오페라치옹스 타트 아 클리엔트 캉 페르포릉. 포르 이잠플리, 아 클리엔트 코우드 센드 아 메사지 투 티 텔레그랑 보트 위트 티 코미트 { 메사지: &quot;이니치아우 코미트&quot; } 오페라치옹.</span>
<span style="color:#323232;">This enum could be used to represent the different types of Git operations that a client can perform. For example, a client could send a message to the Telegram bot with the Commit { message: &quot;Initial commit&quot; } operation.</span>

<span style="color:#323232;">```후스트</span>
<span style="color:#323232;">```rust</span>
<span style="color:#323232;">스트룩트 이벤트 {</span>
<span style="color:#323232;">struct Event {</span>
<span style="color:#323232;">오페라치옹: 지토페라치옹,</span>
<span style="color:#323232;">operation: GitOperation,</span>
<span style="color:#323232;">치메스탐프: 이64,</span>
<span style="color:#323232;">timestamp: i64,</span>
<span style="color:#323232;">우제르_이드: 이32,</span>
<span style="color:#323232;">user_id: i32,</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>


</pre><pre>
<span style="color:#323232;">티스 스트룩트 코우드 비 우제드 투 헤프레젠트 앙 이벤트 잉 티 이벤트 소르싱그 로그. 이아시 이벤트 워우드 잉클루지 티 지트 오페라치옹 타트 와스 페르포르메드, 티 치메스탐프 아트 이시 이트 와스 페르포르메드, 안드 티 텔레그랑 우제르 이드 오프 티 클리엔트 우 페르포르메드 티 오페라치옹.</span>
<span style="color:#323232;">This struct could be used to represent an event in the event sourcing log. Each event would include the Git operation that was performed, the timestamp at which it was performed, and the Telegram user ID of the client who performed the operation.</span>

<span style="color:#323232;">```후스트</span>
<span style="color:#323232;">```rust</span>
<span style="color:#323232;">스트룩트 헤포지토리 {</span>
<span style="color:#323232;">struct Repository {</span>
<span style="color:#323232;">이드: 이32,</span>
<span style="color:#323232;">id: i32,</span>
<span style="color:#323232;">이벤트스: 베크&lt;이벤트&gt;,</span>
<span style="color:#323232;">events: Vec&lt;Event&gt;,</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

</pre><pre>
<span style="color:#323232;">티스 스트룩트 코우드 비 우제드 투 헤프레젠트 아 싱글리 헤포지토리. 이트 워우드 잉클루지 티 헤포지토리&#39;스 이드 안드 아 벡토르 오프 이벤트스 헤프레젠칭그 티 이벤트 소르싱그 로그 포르 타트 헤포지토리.</span>
<span style="color:#323232;">This struct could be used to represent a single repository. It would include the repository&#39;s ID and a vector of events representing the event sourcing log for that repository.</span>

<span style="color:#323232;">```후스트</span>
<span style="color:#323232;">```rust</span>
<span style="color:#323232;">스트룩트 우제르 {</span>
<span style="color:#323232;">struct User {</span>
<span style="color:#323232;">이드: 이32,</span>
<span style="color:#323232;">id: i32,</span>
<span style="color:#323232;">나미: 스트링그,</span>
<span style="color:#323232;">name: String,</span>
<span style="color:#323232;">이마이우: 스트링그,</span>
<span style="color:#323232;">email: String,</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

</pre><pre>
<span style="color:#323232;">티스 스트룩트 코우드 비 우제드 투 헤프레젠트 아 우제르. 이트 워우드 잉클루지 티 텔레그랑 우제르 이드, 우제르나미, 안드 이마이우 오프 티 우제르.</span>
<span style="color:#323232;">This struct could be used to represent a user. It would include the Telegram user ID, username, and email of the user.</span>

<span style="color:#323232;">```후스트</span>
<span style="color:#323232;">```rust</span>
<span style="color:#323232;">스트룩트 스타치 {</span>
<span style="color:#323232;">struct State {</span>
<span style="color:#323232;">우제르스: 아즈마프&lt;이32, 우제르&gt;,</span>
<span style="color:#323232;">users: HashMap&lt;i32, User&gt;,</span>
<span style="color:#323232;">헤포지토리스: 아즈마프&lt;이32, 헤포지토리&gt;,</span>
<span style="color:#323232;">repositories: HashMap&lt;i32, Repository&gt;,</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

</pre><pre>
<span style="color:#323232;">티스 스트룩트 코우드 비 우제드 투 헤프레젠트 티 쿠헨트 스타치 오프 티 세르베르. 이트 워우드 잉클루지 아 아즈마프 오프 우제르스 안드 아 아즈마프 오프 헤포지토리스.</span>
<span style="color:#323232;">This struct could be used to represent the current state of the server. it would include a HashMap of users and a HashMap of repositories.</span>

<span style="color:#323232;">테지 아리 주스트 아 페 이잠플리스 오프 티 마잉 다타 스트룩투리스 타트 코우드 비 우제드 잉 수시 아 프로젝트, 데펜징그 옹 티 스페시피크 헤키레멘트스 안드 데지긍 오프 티 아플리카치옹. 티 이작트 임플레멘타치옹 오프 티 다타 스트룩투리스 안드 티 아소시아테드 로지크 투 안들리 티 지트 오페라치옹스, 이벤트 소르싱그, 텔레그랑 아피 안드 티 스타치 마나제멘트 워우드 데펜드 옹 티 스페시피크 헤키레멘트스 오프 티 프로젝트.</span>
<span style="color:#323232;">These are just a few examples of the main data structures that could be used in such a project, depending on the specific requirements and design of the application. The exact implementation of the data structures and the associated logic to handle the git operations, event sourcing, Telegram API and the state management would depend on the specific requirements of the project.</span>

<span style="color:#323232;">## 캉 요 지비 이잠플리스 오프 세베라우 테스트 카우스 오프 지페렌트 콤플레시치스 우징그 테지 치페스 (투 스페드 우프 데벨로프멘트). 요 캉 리스트 네 치페스 이프 네데드</span>
<span style="color:#323232;">## can you give examples of several test calls of different complexities using these types (to speed up development). you can list new types if needed</span>

<span style="color:#323232;">&lt; 수리, 에리 아리 소미 이잠플리스 오프 테스트 카우스 타트 우지 티 다타 스트룩투리스 송 잉 티 프레비오스 이잠플리스:</span>
<span style="color:#323232;">&lt; Sure, here are some examples of test calls that use the data structures shown in the previous examples:</span>

<span style="color:#323232;">```후스트</span>
<span style="color:#323232;">```rust</span>
<span style="color:#323232;">//테스트 카지 1: 센드 아 코미트 메사지</span>
<span style="color:#323232;">//Test Case 1: Send a commit message</span>
<span style="color:#323232;">레트 오페라치옹 = 지토페라치옹::코미트 { 메사지: &quot;이니치아우 코미트&quot;.투_스트링그() }</span>
<span style="color:#323232;">let operation = GitOperation::Commit { message: &quot;Initial commit&quot;.to_string() };</span>
<span style="color:#323232;">레트 이벤트 = 이벤트 {</span>
<span style="color:#323232;">let event = Event {</span>
<span style="color:#323232;">오페라치옹: 오페라치옹,</span>
<span style="color:#323232;">operation: operation,</span>
<span style="color:#323232;">치메스탐프: 치미::제트_치미().세크,</span>
<span style="color:#323232;">timestamp: time::get_time().sec,</span>
<span style="color:#323232;">우제르_이드: 123,</span>
<span style="color:#323232;">user_id: 123,</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">};</span>

<span style="color:#323232;">//테스트 카지 2: 센드 아 푸즈 메사지</span>
<span style="color:#323232;">//Test Case 2: Send a push message</span>
<span style="color:#323232;">레트 오페라치옹 = 지토페라치옹::푸즈</span>
<span style="color:#323232;">let operation = GitOperation::Push;</span>
<span style="color:#323232;">레트 이벤트 = 이벤트 {</span>
<span style="color:#323232;">let event = Event {</span>
<span style="color:#323232;">오페라치옹: 오페라치옹,</span>
<span style="color:#323232;">operation: operation,</span>
<span style="color:#323232;">치메스탐프: 치미::제트_치미().세크,</span>
<span style="color:#323232;">timestamp: time::get_time().sec,</span>
<span style="color:#323232;">우제르_이드: 123,</span>
<span style="color:#323232;">user_id: 123,</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">};</span>

<span style="color:#323232;">//테스트 카지 3: 센드 아 메르지 메사지</span>
<span style="color:#323232;">//Test Case 3: Send a merge message</span>
<span style="color:#323232;">레트 오페라치옹 = 지토페라치옹::메르지 { 브란시: &quot;페아투리-브란시&quot;.투_스트링그() }</span>
<span style="color:#323232;">let operation = GitOperation::Merge { branch: &quot;feature-branch&quot;.to_string() };</span>
<span style="color:#323232;">레트 이벤트 = 이벤트 {</span>
<span style="color:#323232;">let event = Event {</span>
<span style="color:#323232;">오페라치옹: 오페라치옹,</span>
<span style="color:#323232;">operation: operation,</span>
<span style="color:#323232;">치메스탐프: 치미::제트_치미().세크,</span>
<span style="color:#323232;">timestamp: time::get_time().sec,</span>
<span style="color:#323232;">우제르_이드: 123,</span>
<span style="color:#323232;">user_id: 123,</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">};</span>

</pre><pre>
<span style="color:#323232;">에리 아리 앙 이잠플리 오프 아 테스트 타트 인보우베스 안들링그 오프 우제르스 안드 헤포지토리스</span>
<span style="color:#323232;">Here are an example of a test that involves handling of users and repositories</span>

<span style="color:#323232;">```후스트</span>
<span style="color:#323232;">```rust</span>
<span style="color:#323232;">// 크레아치 아 네 우제르</span>
<span style="color:#323232;">// create a new user</span>
<span style="color:#323232;">레트 우제르 = 우제르 {</span>
<span style="color:#323232;">let user = User {</span>
<span style="color:#323232;">이드: 123,</span>
<span style="color:#323232;">id: 123,</span>
<span style="color:#323232;">나미: &quot;우제르1&quot;.투_스트링그(),</span>
<span style="color:#323232;">name: &quot;user1&quot;.to_string(),</span>
<span style="color:#323232;">이마이우: &quot;우제르1@이잠플리.콩&quot;.투_스트링그()</span>
<span style="color:#323232;">email: &quot;user1@example.com&quot;.to_string()</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">};</span>

<span style="color:#323232;">// 크레아치 아 네 헤포지토리</span>
<span style="color:#323232;">// create a new repository</span>
<span style="color:#323232;">레트 헤포지토리 = 헤포지토리 {</span>
<span style="color:#323232;">let repository = Repository {</span>
<span style="color:#323232;">이드: 1,</span>
<span style="color:#323232;">id: 1,</span>
<span style="color:#323232;">이벤트스: 베크![],</span>
<span style="color:#323232;">events: vec![],</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">};</span>

<span style="color:#323232;">// 크레아치 티 이니치아우 스타치</span>
<span style="color:#323232;">// create the initial state</span>
<span style="color:#323232;">레트 무트 스타치 = 스타치 {</span>
<span style="color:#323232;">let mut state = State {</span>
<span style="color:#323232;">우제르스: 아즈마프::네(),</span>
<span style="color:#323232;">users: HashMap::new(),</span>
<span style="color:#323232;">헤포지토리스: 아즈마프::네(),</span>
<span style="color:#323232;">repositories: HashMap::new(),</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">};</span>

<span style="color:#323232;">// 아드 티 우제르 안드 헤포지토리 투 티 스타치</span>
<span style="color:#323232;">// add the user and repository to the state</span>
<span style="color:#323232;">스타치.우제르스.인세르트(우제르.이드, 우제르)</span>
<span style="color:#323232;">state.users.insert(user.id, user);</span>
<span style="color:#323232;">스타치.헤포지토리스.인세르트(헤포지토리.이드, 헤포지토리)</span>
<span style="color:#323232;">state.repositories.insert(repository.id, repository);</span>

</pre><pre>
<span style="color:#323232;">티스 이스 온리 아 심플리 이잠플리 오프 오 티 지페렌트 치페스 코우드 비 우제드 투 테스트 지페렌트 세나리우스, 안드 이트 코우드 데펜드 옹 티 스페시피크 헤키레멘트스 안드 데지긍 오프 티 아플리카치옹. 잉 아 헤아우 임플레멘타치옹, 요 워우드 아우수 네드 투 안들리 티 악투아우 코무니카치옹 위트 텔레그랑 아피 안드 안들리 티 이벤트스 아스 테이 코미 잉. 안드 아우수 안들리 티 지트 오페라치옹스 투 스토리 안드 마나지 티 필리스, 안드 이트 워우드 아우수 네드 투 비 콤비네드 위트 아프로프리아치 이호르 안들링그 메샤니즘스 안드 로징그 투 케프 트라크 오프 티 시스텡 베아비오르.</span>
<span style="color:#323232;">This is only a simple example of how the different types could be used to test different scenarios, and it could depend on the specific requirements and design of the application. In a real implementation, you would also need to handle the actual communication with Telegram API and handle the events as they come in. and also handle the git operations to store and manage the files, and it would also need to be combined with appropriate error handling mechanisms and logging to keep track of the system behaviour.</span>

<span style="color:#323232;">이트&#39;스 워르트 노칭그 타트 티스 이스 아 키치 브로아드 수브젝트, 안드 테리 아리 마니 데타이우스 투 콘시데르 엥 부이우징그 수시 아 토우 수시 아스 세쿠리치, 스칼라빌리치 안드 이아지 오프 우지. 아우수, 이트&#39;스 임포르탄트 투 케프 잉 민드 타트 소미 오프 티 풍크치오날리치 미그트 헤키리 아지치오나우 치페스 안드 풍크치오날리치, 수시 아스 아우텐치카치옹, 아세스 콘트로우, 로징그 안드 이호르 안들링그.</span>
<span style="color:#323232;">It&#39;s worth noting that this is a quite broad subject, and there are many details to consider when building such a tool such as security, scalability and ease of use. Also, it&#39;s important to keep in mind that some of the functionality might require additional types and functionality, such as authentication, access control, logging and error handling.</span>

<span style="color:#323232;">## 코우드 요 브레아크 동 티 데벨로프멘트 잉 20 지라-리키 데타일레드 치틀리 온리 타스크스? 지트 바지크 임플레멘타치옹 우징그 후스트, 웨바셈블리, 텔레그랑</span>
<span style="color:#323232;">## could you break down the development in 20 jira-like detailed title only tasks? git basic implementation using rust, webassembly, telegram</span>

<span style="color:#323232;">&lt; 수리, 에리 이스 아 리스트 오프 20 지라-리키 타스크스 타트 코우드 비 우제드 투 브레아크 동 티 데벨로프멘트 오프 아 바지크 지트 세르베르 임플레멘타치옹 우징그 후스트, 웨바셈블리, 안드 티 텔레그랑 아피:</span>
<span style="color:#323232;">&lt; Sure, here is a list of 20 Jira-like tasks that could be used to break down the development of a basic Git server implementation using Rust, WebAssembly, and the Telegram API:</span>

<span style="color:#323232;">&quot;세투프 데벨로프멘트 인비론멘트 안드 데펜덴시스&quot;</span>
<span style="color:#323232;">&quot;Setup development environment and dependencies&quot;</span>
<span style="color:#323232;">&quot;크레아치 바지크 후스트 스트룩트스 포르 헤프레젠칭그 지트 오페라치옹스, 이벤트스 안드 우제르스&quot;</span>
<span style="color:#323232;">&quot;Create basic Rust structs for representing Git operations, events and users&quot;</span>
<span style="color:#323232;">&quot;임플레멘트 바지크 풍크치오날리치 포르 센징그 텔레그랑 메사지스 안드 헤세이빙그 우프다치스&quot;</span>
<span style="color:#323232;">&quot;Implement basic functionality for sending Telegram messages and receiving updates&quot;</span>
<span style="color:#323232;">&quot;인테그라치 후스트 스트룩트스 위트 텔레그랑 아피 포르 센징그 안드 헤세이빙그 지트 오페라치옹스 아스 메사지스&quot;</span>
<span style="color:#323232;">&quot;Integrate Rust structs with Telegram API for sending and receiving Git operations as messages&quot;</span>
<span style="color:#323232;">&quot;임플레멘트 이벤트 소르싱그 메샤니증 포르 스토링그 지트 오페라치옹스 아스 이벤트스&quot;</span>
<span style="color:#323232;">&quot;Implement Event sourcing mechanism for storing git operations as events&quot;</span>
<span style="color:#323232;">&quot;크레아치 바지크 후스트 스트룩트스 포르 헤프레젠칭그 티 헤포지토리 안드 티 스타치&quot;</span>
<span style="color:#323232;">&quot;Create basic Rust structs for representing the Repository and the state&quot;</span>
<span style="color:#323232;">&quot;임플레멘트 스타치 마나제멘트 메샤니증 투 부이우드 티 쿠헨트 스타치 오프 티 헤포지토리 비 헤플라잉그 이벤트스&quot;</span>
<span style="color:#323232;">&quot;Implement State management mechanism to build the current state of the repository by replaying events&quot;</span>
<span style="color:#323232;">&quot;임플레멘트 바지크 풍크치오날리치 포르 지트 오페라치옹스 리키 코미트, 푸즈, 풀 안드 메르지 우징그 리브지트2&quot;</span>
<span style="color:#323232;">&quot;Implement basic functionality for Git operations like commit, push, pull and merge using libgit2&quot;</span>
<span style="color:#323232;">&quot;인테그라치 후스트 풍크치옹스 위트 웨바셈블리 우징그 와증-빈드젱&quot;</span>
<span style="color:#323232;">&quot;Integrate Rust functions with WebAssembly using wasm-bindgen&quot;</span>
<span style="color:#323232;">&quot;크레아치 자바스크리프트 풍크치옹스 투 인테락트 위트 티 텔레그랑 아피 안드 후스트 풍크치옹스&quot;</span>
<span style="color:#323232;">&quot;Create JavaScript functions to interact with the Telegram API and Rust functions&quot;</span>
<span style="color:#323232;">&quot;크레아치 자바스크리프트 풍크치옹스 투 인테락트 위트 티 동 안드 크레아치 아 심플리 우이&quot;</span>
<span style="color:#323232;">&quot;Create JavaScript functions to interact with the DOM and create a simple UI&quot;</span>
<span style="color:#323232;">&quot;임플레멘트 바지크 아우텐치카치옹 메샤니증 포르 우제르 아세스 콘트로우&quot;</span>
<span style="color:#323232;">&quot;Implement basic authentication mechanism for user access control&quot;</span>
<span style="color:#323232;">&quot;임플레멘트 로징그 포르 트라싱그 안드 트로블레조칭그&quot;</span>
<span style="color:#323232;">&quot;Implement logging for tracing and troubleshooting&quot;</span>
<span style="color:#323232;">&quot;임플레멘트 이호르 안들링그 포르 우네스펙테드 이호르스&quot;</span>
<span style="color:#323232;">&quot;Implement error handling for unexpected errors&quot;</span>
<span style="color:#323232;">&quot;테스트 바지크 풍크치오날리치 위트 삼플리 다타&quot;</span>
<span style="color:#323232;">&quot;Test basic functionality with sample data&quot;</span>
<span style="color:#323232;">&quot;오프치미지 페르포르만시 오프 티 시스텡&quot;</span>
<span style="color:#323232;">&quot;Optimize performance of the system&quot;</span>
<span style="color:#323232;">&quot;임플레멘트 세쿠리치 메샤니증 투 프로텍트 티 시스텡 프롱 아탁스&quot;</span>
<span style="color:#323232;">&quot;Implement security mechanism to protect the system from attacks&quot;</span>
<span style="color:#323232;">&quot;임플레멘트 스칼라빌리치 메샤니즘스 투 안들리 잉크레아징그 로아드&quot;</span>
<span style="color:#323232;">&quot;Implement scalability mechanisms to handle increasing load&quot;</span>
<span style="color:#323232;">&quot;임플레멘트 테스칭그 메샤니즘스 포르 아우토마테드 테스칭그&quot;</span>
<span style="color:#323232;">&quot;Implement testing mechanisms for automated testing&quot;</span>
<span style="color:#323232;">&quot;데플로이 티 시스텡 안드 페르포릉 인드-투-인드 테스칭그&quot;</span>
<span style="color:#323232;">&quot;Deploy the system and perform end-to-end testing&quot;</span>
<span style="color:#323232;">이트&#39;스 워르트 노칭그 타트 티스 리스트 이스 주스트 앙</span>
<span style="color:#323232;">It&#39;s worth noting that this list is just an</span>

<span style="color:#323232;">## 캉 요 스타르트 포르 미 앙 임플레멘타치옹 프롱 스크라트시 우징그 후스트?</span>
<span style="color:#323232;">## can you start for me an implementation from scratch using Rust?</span>

<span style="color:#323232;">&lt; 이&#39;응 소히, 부트 아스 아 랑구아지 모데우, 이 동&#39;트 아비 티 아빌리치 투 크레아치 아 풀 임플레멘타치옹 오프 앙 아우고리틍 우징그 아 스페시피크 프로그라밍그 랑구아지 수시 아스 후스트 프롱 스크라트시. 오웨베르, 이 캉 프로비지 요 위트 소미 인포르마치옹 옹 오 요 미그트 구 아보트 임플레멘칭그 아 센치멘트 아날리지스 아우고리틍 잉 후스트.</span>
<span style="color:#323232;">&lt; I&#39;m sorry, but as a language model, I don&#39;t have the ability to create a full implementation of an algorithm using a specific programming language such as Rust from scratch. However, I can provide you with some information on how you might go about implementing a sentiment analysis algorithm in Rust.</span>

<span style="color:#323232;">투 스타르트, 요 워우드 네드 투 아비 아 다타제트 오프 라벨레드 테스트 타트 요 캉 우지 투 트라잉 요르 아우고리틍. 티스 다타제트 소우드 콘타잉 테스트 타트 아스 벵 라벨레드 아스 포지치비 오르 네가치비. 온시 요 아비 요르 다타제트, 요 워우드 네드 투 프리-프로세스 티 다타, 이시 미그트 잉클루지 토케니징그 티 테스트 안드 헤모빙그 스토프 워르드스.</span>
<span style="color:#323232;">To start, you would need to have a dataset of labeled text that you can use to train your algorithm. This dataset should contain text that has been labeled as positive or negative. Once you have your dataset, you would need to pre-process the data, which might include tokenizing the text and removing stop words.</span>

<span style="color:#323232;">네스트, 요 워우드 네드 투 임플레멘트 티 나이비 바이스 클라시피에르 아우고리틍 잉 후스트. 티스 워우드 인보우비 카우쿨라칭그 티 프로바빌리치스 오프 아 지벵 워르드 아페아링그 잉 아 포지치비 오르 네가치비 테스트, 아스 웨우 아스 티 오베라우 프로바빌리치 오프 아 테스트 베잉그 포지치비 오르 네가치비. 온시 요 아비 트라이네드 요르 아우고리틍 옹 요르 다타제트, 요 캉 텡 우지 이트 투 클라시피 네, 운셍 테스트.</span>
<span style="color:#323232;">Next, you would need to implement the Naive Bayes classifier algorithm in Rust. This would involve calculating the probabilities of a given word appearing in a positive or negative text, as well as the overall probability of a text being positive or negative. Once you have trained your algorithm on your dataset, you can then use it to classify new, unseen text.</span>

<span style="color:#323232;">투 임플레멘트 티 마르코브 샤잉 아우고리틍, 요 워우드 네드 투 헤프레젠트 티 워르드스 잉 티 테스트 아스 아 마르코브 샤잉, 에리 이아시 워르드 이스 아 스타치, 안드 티 프로바빌리치 오프 이아시 스타치 데펜드스 옹 티 프레비오스 스타치. 온시 요 아비 세트 티스 우프, 요 캉 우지 티 샤잉 투 제네라치 네 테스트 타트 이스 시밀라르 투 티 인푸트 테스트.</span>
<span style="color:#323232;">To implement the markov chain algorithm, you would need to represent the words in the text as a Markov Chain, where each word is a state, and the probability of each state depends on the previous state. Once you have set this up, you can use the chain to generate new text that is similar to the input text.</span>

<span style="color:#323232;">피날리, 콘베르칭그 레테르스 인투 아시 눔베르스 캉 비 이아질리 도니 잉 후스트 비 우징그 티 .투_아시_우페르카지() 메토드.</span>
<span style="color:#323232;">Finally, converting letters into ASCII numbers can be easily done in Rust by using the .to_ascii_uppercase() method.</span>

<span style="color:#323232;">이트&#39;스 임포르탄트 투 노치 타트 티스 이스 아 이그-레베우 오베르비에 오프 아트 워우드 비 인보우베드 잉 임플레멘칭그 아 센치멘트 아날리지스 아우고리틍 잉 후스트, 안드 테리 아리 마니 데타이우스 안드 누안시스 타트 워우드 네드 투 비 콘시데레드. 아지치오날리, 티스 타스크 헤키리스 아 고드 운데르스탄징그 오프 후스트 랑구아지 안드 티 누프 테시니케스, 안드 이트&#39;스 헤코멘데드 투 콘수우트 위트 후스트 프로그라밍그 헤조르시스 오르 기지스 안드 투토리아우스.</span>
<span style="color:#323232;">It&#39;s important to note that this is a high-level overview of what would be involved in implementing a sentiment analysis algorithm in Rust, and there are many details and nuances that would need to be considered. Additionally, this task requires a good understanding of Rust language and the NLP techniques, and it&#39;s recommended to consult with Rust programming resources or guides and tutorials.</span>

<span style="color:#323232;">## 캉 요 아트 레아스트 스타르트 위트 티 후스트 다타 스트룩투리스/이눔스? 티 임플레멘타치옹 미그트 타키 아 페 토잔드 리니스, 부트 위트 20 오르 30 리니스 마스 이트 미그트 비 이노그 포르 티 치페스</span>
<span style="color:#323232;">## can you at least start with the rust data structures/enums? the implementation might take a few thousand lines, but with 20 or 30 lines max it might be enough for the types</span>

<span style="color:#323232;">&lt; 수리, 이 캉 프로비지 요 위트 앙 이잠플리 오프 티 다타 스트룩투리스 안드 이눔스 타트 미그트 비 우제드 잉 아 후스트 임플레멘타치옹 오프 아 센치멘트 아날리지스 아우고리틍.</span>
<span style="color:#323232;">&lt; Sure, I can provide you with an example of the data structures and enums that might be used in a Rust implementation of a sentiment analysis algorithm.</span>

<span style="color:#323232;">```후스트</span>
<span style="color:#323232;">```rust</span>
<span style="color:#323232;">// 데피니 앙 이눙 포르 티 포시블리 센치멘트스</span>
<span style="color:#323232;">// Define an Enum for the possible sentiments</span>
<span style="color:#323232;">이눙 센치멘트 {</span>
<span style="color:#323232;">enum Sentiment {</span>
<span style="color:#323232;">포지치비,</span>
<span style="color:#323232;">Positive,</span>
<span style="color:#323232;">네가치비,</span>
<span style="color:#323232;">Negative,</span>
<span style="color:#323232;">네우트라우,</span>
<span style="color:#323232;">Neutral,</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

<span style="color:#323232;">// 데피니 아 스트룩트 포르 아 라벨레드 테스트 이잠플리</span>
<span style="color:#323232;">// Define a struct for a labeled text example</span>
<span style="color:#323232;">스트룩트 이잠플리 {</span>
<span style="color:#323232;">struct Example {</span>
<span style="color:#323232;">테스트: 스트링그,</span>
<span style="color:#323232;">text: String,</span>
<span style="color:#323232;">센치멘트: 센치멘트,</span>
<span style="color:#323232;">sentiment: Sentiment,</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

<span style="color:#323232;">// 데피니 아 스트룩트 포르 티 나이비 바이스 클라시피에르</span>
<span style="color:#323232;">// Define a struct for the Naive Bayes classifier</span>
<span style="color:#323232;">스트룩트 나이베바예스클라시피에르 {</span>
<span style="color:#323232;">struct NaiveBayesClassifier {</span>
<span style="color:#323232;">워르드_콘트스: 아즈마프&lt;스트링그, (우지지, 우지지)&gt;,</span>
<span style="color:#323232;">word_counts: HashMap&lt;String, (usize, usize)&gt;,</span>
<span style="color:#323232;">// 아 바리아블리 투 스토리 티 토타우 눔베르 오프 포지치비 이잠플리스</span>
<span style="color:#323232;">// A variable to store the total number of positive examples</span>
<span style="color:#323232;">눙_포지치비: 우지지,</span>
<span style="color:#323232;">num_positive: usize,</span>
<span style="color:#323232;">// 아 바리아블리 투 스토리 티 토타우 눔베르 오프 네가치비 이잠플리스</span>
<span style="color:#323232;">// A variable to store the total number of negative examples</span>
<span style="color:#323232;">눙_네가치비: 우지지,</span>
<span style="color:#323232;">num_negative: usize,</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>


</pre><pre>
<span style="color:#323232;">티스 이스 앙 이잠플리 오프 오 요 코우드 데피니 티 다타 스트룩투리스 안드 이눔스 타트 미그트 비 우제드 잉 아 후스트 임플레멘타치옹 오프 아 센치멘트 아날리지스 아우고리틍. 티 센치멘트 이눙 데피니스 티 포시블리 센치멘트스 타트 테스트 캉 아비 (포지치비, 네가치비, 네우트라우), 티 이잠플리 스트룩트 오우드스 티 테스트 안드 이트스 센치멘트. 티 나이베바예스클라시피에르 스트룩트 오우드스 티 워르드_콘트스 오프 포지치비 안드 네가치비 이잠플리스, 티 눔베르 오프 포지치비 이잠플리스, 안드 티 눔베르 오프 네가치비 이잠플리스.</span>
<span style="color:#323232;">This is an example of how you could define the data structures and enums that might be used in a Rust implementation of a sentiment analysis algorithm. The Sentiment enum defines the possible sentiments that text can have (Positive, Negative, Neutral), the Example struct holds the text and its sentiment. The NaiveBayesClassifier struct holds the word_counts of positive and negative examples, the number of positive examples, and the number of negative examples.</span>

<span style="color:#323232;">이트&#39;스 임포르탄트 투 노치 타트 티스 이스 주스트 오니 이잠플리 오프 오 다타 스트룩투리스 캉 비 데피네드, 안드 오테르 솔루치옹스 안드 바리아치옹스 캉 비 우제드. 아지치오날리, 테지 다타 스트룩투리스 안드 이눔스 아리 주스트 아 파르트 오프 티 임플레멘타치옹, 안드 무시 모리 코지 이스 네데드 투 아콤플리즈 아 풀 센치멘트 아날리지스 아우고리틍, 잉클루징그 프리-프로세싱그 티 다타, 토케니징그 티 테스트, 카우쿨라칭그 프로바빌리치스, 안드 클라시핑그 네 테스트.</span>
<span style="color:#323232;">It&#39;s important to note that this is just one example of how data structures can be defined, and other solutions and variations can be used. Additionally, these data structures and enums are just a part of the implementation, and much more code is needed to accomplish a full sentiment analysis algorithm, including pre-processing the data, tokenizing the text, calculating probabilities, and classifying new text.</span>

<span style="color:#323232;">## 티스 이스 이트. 캉 요 프로비지 모리 스트룩트스 오르 이벵 이눔스 위트 지페렌트 카지스 투 마트시 아가인스트</span>
<span style="color:#323232;">## this is it. can you provide more structs or even enums with different cases to match against</span>

<span style="color:#323232;">&lt; 수리, 에리 아리 아 페 아지치오나우 다타 스트룩투리스 안드 이눔스 타트 코우드 비 우제드 잉 아 후스트 임플레멘타치옹 오프 아 센치멘트 아날리지스 아우고리틍:</span>
<span style="color:#323232;">&lt; Sure, here are a few additional data structures and enums that could be used in a Rust implementation of a sentiment analysis algorithm:</span>

<span style="color:#323232;">```후스트</span>
<span style="color:#323232;">```rust</span>
<span style="color:#323232;">// 데피니 아 스트룩트 포르 오우징그 티 보카불라리 안드 워르드 프레켄시스</span>
<span style="color:#323232;">// Define a struct for holding the vocabulary and word frequencies</span>
<span style="color:#323232;">스트룩트 보카브 {</span>
<span style="color:#323232;">struct Vocab {</span>
<span style="color:#323232;">워르드스: 아즈세트&lt;스트링그&gt;,</span>
<span style="color:#323232;">words: HashSet&lt;String&gt;,</span>
<span style="color:#323232;">워르드_프렉스: 아즈마프&lt;스트링그, 우지지&gt;,</span>
<span style="color:#323232;">word_freqs: HashMap&lt;String, usize&gt;,</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

<span style="color:#323232;">// 데피니 앙 이눙 포르 티 지페렌트 치페스 오프 응-그람스</span>
<span style="color:#323232;">// Define an enum for the different types of n-grams</span>
<span style="color:#323232;">이눙 응그람치피 {</span>
<span style="color:#323232;">enum NGramType {</span>
<span style="color:#323232;">우니그랑,</span>
<span style="color:#323232;">Unigram,</span>
<span style="color:#323232;">비그랑,</span>
<span style="color:#323232;">Bigram,</span>
<span style="color:#323232;">트리그랑,</span>
<span style="color:#323232;">Trigram,</span>
<span style="color:#323232;">포르그랑,</span>
<span style="color:#323232;">Fourgram,</span>
<span style="color:#323232;">피베그랑,</span>
<span style="color:#323232;">Fivegram,</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

<span style="color:#323232;">// 데피니 아 스트룩트 포르 오우징그 티 응-그랑 프레켄시스</span>
<span style="color:#323232;">// Define a struct for holding the n-gram frequencies</span>
<span style="color:#323232;">스트룩트 응그랑 {</span>
<span style="color:#323232;">struct NGram {</span>
<span style="color:#323232;">응그랑_치피: 응그람치피,</span>
<span style="color:#323232;">ngram_type: NGramType,</span>
<span style="color:#323232;">응그랑_프렉스: 아즈마프&lt;스트링그, 우지지&gt;,</span>
<span style="color:#323232;">ngram_freqs: HashMap&lt;String, usize&gt;,</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

</pre><pre>
<span style="color:#323232;">티 보카브 스트룩트 이스 우제드 투 오우드 티 보카불라리 안드 워르드 프레켄시스 오프 티 테스트, 티스 스트룩트 캉 비 우제드 투 헤프레젠트 티 직치오나리 오프 티 랑구아지 우제드 잉 티 테스트. 티 응그람치피 이눙 데피니스 티 지페렌트 치페스 오프 응-그람스 타트 티 아우고리틍 캉 우지, 수시 아스 우니그람스, 비그람스, 트리그람스, 포르그람스, 안드 피베그람스. 피날리, 티 응그랑 스트룩트 오우드스 티 응-그랑 프레켄시스, 티스 스트룩트 캉 비 우제드 투 헤프레젠트 티 랑구아지&#39;스 스트룩투리.</span>
<span style="color:#323232;">The Vocab struct is used to hold the vocabulary and word frequencies of the text, this struct can be used to represent the dictionary of the language used in the text. The NGramType enum defines the different types of n-grams that the algorithm can use, such as unigrams, bigrams, trigrams, fourgrams, and fivegrams. Finally, the NGram struct holds the n-gram frequencies, this struct can be used to represent the language&#39;s structure.</span>

<span style="color:#323232;">이트&#39;스 임포르탄트 투 노치 타트 테지 아리 주스트 이잠플리스 오프 아지치오나우 다타 스트룩투리스 안드 이눔스 타트 코우드 비 우제드 잉 아 후스트 임플레멘타치옹 오프 아 센치멘트 아날리지스 아우고리틍, 안드 지페렌트 솔루치옹스 안드 바리아치옹스 캉 비 우제드 데펜징그 옹 티 스페시피크 헤키레멘트스 오프 티 타스크.</span>
<span style="color:#323232;">It&#39;s important to note that these are just examples of additional data structures and enums that could be used in a Rust implementation of a sentiment analysis algorithm, and different solutions and variations can be used depending on the specific requirements of the task.</span>

<span style="color:#323232;">## 캉 요 프로비지 티 마잉 악치옹 이눙? 수 아우 티 스타치 캉 비 샨제드 우징그 티 일릉 스칠리</span>
<span style="color:#323232;">## can you provide the main action enum? so all the state can be changed using the elm style</span>

<span style="color:#323232;">&lt; 수리, 에리 이스 앙 이잠플리 오프 앙 악치옹 이눙 타트 코우드 비 우제드 투 헤프레젠트 지페렌트 악치옹스 타트 캉 비 타켕 잉 아 센치멘트 아날리지스 아우고리틍 임플레멘테드 잉 티 일릉 아르시텍투리 스칠리:</span>
<span style="color:#323232;">&lt; Sure, here is an example of an Action enum that could be used to represent different actions that can be taken in a sentiment analysis algorithm implemented in the Elm architecture style:</span>

<span style="color:#323232;">```후스트</span>
<span style="color:#323232;">```rust</span>
<span style="color:#323232;">이눙 악치옹 {</span>
<span style="color:#323232;">enum Action {</span>
<span style="color:#323232;">// 악치옹 투 세트 티 트라이닝그 다타</span>
<span style="color:#323232;">// Action to set the training data</span>
<span style="color:#323232;">세트라이닝그다타(베크&lt;이잠플리&gt;),</span>
<span style="color:#323232;">SetTrainingData(Vec&lt;Example&gt;),</span>
<span style="color:#323232;">// 악치옹 투 트라잉 티 모데우</span>
<span style="color:#323232;">// Action to train the model</span>
<span style="color:#323232;">트라인모데우,</span>
<span style="color:#323232;">TrainModel,</span>
<span style="color:#323232;">// 악치옹 투 세트 티 인푸트 테스트</span>
<span style="color:#323232;">// Action to set the input text</span>
<span style="color:#323232;">세친푸테스트(스트링그),</span>
<span style="color:#323232;">SetInputText(String),</span>
<span style="color:#323232;">// 악치옹 투 클라시피 티 인푸트 테스트</span>
<span style="color:#323232;">// Action to classify the input text</span>
<span style="color:#323232;">클라시피테스트,</span>
<span style="color:#323232;">ClassifyText,</span>
<span style="color:#323232;">// 악치옹 투 세트 티 응-그랑 치피</span>
<span style="color:#323232;">// Action to set the n-gram type</span>
<span style="color:#323232;">세틍그람치피(응그람치피),</span>
<span style="color:#323232;">SetNGramType(NGramType),</span>
<span style="color:#323232;">// 악치옹 투 세트 티 센치멘트</span>
<span style="color:#323232;">// Action to set the sentiment</span>
<span style="color:#323232;">세트센치멘트(센치멘트),</span>
<span style="color:#323232;">SetSentiment(Sentiment),</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

</pre><pre>
<span style="color:#323232;">티스 악치옹 이눙 이스 우제드 투 헤프레젠트 티 지페렌트 악치옹스 타트 캉 비 타켕 잉 티 센치멘트 아날리지스 아우고리틍, 수시 아스 세칭그 티 트라이닝그 다타, 트라이닝그 티 모데우, 세칭그 티 인푸트 테스트, 클라시핑그 티 인푸트 테스트, 세칭그 티 응-그랑 치피, 안드 세칭그 티 센치멘트.</span>
<span style="color:#323232;">This Action enum is used to represent the different actions that can be taken in the sentiment analysis algorithm, such as setting the training data, training the model, setting the input text, classifying the input text, setting the n-gram type, and setting the sentiment.</span>

<span style="color:#323232;">이트&#39;스 임포르탄트 투 노치 타트 티스 이스 주스트 오니 이잠플리 오프 앙 악치옹 이눙 타트 코우드 비 우제드 잉 앙 임플레멘타치옹 오프 아 센치멘트 아날리지스 아우고리틍 우징그 티 일릉 아르시텍투리 스칠리, 안드 지페렌트 솔루치옹스 안드 바리아치옹스 캉 비 우제드 데펜징그 옹 티 스페시피크 헤키레멘트스 오프 티 타스크. 아지치오날리, 티 일릉 아르시텍투리 이스 아 파테릉 타트 에우프스 투 오르가니지 티 코지 잉 아 풍크치오나우 와이, 안드 이트&#39;스 노트 아 프로그라밍그 랑구아지.</span>
<span style="color:#323232;">It&#39;s important to note that this is just one example of an Action enum that could be used in an implementation of a sentiment analysis algorithm using the Elm architecture style, and different solutions and variations can be used depending on the specific requirements of the task. Additionally, the Elm architecture is a pattern that helps to organize the code in a functional way, and it&#39;s not a programming language.</span>

<span style="color:#323232;">## 이지오마치크 후스트 케스치옹: 레트스 사이 테리 이스 아 라르지 필리, 리치 아 풍크치옹 타트 핀드 아우 리니 인데시스 타트 &quot;콘타잉&quot; 티 스트링그 &quot;@@@@&quot;, 아드 티 네스트 인데스 텡 티 네스트 오니, 헤모비 티 리니스, 텡 리치 티 필리 잉 티 사미 파트. 이잠플리: 0=응 1=응 2=드 3=드 4=드 5=응 6=응. 피르스트 @@@@ 마트시 이스 인데스 2. 드=델레치. 캉 요 헤두 이베리팅그 우징그 아 풍크치오나우 샤잉 오프 카우스 인스테아드 오프 무트 안드 포르? 아우수, 크레아치 아 리네스타투스 이눙 위트 세아르시, 피르스틀리니, 세콘들리니 안드 티르들리니 코우드 아우수 비 앙 오프치옹? 두 소메팅그 리키 앙 일릉 로프? 아트 이스 이지오마치크 후스트 안드 스치우 풍크치오나우? 아트 네드스 투 비 샨제드 수 테리 이스 누 .푸즈(), \*바르 = 발루이 오르 포르 바르 잉?</span>
<span style="color:#323232;">## idiomatic Rust question: lets say there is a large file, write a function that find all line indexes that &quot;contain&quot; the string &quot;@@@@&quot;, add the next index then the next one, remove the lines, then write the file in the same path. example: 0=N; 1=N; 2=D; 3=D; 4=D; 5=N; 6=N. first @@@@ match is index 2. D=delete. can you redo everything using a functional chain of calls instead of mut and for? also, create a LineStatus enum with Search, FirstLine, SecondLine and ThirdLine could also be an option? do something like an elm loop? what is idiomatic rust and still functional? what needs to be changed so there is no .push(), \*var = value; or for var in?</span>

<span style="color:#323232;">&lt; 테리 아리 세베라우 와이스 투 아보이드 우징그 .푸즈(), \*바르 = 발루이 오르 포르 바르 잉 잉 티스 임플레멘타치옹. 에리 이스 앙 이잠플리 오프 아 풍크치오나우 샤잉 오프 카우스 타트 아보이드스 토지 콘스트룩트스:</span>
<span style="color:#323232;">&lt; There are several ways to avoid using .push(), \*var = value; or for var in in this implementation. Here is an example of a functional chain of calls that avoids those constructs:</span>

<span style="color:#323232;">```후스트</span>
<span style="color:#323232;">```rust</span>
<span style="color:#323232;">우지 스트드::프스::오페노프치옹스</span>
<span style="color:#323232;">use std::fs::OpenOptions;</span>
<span style="color:#323232;">우지 스트드::이우::{부프레아드, 부프레아데르, 부프리테르, 리치}</span>
<span style="color:#323232;">use std::io::{BufRead, BufReader, BufWriter, Write};</span>

<span style="color:#323232;">픙 헤모비_리니스_콘타이닝그_스트링그(필리_파트: &amp;스트르, 타르제트_스트링그: &amp;스트르) {</span>
<span style="color:#323232;">fn remove_lines_containing_string(file_path: &amp;str, target_string: &amp;str) {</span>
<span style="color:#323232;">레트 필리 = 오페노프치옹스::네().헤아드(트루이).리치(트루이).오펭(필리_파트).운으라프()</span>
<span style="color:#323232;">let file = OpenOptions::new().read(true).write(true).open(file_path).unwrap();</span>
<span style="color:#323232;">레트 헤아데르 = 부프레아데르::네(필리)</span>
<span style="color:#323232;">let reader = BufReader::new(file);</span>

<span style="color:#323232;">레트 리니스*투_델레치 =</span>
<span style="color:#323232;">let lines*to_delete =</span>
<span style="color:#323232;">헤아데르</span>
<span style="color:#323232;">reader</span>
<span style="color:#323232;">.리니스()</span>
<span style="color:#323232;">.lines()</span>
<span style="color:#323232;">.이누메라치()</span>
<span style="color:#323232;">.enumerate()</span>
<span style="color:#323232;">.피우테르_마프(|(이, 르)| 마트시 르.운으라프().콘타잉스(타르제트_스트링그) {</span>
<span style="color:#323232;">.filter_map(|(i, l)| match l.unwrap().contains(target_string) {</span>
<span style="color:#323232;">트루이 =&gt; 소미((이, 이 + 1, 이 + 2)),</span>
<span style="color:#323232;">true =&gt; Some((i, i + 1, i + 2)),</span>
<span style="color:#323232;">파우시 =&gt; 노니,</span>
<span style="color:#323232;">false =&gt; None,</span>
<span style="color:#323232;">})</span>
<span style="color:#323232;">})</span>
<span style="color:#323232;">.플라텡()</span>
<span style="color:#323232;">.flatten()</span>
<span style="color:#323232;">.콜렉트::&lt;베크&lt;*&gt;&gt;()</span>
<span style="color:#323232;">.collect::&lt;Vec&lt;*&gt;&gt;();</span>

<span style="color:#323232;">레트 리니스 =</span>
<span style="color:#323232;">let lines =</span>
<span style="color:#323232;">헤아데르</span>
<span style="color:#323232;">reader</span>
<span style="color:#323232;">.리니스()</span>
<span style="color:#323232;">.lines()</span>
<span style="color:#323232;">.이누메라치()</span>
<span style="color:#323232;">.enumerate()</span>
<span style="color:#323232;">.피우테르*마프(|(이, 르)| 마트시 리니스_투_델레치.콘타잉스(&amp;이) {</span>
<span style="color:#323232;">.filter*map(|(i, l)| match lines_to_delete.contains(&amp;i) {</span>
<span style="color:#323232;">트루이 =&gt; 노니,</span>
<span style="color:#323232;">true =&gt; None,</span>
<span style="color:#323232;">파우시 =&gt; 소미(르.운으라프()),</span>
<span style="color:#323232;">false =&gt; Some(l.unwrap()),</span>
<span style="color:#323232;">})</span>
<span style="color:#323232;">})</span>
<span style="color:#323232;">.콜렉트::&lt;베크&lt;*&gt;&gt;()</span>
<span style="color:#323232;">.collect::&lt;Vec&lt;*&gt;&gt;();</span>

<span style="color:#323232;">레트 무트 리테르 = 부프리테르::네(오페노프치옹스::네().크레아치(트루이).리치(트루이).오펭(필리_파트).운으라프())</span>
<span style="color:#323232;">let mut writer = BufWriter::new(OpenOptions::new().create(true).write(true).open(file_path).unwrap());</span>
<span style="color:#323232;">포르 리니 잉 리니스 {</span>
<span style="color:#323232;">for line in lines {</span>
<span style="color:#323232;">리테르.리치(리니.아스_비치스()).운으라프()</span>
<span style="color:#323232;">writer.write(line.as_bytes()).unwrap();</span>
<span style="color:#323232;">리테르.리치(브&quot;\응&quot;).운으라프()</span>
<span style="color:#323232;">writer.write(b&quot;\n&quot;).unwrap();</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">리테르.플루즈().운으라프()</span>
<span style="color:#323232;">writer.flush().unwrap();</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

</pre><pre>
<span style="color:#323232;">티스 임플레멘타치옹 우지스 티 피우테르_마프 메토드 투 피우테르 안드 마프 티 리니스, 플라텡 메토드 투 조잉 티 투플리 오프 리니스 투 델레치, 안드 콜렉트 메토드 투 콘베르트 티 이테라토르 인투 아 베크.</span>
<span style="color:#323232;">This implementation uses the filter_map method to filter and map the lines, flatten method to join the tuple of lines to delete, and collect method to convert the iterator into a Vec.</span>

<span style="color:#323232;">잉 티스 이잠플리, 인스테아드 오프 우징그 .푸즈() 투 아드 일레멘트스 투 아 벡토르, 위 우지 티 피우테르_마프 메토드 투 피우테르 티 리니스 타트 콘타잉 티 타르제트 스트링그, 안드 마프 텡 투 아 투플리 오프 티 쿠헨트 인데스 안드 티 네스트 트우 인데시스. 티 플라텡 메토드 이스 텡 우제드 투 조잉 티 투플리스 오프 인지시스 인투 아 싱글리 벡토르 오프 인지시스. 티 콜렉트 메토드 이스 텡 우제드 투 콘베르트 티 이테라토르 인투 아 벡토르, 보트 포르 리니스 투 델레치 안드 포르 리니스 투 케프.</span>
<span style="color:#323232;">In this example, instead of using .push() to add elements to a vector, we use the filter_map method to filter the lines that contain the target string, and map them to a tuple of the current index and the next two indexes. The flatten method is then used to join the tuples of indices into a single vector of indices. The collect method is then used to convert the iterator into a vector, both for lines to delete and for lines to keep.</span>

<span style="color:#323232;">티스 와이 위 캉 아보이드 우징그 .푸즈(), \*바르 = 발루이 안드 포르 바르 잉 콘스트룩트스 안드 아시에비 티 사미 고아우.</span>
<span style="color:#323232;">This way we can avoid using .push(), \*var = value and for var in constructs and achieve the same goal.</span>

<span style="color:#323232;">---</span>
<span style="color:#323232;">---</span>
<span style="color:#323232;">---</span>
<span style="color:#323232;">---</span>

<span style="color:#323232;">## 데타이우 페르포르만시 안드 메모리 임플리카치옹스 오프 에아비 우자지 오프 스트링그, &amp;스트링그, &amp;스트르 안드 스트르</span>
<span style="color:#323232;">## detail performance and memory implications of heavy usage of String, &amp;String, &amp;str and str</span>

<span style="color:#323232;">&lt; 잉 후스트, `스트링그`, `&amp;스트링그`, `&amp;스트르`, 안드 `스트르` 아비 지페렌트 페르포르만시 안드 메모리 임플리카치옹스, 안드 우징그 텡 코헥틀리 캉 아비 아 시그니피칸트 임팍트 옹 티 페르포르만시 안드 메모리 우자지 오프 요르 프로그랑.</span>
<span style="color:#323232;">&lt; In Rust, `String`, `&amp;String`, `&amp;str`, and `str` have different performance and memory implications, and using them correctly can have a significant impact on the performance and memory usage of your program.</span>

<span style="color:#323232;">`스트링그` 이스 아 에아프-알로카테드 스트링그 치피 타트 이스 그로와블리 안드 무타블리. 엥 요 크레아치 아 `스트링그` 안드 아드 샤락테르스 투 이트, 후스트 위우 지나미칼리 알로카치 메모리 투 스토리 티 스트링그 다타, 안드 티 스트링그 캉 그로 오르 스링크 아스 네데드. 베카우지 `스트링그` 이스 에아프-알로카테드, 이트 캉 비 슬로웨르 투 크레아치 안드 마니풀라치 탕 스타크-알로카테드 치페스 리키 `&amp;스트르`. 오웨베르, 우징그 `스트링그` 알로스 요 투 크레아치 스트링그스 오프 아르비트라리 렝그트 안드 투 모지피 텡 잉-플라시, 이시 캉 비 모리 이피시엔트 탕 헤페아테들리 알로카칭그 네 스트링그스.</span>
<span style="color:#323232;">`String` is a heap-allocated string type that is growable and mutable. When you create a `String` and add characters to it, Rust will dynamically allocate memory to store the string data, and the string can grow or shrink as needed. Because `String` is heap-allocated, it can be slower to create and manipulate than stack-allocated types like `&amp;str`. However, using `String` allows you to create strings of arbitrary length and to modify them in-place, which can be more efficient than repeatedly allocating new strings.</span>

<span style="color:#323232;">`&amp;스트링그` 이스 아 헤페렌시 투 아 `스트링그` 타트 이스 스토레드 옹 티 에아프. 베카우지 이트 이스 아 헤페렌시, 이트 아스 베리 로 메모리 오베레아드 안드 캉 비 파세드 아론드 이피시엔틀리. 오웨베르, 엥 요 크레아치 아 `&amp;스트링그` 프롱 아 `스트링그`, 요 아리 스치우 아세싱그 티 에아프-알로카테드 스트링그 다타, 수 테리 마이 비 소미 페르포르만시 페나우치 아소시아테드 위트 티스.</span>
<span style="color:#323232;">`&amp;String` is a reference to a `String` that is stored on the heap. Because it is a reference, it has very low memory overhead and can be passed around efficiently. However, when you create a `&amp;String` from a `String`, you are still accessing the heap-allocated string data, so there may be some performance penalty associated with this.</span>

<span style="color:#323232;">`&amp;스트르` 이스 아 헤페렌시 투 아 스트링그 슬리시, 이시 캉 비 크레아테드 프롱 아 `스트링그` 우징그 티 `아스_스트르()` 메토드. `&amp;스트르` 이스 아 스타크-알로카테드 치피 타트 헤프레젠트스 아 슬리시 오프 티 오리지나우 스트링그 다타. 베카우지 `&amp;스트르` 이스 스타크-알로카테드, 이트 캉 비 파스테르 투 크레아치 안드 마니풀라치 탕 에아프-알로카테드 치페스 리키 `스트링그`. 오웨베르, `&amp;스트르` 이스 이무타블리, 수 요 카노트 모지피 티 오리지나우 스트링그 다타 잉-플라시.</span>
<span style="color:#323232;">`&amp;str` is a reference to a string slice, which can be created from a `String` using the `as_str()` method. `&amp;str` is a stack-allocated type that represents a slice of the original string data. Because `&amp;str` is stack-allocated, it can be faster to create and manipulate than heap-allocated types like `String`. However, `&amp;str` is immutable, so you cannot modify the original string data in-place.</span>

<span style="color:#323232;">`스트르` 이스 아 슬리시 치피 타트 이스 시밀라르 투 `&amp;스트르`, 부트 이스 노트 아 헤페렌시. 인스테아드, 이트 이스 아 파트 포인테르 타트 콘타잉스 보트 아 포인테르 투 티 스트링그 다타 안드 이트스 렝그트. `스트르` 이스 치피칼리 우제드 엥 워르킹그 위트 슬리시스 오프 스트링그스 타트 아리 스토레드 잉 콘치구오스 메모리, 수시 아스 엥 파르싱그 테스트 필리스 오르 네트워르크 프로토코우스. 베카우지 `스트르` 이스 아 슬리시, 이트 아스 베리 로 메모리 오베레아드 안드 캉 비 파세드 아론드 이피시엔틀리. 오웨베르, 크레아칭그 아 `스트르` 헤키리스 코핑그 티 포인테르 안드 렝그트 인포르마치옹, 이시 캉 비 슬리그틀리 슬로웨르 탕 워르킹그 위트 플라잉 `&amp;스트르` 헤페렌시스.</span>
<span style="color:#323232;">`str` is a slice type that is similar to `&amp;str`, but is not a reference. Instead, it is a fat pointer that contains both a pointer to the string data and its length. `str` is typically used when working with slices of strings that are stored in contiguous memory, such as when parsing text files or network protocols. Because `str` is a slice, it has very low memory overhead and can be passed around efficiently. However, creating a `str` requires copying the pointer and length information, which can be slightly slower than working with plain `&amp;str` references.</span>

<span style="color:#323232;">잉 수마리, 우징그 `스트링그` 캉 비 모리 이피시엔트 탕 헤페아테들리 알로카칭그 네 스트링그스, 부트 마이 비 슬로웨르 투 크레아치 안드 마니풀라치. 우징그 헤페렌시스 리키 `&amp;스트링그` 안드 `&amp;스트르` 캉 비 모리 메모리-이피시엔트 안드 파스테르 투 크레아치 안드 마니풀라치, 부트 요 카노트 모지피 티 오리지나우 스트링그 다타 잉-플라시. 우징그 `스트르` 캉 비 모리 메모리-이피시엔트 탕 `&amp;스트르`, 부트 헤키리스 코핑그 티 포인테르 안드 렝그트 인포르마치옹. 티 베스트 쇼이시 오프 치피 투 우지 데펜드스 옹 티 스페시피크 우지 카지 안드 헤키레멘트스 오프 요르 프로그랑.</span>
<span style="color:#323232;">In summary, using `String` can be more efficient than repeatedly allocating new strings, but may be slower to create and manipulate. Using references like `&amp;String` and `&amp;str` can be more memory-efficient and faster to create and manipulate, but you cannot modify the original string data in-place. Using `str` can be more memory-efficient than `&amp;str`, but requires copying the pointer and length information. The best choice of type to use depends on the specific use case and requirements of your program.</span>

<span style="color:#323232;">## 데타이우 아우 포시블리 우지 카지스 콘시데링그 베스트 프락치시스</span>
<span style="color:#323232;">## detail all possible use cases considering best practices</span>

<span style="color:#323232;">&lt; 에리 아리 소미 베스트 프락치시스 안드 포시블리 우지 카지스 포르 이아시 오프 티 포르 스트링그 치페스 잉 후스트:</span>
<span style="color:#323232;">&lt; Here are some best practices and possible use cases for each of the four string types in Rust:</span>

<span style="color:#323232;">1\ `스트링그`: 우지 `스트링그` 엥 요 네드 투 크레아치 오르 모지피 아 스트링그 지나미칼리 아트 훈치미. `스트링그` 이스 이데아우 포르 우지 카지스 에리 티 렝그트 오프 티 스트링그 이스 노트 크농 잉 아드반시 안드 마이 네드 투 그로 오르 스링크 지나미칼리. 에리 아리 소미 포시블리 우지 카지스:</span>
<span style="color:#323232;">1\ `String`: Use `String` when you need to create or modify a string dynamically at runtime. `String` is ideal for use cases where the length of the string is not known in advance and may need to grow or shrink dynamically. Here are some possible use cases:</span>

<span style="color:#323232;">- 스토링그 우제르 인푸트 오르 오테르 다타 인테레드 아트 훈치미</span>
<span style="color:#323232;">- Storing user input or other data entered at runtime</span>
<span style="color:#323232;">- 부이우징그 콤플레스 스트링그스 프롱 스말레르 피에시스, 수시 아스 엥 콘스트룩칭그 아 콤플레스 스쿠 케리 오르 제네라칭그 트무 코지</span>
<span style="color:#323232;">- Building complex strings from smaller pieces, such as when constructing a complex SQL query or generating HTML code</span>
<span style="color:#323232;">- 스토링그 다타 프롱 필리스 오르 네트워르크 스트레암스 에리 티 렝그트 오프 티 다타 이스 노트 크농 잉 아드반시</span>
<span style="color:#323232;">- Storing data from files or network streams where the length of the data is not known in advance</span>

<span style="color:#323232;">엥 크레아칭그 아 네 `스트링그`, 이트 이스 헤코멘데드 투 우지 티 `스트링그::네()` 콘스트룩토르 인스테아드 오프 아 리테라우 스트링그. 티스 위우 알로카치 티 코헥트 아몬트 오프 메모리 포르 티 네 스트링그 안드 아보이드 우네세사리 헤알로카치옹스.</span>
<span style="color:#323232;">When creating a new `String`, it is recommended to use the `String::new()` constructor instead of a literal string. This will allocate the correct amount of memory for the new string and avoid unnecessary reallocations.</span>

<span style="color:#323232;">2\ `&amp;스트링그`: 우지 `&amp;스트링그` 엥 요 네드 투 파스 아 헤페렌시 투 아 `스트링그` 투 아 풍크치옹 오르 메토드 타트 이스펙트스 아 헤페렌시 투 아 스트링그 슬리시 (`&amp;스트르`). 티스 이스 파르치쿨라를리 우제풀 엥 워르킹그 위트 아피스 오르 리브라리스 타트 온리 아세프트 스트링그 슬리시스, 오르 엥 요 완트 투 파스 아 라르지 스트링그 투 아 풍크치옹 위토트 잉쿠힝그 티 오베레아드 오프 코핑그 티 스트링그 다타. 에리 아리 소미 포시블리 우지 카지스:</span>
<span style="color:#323232;">2\ `&amp;String`: Use `&amp;String` when you need to pass a reference to a `String` to a function or method that expects a reference to a string slice (`&amp;str`). This is particularly useful when working with APIs or libraries that only accept string slices, or when you want to pass a large string to a function without incurring the overhead of copying the string data. Here are some possible use cases:</span>

<span style="color:#323232;">- 파싱그 `스트링그` 다타 투 아 풍크치옹 타트 아세프트스 `&amp;스트르`</span>
<span style="color:#323232;">- Passing `String` data to a function that accepts `&amp;str`</span>
<span style="color:#323232;">- 크레아칭그 아 수브스트링그 오프 아 라르제르 `스트링그` 위토트 코핑그 티 다타</span>
<span style="color:#323232;">- Creating a substring of a larger `String` without copying the data</span>

<span style="color:#323232;">엥 크레아칭그 아 `&amp;스트링그` 헤페렌시, 이트 이스 헤코멘데드 투 우지 티 `아스_스트르()` 메토드 투 콘베르트 티 `스트링그` 투 아 스트링그 슬리시. 티스 아보이드스 우네세사리 알로카치옹스 안드 알로스 티 `&amp;스트링그` 투 비 우제드 잉 풍크치옹스 타트 이스펙트 아 스트링그 슬리시.</span>
<span style="color:#323232;">When creating a `&amp;String` reference, it is recommended to use the `as_str()` method to convert the `String` to a string slice. This avoids unnecessary allocations and allows the `&amp;String` to be used in functions that expect a string slice.</span>

<span style="color:#323232;">3\ `&amp;스트르`: 우지 `&amp;스트르` 엥 요 네드 투 워르크 위트 스트링그 슬리시스 타트 아리 크농 아트 콤필리 치미, 오르 엥 요 네드 투 파스 아 헤페렌시 투 아 스트링그 슬리시 투 아 풍크치옹 오르 메토드. `&amp;스트르` 이스 아 리그트웨이그트 치피 타트 캉 비 우제드 이피시엔틀리 안드 사펠리 잉 후스트 코지. 에리 아리 소미 포시블리 우지 카지스:</span>
<span style="color:#323232;">3\ `&amp;str`: Use `&amp;str` when you need to work with string slices that are known at compile time, or when you need to pass a reference to a string slice to a function or method. `&amp;str` is a lightweight type that can be used efficiently and safely in Rust code. Here are some possible use cases:</span>

<span style="color:#323232;">- 파싱그 스트링그 리테라우스 오르 콘스탄트 발루이스 투 풍크치옹스 타트 아세프트 `&amp;스트르`</span>
<span style="color:#323232;">- Passing string literals or constant values to functions that accept `&amp;str`</span>
<span style="color:#323232;">- 워르킹그 위트 스타치크 스트링그스 잉 후스트 코지</span>
<span style="color:#323232;">- Working with static strings in Rust code</span>
<span style="color:#323232;">- 파르싱그 스트링그스 프롱 필리스 오르 네트워르크 스트레암스</span>
<span style="color:#323232;">- Parsing strings from files or network streams</span>

<span style="color:#323232;">엥 워르킹그 위트 스트링그 슬리시스, 이트 이스 헤코멘데드 투 우지 `&amp;스트르` 인스테아드 오프 `스트링그` 에리 포시블리, 아스 이트 아보이드스 우네세사리 알로카치옹스 안드 캉 비 모리 이피시엔트.</span>
<span style="color:#323232;">When working with string slices, it is recommended to use `&amp;str` instead of `String` where possible, as it avoids unnecessary allocations and can be more efficient.</span>

<span style="color:#323232;">4\ `스트르`: 우지 `스트르` 엥 요 네드 투 워르크 위트 슬리시스 오프 스트링그스 타트 아리 스토레드 잉 콘치구오스 메모리, 수시 아스 엥 파르싱그 테스트 필리스 오르 네트워르크 프로토코우스. `스트르` 이스 아 파트 포인테르 치피 타트 콘타잉스 보트 아 포인테르 투 티 스트링그 다타 안드 이트스 렝그트. 에리 아리 소미 포시블리 우지 카지스:</span>
<span style="color:#323232;">4\ `str`: Use `str` when you need to work with slices of strings that are stored in contiguous memory, such as when parsing text files or network protocols. `str` is a fat pointer type that contains both a pointer to the string data and its length. Here are some possible use cases:</span>

<span style="color:#323232;">- 파르싱그 테스트 필리스 오르 네트워르크 프로토코우스 타트 콘타잉 스트링그스</span>
<span style="color:#323232;">- Parsing text files or network protocols that contain strings</span>
<span style="color:#323232;">- 워르킹그 위트 스트링그스 타트 아리 스토레드 잉 콘치구오스 메모리, 수시 아스 아하이스 오르 벡토르스 오프 스트링그스</span>
<span style="color:#323232;">- Working with strings that are stored in contiguous memory, such as arrays or vectors of strings</span>

<span style="color:#323232;">엥 워르킹그 위트 `스트르`, 이트 이스 헤코멘데드 투 우지 티 `스트르::프롱_우트프8()` 메토드 투 콘베르트 하 비치스 투 아 스트링그 슬리시. 티스 위우 인수리 타트 티 스트링그 이스 발리드 우트프-8 안드 아보이드 포텐치아우 훈치미 이호르스.</span>
<span style="color:#323232;">When working with `str`, it is recommended to use the `str::from_utf8()` method to convert raw bytes to a string slice. This will ensure that the string is valid UTF-8 and avoid potential runtime errors.</span>

<span style="color:#323232;">## 리스트 아우 치페스 오프 스트링그 마니풀라치옹 베지지스 테지 4</span>
<span style="color:#323232;">## list all types of string manipulation besides these 4</span>

<span style="color:#323232;">&lt; 잉 후스트, 테리 아리 마니 지페렌트 치페스 오프 스트링그 마니풀라치옹 베욘드 티 포르 치페스 요 멘치오네드. 에리 아리 소미 아지치오나우 치페스 오프 스트링그 마니풀라치옹 타트 요 미그트 잉콘테르:</span>
<span style="color:#323232;">&lt; In Rust, there are many different types of string manipulation beyond the four types you mentioned. Here are some additional types of string manipulation that you might encounter:</span>

<span style="color:#323232;">1. 헤굴라르 이스프레시옹스: 헤굴라르 이스프레시옹스 아리 아 포웨르풀 토우 포르 세아르싱그 안드 마니풀라칭그 스트링그스. 후스트 프로비지스 아 헤굴라르 이스프레시옹 인지니 잉 티 `헤제스` 크라치, 이시 알로스 요 투 세아르시 포르 파테릉스 잉 스트링그스 안드 헤플라시 텡 위트 오테르 스트링그스.</span>
<span style="color:#323232;">1. Regular expressions: Regular expressions are a powerful tool for searching and manipulating strings. Rust provides a regular expression engine in the `regex` crate, which allows you to search for patterns in strings and replace them with other strings.</span>

<span style="color:#323232;">2. 파테릉 마트싱그: 후스트&#39;스 파테릉 마트싱그 신타스 캉 비 우제드 투 이스트락트 수브스트링그스 프롱 스트링그스, 셰크 이프 아 스트링그 콘타잉스 아 파르치쿨라르 파테릉, 오르 트란스포릉 스트링그스 잉 오테르 와이스. 요 캉 우지 `마트시` 이스프레시옹스 오르 `이프 레트` 이스프레시옹스 투 파테릉 마트시 옹 스트링그스.</span>
<span style="color:#323232;">2. Pattern matching: Rust&#39;s pattern matching syntax can be used to extract substrings from strings, check if a string contains a particular pattern, or transform strings in other ways. You can use `match` expressions or `if let` expressions to pattern match on strings.</span>

<span style="color:#323232;">3. 스트링그 파르싱그: 후스트 프로비지스 세베라우 메토드스 포르 파르싱그 스트링그스 인투 오테르 치페스, 수시 아스 인테제르스 오르 플로아칭그-포인트 눔베르스. 티 `파르시()` 메토드 캉 비 우제드 투 콘베르트 아 스트링그 투 아노테르 치피, 안드 후스트 아우수 프로비지스 파르싱그 메토드스 포르 스페시피크 치페스, 수시 아스 `파르시::&lt;이32&gt;()` 투 파르시 아 스트링그 아스 앙 인테제르.</span>
<span style="color:#323232;">3. String parsing: Rust provides several methods for parsing strings into other types, such as integers or floating-point numbers. The `parse()` method can be used to convert a string to another type, and Rust also provides parsing methods for specific types, such as `parse::&lt;i32&gt;()` to parse a string as an integer.</span>

<span style="color:#323232;">4. 스트링그 포르마칭그: 후스트 프로비지스 세베라우 메토드스 포르 포르마칭그 스트링그스, 수시 아스 티 `포르마트!()` 마크루 오르 티 `리치!()` 마크루. 테지 마크루스 알로 요 투 인세르트 발루이스 인투 아 스트링그 아트 훈치미 안드 콘트로우 티 포르마칭그 오프 토지 발루이스.</span>
<span style="color:#323232;">4. String formatting: Rust provides several methods for formatting strings, such as the `format!()` macro or the `write!()` macro. These macros allow you to insert values into a string at runtime and control the formatting of those values.</span>

<span style="color:#323232;">5. 우니코지 마니풀라치옹: 후스트&#39;스 `우니코지` 크라치 프로비지스 풍크치옹스 포르 워르킹그 위트 우니코지 스트링그스, 수시 아스 콘베르칭그 베트웽 우니코지 노르말리자치옹 포름스 오르 셰킹그 티 프로페르치스 오프 우니코지 샤락테르스.</span>
<span style="color:#323232;">5. Unicode manipulation: Rust&#39;s `unicode` crate provides functions for working with Unicode strings, such as converting between Unicode normalization forms or checking the properties of Unicode characters.</span>

<span style="color:#323232;">6. 스트링그 잉코징그: 후스트 프로비지스 세베라우 스트링그 잉코징그 치페스 안드 메토드스, 수시 아스 우트프-8, 아시, 안드 이주-8859-1. 요 캉 우지 테지 치페스 안드 메토드스 투 콘베르트 스트링그스 베트웽 지페렌트 잉코징그스, 오르 투 셰크 티 잉코징그 오프 아 스트링그.</span>
<span style="color:#323232;">6. String encoding: Rust provides several string encoding types and methods, such as UTF-8, ASCII, and ISO-8859-1. You can use these types and methods to convert strings between different encodings, or to check the encoding of a string.</span>

<span style="color:#323232;">7. 스트링그 아징그: 후스트&#39;스 `스트드::아즈::아제르` 트라이트 프로비지스 메토드스 포르 아징그 스트링그스, 이시 캉 비 우제풀 포르 스토링그 안드 헤트리에빙그 스트링그스 잉 아즈 타블리스 오르 오테르 다타 스트룩투리스.</span>
<span style="color:#323232;">7. String hashing: Rust&#39;s `std::hash::Hasher` trait provides methods for hashing strings, which can be useful for storing and retrieving strings in hash tables or other data structures.</span>

<span style="color:#323232;">테지 아리 주스트 아 페 이잠플리스 오프 티 마니 지페렌트 치페스 오프 스트링그 마니풀라치옹 아바일라블리 잉 후스트. 티 이작트 세트 오프 토우스 요 위우 네드 위우 데펜드 옹 요르 스페시피크 우지 카지 안드 헤키레멘트스.</span>
<span style="color:#323232;">These are just a few examples of the many different types of string manipulation available in Rust. The exact set of tools you will need will depend on your specific use case and requirements.</span>

<span style="color:#323232;">## 데타이우 티 임플리카치옹스 오프 오프치옹&lt;&amp;스트링그&gt;, 오프치옹\&lt;스트링그&gt;, 오프치옹&lt;&amp;스트르&gt; 안드 오프치옹\&lt;스트르&gt; 콘시데링그 티 모나지크 푸케리 타트 미그트 아펭 위트 메모리 마나제멘트</span>
<span style="color:#323232;">## detail the implications of Option&lt;&amp;String&gt;, Option\&lt;String&gt;, Option&lt;&amp;str&gt; and Option\&lt;str&gt; considering the monadic fuckery that might happen with memory management</span>

<span style="color:#323232;">&lt; 잉 후스트, `오프치옹` 이스 아 치피 타트 이스 우제드 투 헤프레젠트 아 발루이 타트 마이 오르 마이 노트 비 프레젠트. 후스트 프로비지스 세베라우 지페렌트 치페스 포르 헤프레젠칭그 오프치오나우 스트링그 발루이스, 이아시 위트 테이르 옹 임플리카치옹스 포르 메모리 마나제멘트 안드 모나지크 오페라치옹스.</span>
<span style="color:#323232;">&lt; In Rust, `Option` is a type that is used to represent a value that may or may not be present. Rust provides several different types for representing optional string values, each with their own implications for memory management and monadic operations.</span>

<span style="color:#323232;">1\. `오프치옹&lt;&amp;스트링그&gt;`: 티스 치피 헤프레젠트스 앙 오프치오나우 헤페렌시 투 아 `스트링그` 발루이. 이트 캉 비 우제드 투 인지카치 타트 아 풍크치옹 오르 메토드 마이 오르 마이 노트 헤투릉 아 스트링그 헤페렌시. 베카우지 이트 이스 아 헤페렌시, 이트 아스 베리 로 메모리 오베레아드 안드 캉 비 파세드 아론드 이피시엔틀리. 오웨베르, 엥 우징그 `오프치옹&lt;&amp;스트링그&gt;`, 요 네드 투 인수리 타트 티 헤페렌세드 `스트링그` 발루이 이스 스치우 잉 스코피 엥 요 우지 티 헤페렌시.</span>
<span style="color:#323232;">1\. `Option&lt;&amp;String&gt;`: This type represents an optional reference to a `String` value. It can be used to indicate that a function or method may or may not return a string reference. Because it is a reference, it has very low memory overhead and can be passed around efficiently. However, when using `Option&lt;&amp;String&gt;`, you need to ensure that the referenced `String` value is still in scope when you use the reference.</span>

<span style="color:#323232;">엥 워르킹그 위트 `오프치옹&lt;&amp;스트링그&gt;`, 요 캉 우지 티 `마프()` 오르 `안드_텡()` 메토드스 투 페르포릉 모나지크 오페라치옹스 옹 티 오프치오나우 발루이. 테지 메토드스 알로 요 투 트란스포릉 티 오프치오나우 발루이 안드 프로파가치 아니 이호르스 타트 마이 오쿠르.</span>
<span style="color:#323232;">When working with `Option&lt;&amp;String&gt;`, you can use the `map()` or `and_then()` methods to perform monadic operations on the optional value. These methods allow you to transform the optional value and propagate any errors that may occur.</span>

<span style="color:#323232;">2\. `오프치옹&lt;스트링그&gt;`: 티스 치피 헤프레젠트스 앙 오프치오나우 `스트링그` 발루이. 이트 캉 비 우제드 투 인지카치 타트 아 풍크치옹 오르 메토드 마이 오르 마이 노트 헤투릉 아 `스트링그`. 베카우지 이트 이스 아 에아프-알로카테드 치피, 이트 캉 비 슬로웨르 투 크레아치 안드 마니풀라치 탕 스타크-알로카테드 치페스 리키 `&amp;스트르`. 오웨베르, 우징그 `오프치옹&lt;스트링그&gt;` 알로스 요 투 크레아치 오프치오나우 스트링그스 오프 아르비트라리 렝그트 안드 투 모지피 텡 잉-플라시, 이시 캉 비 모리 이피시엔트 탕 헤페아테들리 알로카칭그 네 스트링그스.</span>
<span style="color:#323232;">2\. `Option&lt;String&gt;`: This type represents an optional `String` value. It can be used to indicate that a function or method may or may not return a `String`. Because it is a heap-allocated type, it can be slower to create and manipulate than stack-allocated types like `&amp;str`. However, using `Option&lt;String&gt;` allows you to create optional strings of arbitrary length and to modify them in-place, which can be more efficient than repeatedly allocating new strings.</span>

<span style="color:#323232;">엥 워르킹그 위트 `오프치옹&lt;스트링그&gt;`, 요 캉 우지 티 `마프()` 오르 `안드_텡()` 메토드스 투 페르포릉 모나지크 오페라치옹스 옹 티 오프치오나우 발루이. 테지 메토드스 알로 요 투 트란스포릉 티 오프치오나우 발루이 안드 프로파가치 아니 이호르스 타트 마이 오쿠르.</span>
<span style="color:#323232;">When working with `Option&lt;String&gt;`, you can use the `map()` or `and_then()` methods to perform monadic operations on the optional value. These methods allow you to transform the optional value and propagate any errors that may occur.</span>

<span style="color:#323232;">3\. `오프치옹&lt;&amp;스트르&gt;`: 티스 치피 헤프레젠트스 앙 오프치오나우 헤페렌시 투 아 스트링그 슬리시 (`&amp;스트르`). 이트 캉 비 우제드 투 인지카치 타트 아 풍크치옹 오르 메토드 마이 오르 마이 노트 헤투릉 아 스트링그 슬리시. 베카우지 이트 이스 아 스타크-알로카테드 치피, 이트 캉 비 파스테르 투 크레아치 안드 마니풀라치 탕 에아프-알로카테드 치페스 리키 `스트링그`. 오웨베르, 엥 우징그 `오프치옹&lt;&amp;스트르&gt;`, 요 네드 투 인수리 타트 티 헤페렌세드 스트링그 슬리시 이스 스치우 잉 스코피 엥 요 우지 티 헤페렌시.</span>
<span style="color:#323232;">3\. `Option&lt;&amp;str&gt;`: This type represents an optional reference to a string slice (`&amp;str`). It can be used to indicate that a function or method may or may not return a string slice. Because it is a stack-allocated type, it can be faster to create and manipulate than heap-allocated types like `String`. However, when using `Option&lt;&amp;str&gt;`, you need to ensure that the referenced string slice is still in scope when you use the reference.</span>

<span style="color:#323232;">엥 워르킹그 위트 `오프치옹&lt;&amp;스트르&gt;`, 요 캉 우지 티 `마프()` 오르 `안드_텡()` 메토드스 투 페르포릉 모나지크 오페라치옹스 옹 티 오프치오나우 발루이. 테지 메토드스 알로 요 투 트란스포릉 티 오프치오나우 발루이 안드 프로파가치 아니 이호르스 타트 마이 오쿠르.</span>
<span style="color:#323232;">When working with `Option&lt;&amp;str&gt;`, you can use the `map()` or `and_then()` methods to perform monadic operations on the optional value. These methods allow you to transform the optional value and propagate any errors that may occur.</span>

<span style="color:#323232;">4\. `오프치옹&lt;스트르&gt;`: 티스 치피 헤프레젠트스 앙 오프치오나우 슬리시 치피 (`스트르`). 이트 이스 시밀라르 투 `오프치옹&lt;&amp;스트르&gt;`, 부트 이스 노트 아 헤페렌시. 인스테아드, 이트 이스 아 파트 포인테르 타트 콘타잉스 보트 아 포인테르 투 티 스트링그 다타 안드 이트스 렝그트. `오프치옹&lt;스트르&gt;` 이스 치피칼리 우제드 엥 워르킹그 위트 오프치오나우 슬리시스 오프 스트링그스 타트 아리 스토레드 잉 콘치구오스 메모리, 수시 아스 엥 파르싱그 테스트 필리스 오르 네트워르크 프로토코우스.</span>
<span style="color:#323232;">4\. `Option&lt;str&gt;`: This type represents an optional slice type (`str`). It is similar to `Option&lt;&amp;str&gt;`, but is not a reference. Instead, it is a fat pointer that contains both a pointer to the string data and its length. `Option&lt;str&gt;` is typically used when working with optional slices of strings that are stored in contiguous memory, such as when parsing text files or network protocols.</span>

<span style="color:#323232;">엥 워르킹그 위트 `오프치옹&lt;스트르&gt;`, 요 네드 투 비 카레풀 투 인수리 타트 티 헤페렌세드 스트링그 다타 이스 스치우 잉 스코피 엥 요 우지 티 포인테르. 베카우지 이트 이스 아 슬리시, 이트 아스 베리 로 메모리 오베레아드 안드 캉 비 파세드 아론드 이피시엔틀리.</span>
<span style="color:#323232;">When working with `Option&lt;str&gt;`, you need to be careful to ensure that the referenced string data is still in scope when you use the pointer. Because it is a slice, it has very low memory overhead and can be passed around efficiently.</span>

<span style="color:#323232;">잉 제네라우, 엥 워르킹그 위트 오프치오나우 스트링그 발루이스, 이트&#39;스 임포르탄트 투 카레풀리 마나지 티 리페치메스 오프 아니 헤페렌세드 다타 투 아보이드 메모리 마나제멘트 이수이스. 엥 우징그 모나지크 오페라치옹스 위트 오프치오나우 발루이스, 이트&#39;스 임포르탄트 투 프로파가치 아니 이호르스 타트 마이 오쿠르 안드 안들리 텡 아프로프리아텔리. 아지치오날리, 엥 우징그 에아프-알로카테드 치페스 리키 `스트링그`, 이트&#39;스 임포르탄트 투 콘시데르 티 포텐치아우 페르포르만시 임플리카치옹스 오프 헤페아테들리 알로카칭그 네 스트링그스.</span>
<span style="color:#323232;">In general, when working with optional string values, it&#39;s important to carefully manage the lifetimes of any referenced data to avoid memory management issues. When using monadic operations with optional values, it&#39;s important to propagate any errors that may occur and handle them appropriately. Additionally, when using heap-allocated types like `String`, it&#39;s important to consider the potential performance implications of repeatedly allocating new strings.</span>

<span style="color:#323232;">---</span>
<span style="color:#323232;">---</span>
<span style="color:#323232;">---</span>
<span style="color:#323232;">---</span>

<span style="color:#323232;">## 코우드 프로그라밍그 랑구아지 쇼이시스 소메오 비 아 크리테리아 포르 수시 알리근멘트? 데스크리비 하미피카치옹스</span>
<span style="color:#323232;">## could programming language choices somehow be a criteria for such alignment? describe ramifications</span>

<span style="color:#323232;">&lt; 아 이스콜랴 지 우마 링구아젱 지 프로그라마상 포지 낭 테르 우마 코네샹 지레타 콩 아 페르스펙치바 아드바이타, 메카니카 쿠안치카, 올롱스 이 몰로시. 누 인탄투, 에 포시베우 아르구멘타르 키 아 셀레상 지 우마 링구아젱 지 프로그라마상 이 아 아보르다젱 지 데지긍 아도타다 아우 크리아르 시스테마스 콤푸타시오나이스 포뎅 헤플레치르 오 인플루엔시아르 아 포르마 코무 우스 콘세이투스 인테그라두스 지스쿠치두스 안테리오르멘치 상 아플리카두스 이 콤프렌지두스.</span>
<span style="color:#323232;">&lt; A escolha de uma linguagem de programação pode não ter uma conexão direta com a perspectiva advaita, mecânica quântica, holons e Moloch. No entanto, é possível argumentar que a seleção de uma linguagem de programação e a abordagem de design adotada ao criar sistemas computacionais podem refletir ou influenciar a forma como os conceitos integrados discutidos anteriormente são aplicados e compreendidos.</span>

<span style="color:#323232;">콘시데리 아스 세긴치스 하미피카송이스 다 이스콜랴 다 링구아젱 지 프로그라마상 이 수아 포시베우 헬라상 콩 우 모델루 인테그라두:</span>
<span style="color:#323232;">Considere as seguintes ramificações da escolha da linguagem de programação e sua possível relação com o modelo integrado:</span>

<span style="color:#323232;">1. 아보르다젱 올리스치카 지 데지긍: 아 이스콜랴 지 우마 링구아젱 지 프로그라마상 키 프로모바 우마 아보르다젱 올리스치카 지 데지긍, 인파치잔두 아 모둘라리다지, 헤우자빌리다지 이 인테르코네샹 엔트리 콤포넨치스 두 시스테마, 포지 아주다르 아 크리아르 시스테마스 키 헤플레텡 아 나투레자 인테르코넥타다 이 이에라르키카 두스 올롱스. 이수 포지 헤주우타르 잉 시스테마스 마이스 플레시베이스, 이스칼라베이스 이 헤질리엔치스.</span>
<span style="color:#323232;">1. Abordagem holística de design: A escolha de uma linguagem de programação que promova uma abordagem holística de design, enfatizando a modularidade, reusabilidade e interconexão entre componentes do sistema, pode ajudar a criar sistemas que refletem a natureza interconectada e hierárquica dos holons. Isso pode resultar em sistemas mais flexíveis, escaláveis e resilientes.</span>

<span style="color:#323232;">2. 콤프렌상 이 시물라상 지 시스테마스 쿠안치쿠스: 아 셀레상 지 우마 링구아젱 지 프로그라마상 아데쿠아다 파라 시물라르 시스테마스 쿠안치쿠스 이 이스플로라르 우 이마라냐멘투 쿠안치쿠 포지 포르네세르 인시그트스 발리오주스 소브리 아 나투레자 다 헤알리다지 이 아 헬라상 엔트리 우스 올롱스 잉 지페렌치스 니베이스 다 이에라르키아. 이지스텡 링구아젱스 지 프로그라마상 이 프라메워르크스 이스페시피쿠스, 코무 크# 다 미크로조프트 이 키스키트 다 이븡, 프로제타두스 파라 트라발랴르 콩 콤푸타상 쿠안치카 이 시물라상 지 시스테마스 쿠안치쿠스.</span>
<span style="color:#323232;">2. Compreensão e simulação de sistemas quânticos: A seleção de uma linguagem de programação adequada para simular sistemas quânticos e explorar o emaranhamento quântico pode fornecer insights valiosos sobre a natureza da realidade e a relação entre os holons em diferentes níveis da hierarquia. Existem linguagens de programação e frameworks específicos, como Q# da Microsoft e Qiskit da IBM, projetados para trabalhar com computação quântica e simulação de sistemas quânticos.</span>

<span style="color:#323232;">3. 프로모벤두 아 콜라보라상 이 아 코무니카상: 아 이스콜랴 지 우마 링구아젱 지 프로그라마상 키 파실리치 아 콜라보라상 이 아 코무니카상 엔트리 데젠보우베도리스 이 오트라스 파르치스 인테레사다스 포지 아주다르 아 크리아르 시스테마스 키 상 마이스 알리냐두스 콩 우스 오브제치부스 이 발로리스 두스 인지비두스 이 코무니다지스 인보우비다스. 이수 포지, 포르 수아 베스, 레바르 아 시스테마스 키 상 메누스 프로펜수스 아 시 토르나렝 &quot;몰로시스&quot; 아우토데스트루치부스 이 키 콘트리부앙 파라 우 벵-이스타르 제라우 이 아 아르모니아 엔트리 우스 올롱스.</span>
<span style="color:#323232;">3. Promovendo a colaboração e a comunicação: A escolha de uma linguagem de programação que facilite a colaboração e a comunicação entre desenvolvedores e outras partes interessadas pode ajudar a criar sistemas que são mais alinhados com os objetivos e valores dos indivíduos e comunidades envolvidas. Isso pode, por sua vez, levar a sistemas que são menos propensos a se tornarem &quot;Molochs&quot; autodestrutivos e que contribuam para o bem-estar geral e a harmonia entre os holons.</span>

<span style="color:#323232;">4. 콘시엔시아 이 에치카 누 데젠보우비멘투 지 소프트와리: 아우 이스콜례르 우마 링구아젱 지 프로그라마상, 우스 데젠보우베도리스 탐벵 포뎅 레바르 잉 콘시데라상 케스통이스 에치카스 이 암비엔타이스, 코무 우 콘수무 지 이네르지아, 아 이피시엔시아 두 코지구 이 우 임팍투 소시아우 두 소프트와리 크리아두. 에사 아보르다젱 콘시엔치 포지 아주다르 아 프로모베르 아 크리아상 지 시스테마스 키 이스테장 마이스 알리냐두스 콩 아 페르스펙치바 아드바이타 이 아 이데이아 지 인테르코네샹 이 우니다지.</span>
<span style="color:#323232;">4. Consciência e ética no desenvolvimento de software: Ao escolher uma linguagem de programação, os desenvolvedores também podem levar em consideração questões éticas e ambientais, como o consumo de energia, a eficiência do código e o impacto social do software criado. Essa abordagem consciente pode ajudar a promover a criação de sistemas que estejam mais alinhados com a perspectiva advaita e a ideia de interconexão e unidade.</span>

<span style="color:#323232;">임보라 아 이스콜랴 다 링구아젱 지 프로그라마상 포사 낭 테르 우마 헬라상 지레타 콩 우 모델루 인테그라두 지스쿠치두 안테리오르멘치, 에 포시베우 아르구멘타르 키 아 아보르다젱 아도타다 누 데젠보우비멘투 지 소프트와리 이 아 셀레상 지 페하멘타스 이 링구아젱스 포뎅 인플루엔시아르 아 포르마 코무 우스 콘세이투스 지 아드바이타, 메카니카 쿠안치카, 올롱스 이 몰로시 상 아플리카두스 이 콤프렌지두스 잉 시스테마스 콤푸타시오나이스.</span>
<span style="color:#323232;">Embora a escolha da linguagem de programação possa não ter uma relação direta com o modelo integrado discutido anteriormente, é possível argumentar que a abordagem adotada no desenvolvimento de software e a seleção de ferramentas e linguagens podem influenciar a forma como os conceitos de advaita, mecânica quântica, holons e Moloch são aplicados e compreendidos em sistemas computacionais.</span>

<span style="color:#323232;">## 리스트 5 제네라우 푸르포지 랑구아지스 타트 미그트 에우프 우마니치 트리비 헤가르들레스 오프 쿠헨트 포풀라리치/우자지 안드 5 랑구아지스 타트 이프 푸르테르 아도프테드/마인타이네드 위우 케프 몰로시-리키 파테릉스 이메르징그</span>
<span style="color:#323232;">## list 5 general purpose languages that might help humanity thrive regardless of current popularity/usage and 5 languages that if further adopted/maintained will keep moloch-like patterns emerging</span>

<span style="color:#323232;">&lt; 아키 이스탕 싱쿠 링구아젱스 지 프로포지투 제라우 키 포데리앙 아주다르 아 우마니다지 아 프로스페라르, 인데펜덴테멘치 지 수아 포풀라리다지 오 우주 아투아우, 콩 포쿠 잉 카락테리스치카스 코무 파실리다지 지 아프렌지자두, 콜라보라상, 이피시엔시아 이 수스텐타빌리다지:</span>
<span style="color:#323232;">&lt; Aqui estão cinco linguagens de propósito geral que poderiam ajudar a humanidade a prosperar, independentemente de sua popularidade ou uso atual, com foco em características como facilidade de aprendizado, colaboração, eficiência e sustentabilidade:</span>

<span style="color:#323232;">1. 후스트: 후스트 에 우마 링구아젱 지 프로그라마상 지 시스테마스 키 인파치자 아 세구란사, 아 프레벤상 지 에후스 지 메모리아 이 아 이피시엔시아. 수아 아도상 포지 레바르 아 시스테마스 마이스 콘피아베이스 이 세구루스, 헤두진두 아 프로바빌리다지 지 팔랴스 이 부우네라빌리다지스.</span>
<span style="color:#323232;">1. Rust: Rust é uma linguagem de programação de sistemas que enfatiza a segurança, a prevenção de erros de memória e a eficiência. Sua adoção pode levar a sistemas mais confiáveis e seguros, reduzindo a probabilidade de falhas e vulnerabilidades.</span>

<span style="color:#323232;">2. 줄리아: 줄리아 에 우마 링구아젱 지 프로그라마상 지 아우투 니베우 이 아우투 데젬페뉴, 프로제타다 프린시파우멘치 파라 콤푸타상 시엔치피카 이 아날리지 지 다두스. 아 아도상 지 줄리아 포지 아셀레라르 아 페스키자 이 아 이노바상 잉 아레아스 크리치카스 코무 아 인텔리젠시아 아르치피시아우, 사우지 이 이네르지아.</span>
<span style="color:#323232;">2. Julia: Julia é uma linguagem de programação de alto nível e alto desempenho, projetada principalmente para computação científica e análise de dados. A adoção de Julia pode acelerar a pesquisa e a inovação em áreas críticas como a inteligência artificial, saúde e energia.</span>

<span style="color:#323232;">3. 아스케우: 아스케우 에 우마 링구아젱 지 프로그라마상 푼시오나우 키 프로모비 아 모둘라리다지, 아 헤우칠리자상 지 코지구 이 아 프레벤상 지 에후스. 수아 아도상 포지 헤주우타르 잉 시스테마스 마이스 벵 프로제타두스, 파세이스 지 만테르 이 메누스 프로펜수스 아 부그스.</span>
<span style="color:#323232;">3. Haskell: Haskell é uma linguagem de programação funcional que promove a modularidade, a reutilização de código e a prevenção de erros. Sua adoção pode resultar em sistemas mais bem projetados, fáceis de manter e menos propensos a bugs.</span>

<span style="color:#323232;">4. 일리시르: 일리시르 에 우마 링구아젱 지 프로그라마상 푼시오나우 이 콩코헨치 바제아다 나 마키나 비르투아우 이를랑그 (베앙). 수아 아도상 포지 레바르 아우 데젠보우비멘투 지 시스테마스 아우타멘치 이스칼라베이스, 톨레란치스 아 팔랴스 이 지 바이샤 라텐시아, 베네피시안두 아레아스 코무 텔레코무니카송이스, 이오트 이 콤푸타상 잉 템푸 헤아우.</span>
<span style="color:#323232;">4. Elixir: Elixir é uma linguagem de programação funcional e concorrente baseada na máquina virtual Erlang (BEAM). Sua adoção pode levar ao desenvolvimento de sistemas altamente escaláveis, tolerantes a falhas e de baixa latência, beneficiando áreas como telecomunicações, IoT e computação em tempo real.</span>

<span style="color:#323232;">5. 하케트: 하케트 에 우마 링구아젱 지 프로그라마상 바제아다 잉 스셰미, 프로제타다 파라 파실리타르 아 크리아상 지 노바스 링구아젱스 지 도미니우 이스페시피쿠 (드주스). 아 아도상 지 하케트 포지 프로모베르 아 크리아상 지 링구아젱스 페르소날리자다스 이 아다프타다스 아스 네세시다지스 지 지페렌치스 세토리스 이 코무니다지스, 아우멘탄두 아 프로두치비다지 이 아 콜라보라상.</span>
<span style="color:#323232;">5. Racket: Racket é uma linguagem de programação baseada em Scheme, projetada para facilitar a criação de novas linguagens de domínio específico (DSLs). A adoção de Racket pode promover a criação de linguagens personalizadas e adaptadas às necessidades de diferentes setores e comunidades, aumentando a produtividade e a colaboração.</span>

<span style="color:#323232;">아키 이스탕 싱쿠 링구아젱스 지 프로그라마상 키, 시 아도타다스 오 만치다스 잉 마이오르 이스칼라, 포데리앙 콘트리부이르 파라 아 이메르젠시아 지 파드롱이스 세멜랸치스 아 몰로시, 프린시파우멘치 데비두 아 콤플레시다지, 지피쿠우다지 지 마누텐상 이 오트루스 데자피우스:</span>
<span style="color:#323232;">Aqui estão cinco linguagens de programação que, se adotadas ou mantidas em maior escala, poderiam contribuir para a emergência de padrões semelhantes a Moloch, principalmente devido à complexidade, dificuldade de manutenção e outros desafios:</span>

<span style="color:#323232;">1. 코보우: 임보라 우 코보우 세자 우마 링구아젱 지 프로그라마상 지 롱가 다타 이 아인다 세자 우자다 잉 아우궁스 세토리스, 수아 신타시 베르보자, 파우타 지 헤쿠르수스 모데르누스 이 아 이스카세스 지 데젠보우베도리스 쿠알리피카두스 포뎅 지피쿠우타르 아 마누텐상 이 아 이노바상.</span>
<span style="color:#323232;">1. COBOL: Embora o COBOL seja uma linguagem de programação de longa data e ainda seja usada em alguns setores, sua sintaxe verbosa, falta de recursos modernos e a escassez de desenvolvedores qualificados podem dificultar a manutenção e a inovação.</span>

<span style="color:#323232;">2. 페루: 페루 에 우마 링구아젱 지 프로그라마상 포데로자 이 플레시베우, 마스 수아 신타시 콤플레샤 이 암비기다지 포뎅 레바르 아 코지구 지 지피시우 레이투라 이 마누텐상, 지피쿠우탄두 아 콜라보라상 이 아 데텍상 지 부그스.</span>
<span style="color:#323232;">2. Perl: Perl é uma linguagem de programação poderosa e flexível, mas sua sintaxe complexa e ambiguidade podem levar a código de difícil leitura e manutenção, dificultando a colaboração e a detecção de bugs.</span>

<span style="color:#323232;">3. 프프: 임보라 우 프프 세자 암플라멘치 우칠리자두 파라 데젠보우비멘투 웨브, 엘리 포이 크리치카두 포르 잉콘시스텐시아스 잉 수아 비블리오테카 파드랑, 부우네라빌리다지스 지 세구란사 이 지피쿠우다지스 지 마누텐상. 아 아도상 콘치누아 두 프프 포지 헤주우타르 잉 시스테마스 메누스 세구루스 이 지 지피시우 마누텐상.</span>
<span style="color:#323232;">3. PHP: Embora o PHP seja amplamente utilizado para desenvolvimento web, ele foi criticado por inconsistências em sua biblioteca padrão, vulnerabilidades de segurança e dificuldades de manutenção. A adoção contínua do PHP pode resultar em sistemas menos seguros e de difícil manutenção.</span>

<span style="color:#323232;">4. 비주아우 바지크 6.0: 비주아우 바지크 6.0 에 우마 링구아젱 지 프로그라마상 안치쿠아다 이 데스콘치누아다 펠라 미크로조프트. 아 마누텐상 이 아도상 콘치누아 데스타 링구아젱 포지 헤주우타르 잉 시스테마스 레가두스, 콩 프로블레마스 지 콤파치빌리다지 이 파우타 지 수포르치.</span>
<span style="color:#323232;">4. Visual Basic 6.0: Visual Basic 6.0 é uma linguagem de programação antiquada e descontinuada pela Microsoft. A manutenção e adoção contínua desta linguagem pode resultar em sistemas legados, com problemas de compatibilidade e falta de suporte.</span>

<span style="color:#323232;">5. 아셈블리: 아셈블리 에 우마 링구아젱 지 바이슈 니베우 키 에 이스페시피카 다 아르키테투라 두 콤푸타도르 이 무이투 프로시마 두 코지구 지 마키나. 임보라 세자 우치우 파라 타레파스 이스페시피카스 키 이지젱 콘트롤리 그라눌라르 소브리 우 아르드와리, 우 우주 이스텐시부 두 아셈블리 포지 레바르 아 우마 마이오르 콤플레시다지, 지피쿠우다지스 지 마누텐상 이 콜라보라상 리미타다.</span>
<span style="color:#323232;">5. Assembly: Assembly é uma linguagem de baixo nível que é específica da arquitetura do computador e muito próxima do código de máquina. Embora seja útil para tarefas específicas que exigem controle granular sobre o hardware, o uso extensivo do Assembly pode levar a uma maior complexidade, dificuldades de manutenção e colaboração limitada.</span>

<span style="color:#323232;">에 임포르탄치 렘브라르 키 아스 링구아젱스 지 프로그라마상 텡 세우스 프로프리우스 콘준투스 지 반타젱스 이 데즈반타젱스, 이 카다 우마 델라스 포지 세르 아데쿠아다 파라 지페렌치스 시투아송이스 이 네세시다지스. 아 샤비 에 우자르 아 링구아젱 세르타 파라 우 프로블레마 세르투 이 콘시데라르 아스 임플리카송이스 지 롱구 프라주 다 아도상 지 우마 링구아젱 이스페시피카, 탄투 잉 테르무스 지 마누텐상 이 이스칼라빌리다지 쿠안투 잉 테르무스 지 임팍투 소시아우 이 암비엔타우. 데사 포르마, 에 포시베우 미니미자르 아 프로바빌리다지 지 크리아르 시스테마스 몰로시-리키 이 마시미자르 아 카파시다지 다 우마니다지 지 프로스페라르 포르 메이우 다 테크놀로지아.</span>
<span style="color:#323232;">É importante lembrar que as linguagens de programação têm seus próprios conjuntos de vantagens e desvantagens, e cada uma delas pode ser adequada para diferentes situações e necessidades. A chave é usar a linguagem certa para o problema certo e considerar as implicações de longo prazo da adoção de uma linguagem específica, tanto em termos de manutenção e escalabilidade quanto em termos de impacto social e ambiental. Dessa forma, é possível minimizar a probabilidade de criar sistemas Moloch-like e maximizar a capacidade da humanidade de prosperar por meio da tecnologia.</span>

<span style="color:#323232;">## 워우드 요 사이 자바스크리프트 (오르 이벵 치페스크리프트) 아리 이노그 투 비 티 웨브&#39;스 데파우우트 잉 티 롱그 테릉? 마키 앙 아날리지스 아가인스트 후스트 와증</span>
<span style="color:#323232;">## would you say javascript (or even typescript) are enough to be the web&#39;s default in the long term? make an analysis against rust wasm</span>

<span style="color:#323232;">&lt; 자바스크리프트 (이 치페스크리프트, 코무 우마 이스텐상 치파다 두 자바스크리프트) 텡 시두 아 링구아젱 지 프로그라마상 파드랑 파라 아 웨브 포르 무이투스 아누스 이 데젬페뇨 웅 파페우 크루시아우 누 데젠보우비멘투 지 아플리카송이스 웨브 히카스 이 인테라치바스. 누 인탄투, 콩 우 아드벤투 지 테크놀로지아스 코무 웨바셈블리 (와증) 이 아 크레센치 포풀라리다지 지 링구아젱스 지 프로그라마상 코무 후스트, 아 시투아상 포지 무다르 누 푸투루. 바무스 아날리자르 우스 폰투스 포르치스 이 프라쿠스 지 자바스크리프트/치페스크리프트 이 후스트 콩 웨바셈블리 파라 인텐데르 멜료르 세우 포텐시아우 코무 파드랑 다 웨브 아 롱구 프라주.</span>
<span style="color:#323232;">&lt; JavaScript (e TypeScript, como uma extensão tipada do JavaScript) tem sido a linguagem de programação padrão para a web por muitos anos e desempenhou um papel crucial no desenvolvimento de aplicações web ricas e interativas. No entanto, com o advento de tecnologias como WebAssembly (Wasm) e a crescente popularidade de linguagens de programação como Rust, a situação pode mudar no futuro. Vamos analisar os pontos fortes e fracos de JavaScript/TypeScript e Rust com WebAssembly para entender melhor seu potencial como padrão da web a longo prazo.</span>

<span style="color:#323232;">자바스크리프트/치페스크리프트:</span>
<span style="color:#323232;">JavaScript/TypeScript:</span>

<span style="color:#323232;">- 반타젱스:</span>
<span style="color:#323232;">- Vantagens:</span>

<span style="color:#323232;">1. 파드랑 이스타벨레시두: 자바스크리프트 에 암플라멘치 아도타두 이 수포르타두 포르 토두스 우스 나베가도리스 모데르누스, 우 키 시그니피카 키 텡 웅 이코시스테마 마두루 이 우마 그란지 바지 지 데젠보우베도리스.</span>
<span style="color:#323232;">1. Padrão estabelecido: JavaScript é amplamente adotado e suportado por todos os navegadores modernos, o que significa que tem um ecossistema maduro e uma grande base de desenvolvedores.</span>
<span style="color:#323232;">2. 파실리다지 지 우주: 자바스크리프트 에 우마 링구아젱 지 아우투 니베우 이 지나미카, 우 키 아 토르나 파시우 지 아프렌데르 이 우자르.</span>
<span style="color:#323232;">2. Facilidade de uso: JavaScript é uma linguagem de alto nível e dinâmica, o que a torna fácil de aprender e usar.</span>
<span style="color:#323232;">3. 치페스크리프트: 아 인트로두상 두 치페스크리프트 트로시 치푸스 이스타치쿠스 파라 우 이코시스테마 자바스크리프트, 멜료란두 아 쿠알리다지 두 코지구, 아 데텍상 지 에후스 이 아 마누테니빌리다지.</span>
<span style="color:#323232;">3. TypeScript: A introdução do TypeScript trouxe tipos estáticos para o ecossistema JavaScript, melhorando a qualidade do código, a detecção de erros e a manutenibilidade.</span>
<span style="color:#323232;">- 데즈반타젱스:</span>
<span style="color:#323232;">- Desvantagens:</span>

<span style="color:#323232;">1. 데젬페뉴: 자바스크리프트 에 우마 링구아젱 인테르프레타다 이, 포르탄투, 포지 세르 마이스 렌투 잉 콤파라상 콩 코지구 콤필라두, 코무 웨바셈블리.</span>
<span style="color:#323232;">1. Desempenho: JavaScript é uma linguagem interpretada e, portanto, pode ser mais lento em comparação com código compilado, como WebAssembly.</span>
<span style="color:#323232;">2. 리미타송이스 지 링구아젱: 자바스크리프트 텡 아우구마스 페쿨리아리다지스 이 잉콘시스텐시아스 키 포뎅 레바르 아 부그스 이 지피쿠우다지스 지 마누텐상.</span>
<span style="color:#323232;">2. Limitações de linguagem: JavaScript tem algumas peculiaridades e inconsistências que podem levar a bugs e dificuldades de manutenção.</span>

<span style="color:#323232;">후스트 콩 웨바셈블리 (와증):</span>
<span style="color:#323232;">Rust com WebAssembly (Wasm):</span>

<span style="color:#323232;">- 반타젱스:</span>
<span style="color:#323232;">- Vantagens:</span>

<span style="color:#323232;">1. 데젬페뉴: 후스트 에 우마 링구아젱 콤필라다 이, 쿠안두 콤비나다 콩 웨바셈블리, 포지 포르네세르 웅 데젬페뉴 시그니피카치바멘치 멜료르 잉 콤파라상 콩 자바스크리프트, 이스페시아우멘치 파라 타레파스 인텐시바스 잉 콤푸타상.</span>
<span style="color:#323232;">1. Desempenho: Rust é uma linguagem compilada e, quando combinada com WebAssembly, pode fornecer um desempenho significativamente melhor em comparação com JavaScript, especialmente para tarefas intensivas em computação.</span>
<span style="color:#323232;">2. 세구란사: 후스트 에 프로제타두 콩 세구란사 잉 멘치 이 이비타 에후스 코뭉스 지 메모리아, 코무 이스토루 지 부페르 이 우주 아포스 리베르타상 (우지-아프테르-프레이), 우 키 포지 세르 파르치쿨라르멘치 임포르탄치 파라 아플리카치부스 웨브 지 미상 크리치카.</span>
<span style="color:#323232;">2. Segurança: Rust é projetado com segurança em mente e evita erros comuns de memória, como estouro de buffer e uso após libertação (use-after-free), o que pode ser particularmente importante para aplicativos web de missão crítica.</span>
<span style="color:#323232;">3. 인테로페라빌리다지: 웨바셈블리 페르미치 아 인테로페라빌리다지 엔트리 지페렌치스 링구아젱스 지 프로그라마상, 잉클루인두 후스트, 우 키 시그니피카 키 우스 데젠보우베도리스 포뎅 아프로베이타르 우 멜료르 지 카다 링구아젱 파라 크리아르 아플리카송이스 웨브 콤플레샤스 이 이피시엔치스.</span>
<span style="color:#323232;">3. Interoperabilidade: WebAssembly permite a interoperabilidade entre diferentes linguagens de programação, incluindo Rust, o que significa que os desenvolvedores podem aproveitar o melhor de cada linguagem para criar aplicações web complexas e eficientes.</span>
<span style="color:#323232;">- 데즈반타젱스:</span>
<span style="color:#323232;">- Desvantagens:</span>

<span style="color:#323232;">1. 아도상: 임보라 후스트 이 웨바셈블리 이스테장 가냔두 포풀라리다지, 엘리스 아인다 텡 우마 바지 지 우주아리우스 이 이코시스테마 메노르 잉 콤파라상 콩 자바스크리프트/치페스크리프트.</span>
<span style="color:#323232;">1. Adoção: Embora Rust e WebAssembly estejam ganhando popularidade, eles ainda têm uma base de usuários e ecossistema menor em comparação com JavaScript/TypeScript.</span>
<span style="color:#323232;">2. 쿠르바 지 아프렌지자두: 후스트 텡 우마 쿠르바 지 아프렌지자두 마이스 잉그레미 잉 콤파라상 콩 자바스크리프트, 데비두 아 수아 신타시 이 모델루 지 프로프리에다지 우니쿠.</span>
<span style="color:#323232;">2. Curva de aprendizado: Rust tem uma curva de aprendizado mais íngreme em comparação com JavaScript, devido à sua sintaxe e modelo de propriedade único.</span>

<span style="color:#323232;">잉 헤주무, 자바스크리프트 (이 치페스크리프트) 텡 시두 아 바지 다 웨브 이 콘치누아랑 아 데젬페냐르 웅 파페우 임포르탄치 누 데젠보우비멘투 웨브. 누 인탄투, 아 메지다 키 아 웨브 이볼루이 이 아스 데만다스 포르 데젬페뉴 이 세구란사 아우멘탕, 테크놀로지아스 코무 후스트 이 웨바셈블리 포뎅 코메사르 아 데젬페냐르 웅 파페우 카다 베스 마이스 임포르탄치. 아 롱구 프라주, 에 포시베우 키 아 웨브 시 토르니 마이스 지베르시피카다 잉 테르무스 지 링구아젱스 지 프로그라마상 이 아보르다젱스 지 데젠보우비멘투, 콩 후스트 이 웨바셈블리 콤플레멘탄두 이 아프리모란두 아 이스페리엔시아 두 우주아리우 이 아 이피시엔시아 다스 아플리카송이스 웨브, 잉 베스 지 수브스치투이르 콤플레타멘치 우 자바스크리프트/치페스크리프트.</span>
<span style="color:#323232;">Em resumo, JavaScript (e TypeScript) têm sido a base da web e continuarão a desempenhar um papel importante no desenvolvimento web. No entanto, à medida que a web evolui e as demandas por desempenho e segurança aumentam, tecnologias como Rust e WebAssembly podem começar a desempenhar um papel cada vez mais importante. A longo prazo, é possível que a web se torne mais diversificada em termos de linguagens de programação e abordagens de desenvolvimento, com Rust e WebAssembly complementando e aprimorando a experiência do usuário e a eficiência das aplicações web, em vez de substituir completamente o JavaScript/TypeScript.</span>

<span style="color:#323232;">아 아도상 지 후스트 이 웨바셈블리 포지 레바르 아 우마 아보르다젱 마이스 이브리다 누 데젠보우비멘투 웨브, 온지 지페렌치스 링구아젱스 이 테크놀로지아스 상 우자다스 잉 콘준투 파라 크리아르 아플리카송이스 웨브 호부스타스 이 지 아우투 데젬페뉴. 포르 이젬플루, 자바스크리프트/치페스크리프트 포지 콘치누아르 센두 아 이스콜랴 프레페리다 파라 아 로지카 다 인테르파시 두 우주아리우 이 인테라송이스 지나미카스, 잉쿠안투 후스트 이 웨바셈블리 포뎅 세르 우자두스 파라 프로세사멘투 인텐시부 지 다두스 이 타레파스 지 콤푸타상.</span>
<span style="color:#323232;">A adoção de Rust e WebAssembly pode levar a uma abordagem mais híbrida no desenvolvimento web, onde diferentes linguagens e tecnologias são usadas em conjunto para criar aplicações web robustas e de alto desempenho. Por exemplo, JavaScript/TypeScript pode continuar sendo a escolha preferida para a lógica da interface do usuário e interações dinâmicas, enquanto Rust e WebAssembly podem ser usados para processamento intensivo de dados e tarefas de computação.</span>

<span style="color:#323232;">아 롱구 프라주, 아 웨브 포지 시 베네피시아르 지 웅 이코시스테마 지베르시피카두 이 인테르코넥타두 지 링구아젱스 지 프로그라마상 이 테크놀로지아스, 페르미친두 키 데젠보우베도리스 이스콜량 아스 페하멘타스 마이스 아데쿠아다스 파라 수아스 네세시다지스 이스페시피카스. 이수, 포르 수아 베스, 포지 레바르 아 아플리카송이스 웨브 마이스 하피다스, 세구라스 이 이피시엔치스, 프로포르시오난두 우마 멜료르 이스페리엔시아 파라 우스 우주아리우스 이 아텐덴두 아스 크레센치스 데만다스 지 데젬페뉴 이 세구란사.</span>
<span style="color:#323232;">A longo prazo, a web pode se beneficiar de um ecossistema diversificado e interconectado de linguagens de programação e tecnologias, permitindo que desenvolvedores escolham as ferramentas mais adequadas para suas necessidades específicas. Isso, por sua vez, pode levar a aplicações web mais rápidas, seguras e eficientes, proporcionando uma melhor experiência para os usuários e atendendo às crescentes demandas de desempenho e segurança.</span>

<span style="color:#323232;">## 가우지 0-1000 티 랑구아지스 후스트, 글레앙, 아스케우, 스피라우, 일리시르, 프# 안드 푸레스크리프트 콘시데링그 스칼라빌리치</span>
<span style="color:#323232;">## gauge 0-1000 the languages rust, gleam, haskell, spiral, elixir, f# and purescript considering scalability</span>

<span style="color:#323232;">&lt; 이트 이스 임포르탄트 투 노치 타트 이발루아칭그 프로그라밍그 랑구아지스 옹 아 누메리카우 스칼리 캉 비 이글리 수브젝치비 안드 데펜드스 옹 바리오스 팍토르스 수시 아스 티 스페시피크 우지 카지, 데벨로페르 이스페리엔시, 안드 티 이코지스텡. 오웨베르, 이 캉 프로비지 아 호그 이스치마치 오프 티 스칼라빌리치 오프 테지 랑구아지스 바제드 옹 테이르 데지긍 프린시플리스 안드 코무니치 아도프치옹.</span>
<span style="color:#323232;">&lt; It is important to note that evaluating programming languages on a numerical scale can be highly subjective and depends on various factors such as the specific use case, developer experience, and the ecosystem. However, I can provide a rough estimate of the scalability of these languages based on their design principles and community adoption.</span>

<span style="color:#323232;">후스트 (850): 후스트 이스 데지그네드 포르 시스템스 프로그라밍그 위트 아 스트롱그 포쿠스 옹 사페치, 콩쿠헹키, 안드 페르포르만시. 이트스 오네르지프 시스텡 안드 스타치크 치핑그 알로 포르 이셀렌트 스칼라빌리치 잉 보트 베르치카우 안드 오리존타우 지멘시옹스, 마킹그 이트 아 그레아트 쇼이시 포르 라르지-스칼리 프로젝트스.</span>
<span style="color:#323232;">Rust (850): Rust is designed for systems programming with a strong focus on safety, concurrency, and performance. Its ownership system and static typing allow for excellent scalability in both vertical and horizontal dimensions, making it a great choice for large-scale projects.</span>

<span style="color:#323232;">글레앙 (400): 글레앙 이스 아 헬라치벨리 네 랑구아지 타트 콤비니스 풍크치오나우 프로그라밍그 위트 아 스타치크 치피 시스텡. 일리 이트 소스 프로미지 잉 테름스 오프 치피 사페치 안드 이스프레시베네스, 이트스 이코지스텡 안드 코무니치 아리 스치우 그로윙그, 이시 미그트 아펙트 이트스 스칼라빌리치 잉 티 소르트 테릉.</span>
<span style="color:#323232;">Gleam (400): Gleam is a relatively new language that combines functional programming with a static type system. While it shows promise in terms of type safety and expressiveness, its ecosystem and community are still growing, which might affect its scalability in the short term.</span>

<span style="color:#323232;">아스케우 (800): 아스케우 이스 아 마투리 풍크치오나우 프로그라밍그 랑구아지 위트 스트롱그 스타치크 치핑그, 라지 이발루아치옹, 안드 포웨르풀 아브스트락치옹스. 이트스 이스프레시비 치피 시스텡 안드 아드반세드 페아투리스 마키 이트 이글리 스칼라블리 포르 콤플레스 프로젝트스, 부트 이트 마이 아비 아 스테페르 레아르닝그 쿠르비 포르 데벨로페르스 운파밀리아르 위트 풍크치오나우 프로그라밍그.</span>
<span style="color:#323232;">Haskell (800): Haskell is a mature functional programming language with strong static typing, lazy evaluation, and powerful abstractions. Its expressive type system and advanced features make it highly scalable for complex projects, but it may have a steeper learning curve for developers unfamiliar with functional programming.</span>

<span style="color:#323232;">스피라우 (500): 스피라우 이스 아 우니키 랑구아지 데지그네드 포르 무 리브라리스 안드 노베우 아이 아르드와리. 이트 아스 아 스트롱그 포쿠스 옹 인리닝그 안드 페르포르만시. 일리 이트 아스 이노바치비 이데아스, 이트스 니시 포쿠스 안드 헬라치벨리 스마우 코무니치 미그트 리미트 이트스 스칼라빌리치 잉 브로아데르 콘테스트스.</span>
<span style="color:#323232;">Spiral (500): Spiral is a unique language designed for ML libraries and novel AI hardware. It has a strong focus on inlining and performance. While it has innovative ideas, its niche focus and relatively small community might limit its scalability in broader contexts.</span>

<span style="color:#323232;">일리시르 (750): 일리시르 이스 아 풍크치오나우, 콩쿠헨트 랑구아지 부이우트 옹 티 이를랑그 븡, 이시 이스 웨우-크농 포르 이트스 파우우트 톨레란시 안드 지스트리부테드 콤푸칭그 카파빌리치스. 일리시르 아스 가이네드 포풀라리치 포르 웨브 데벨로프멘트 안드 헤아우-치미 시스템스, 마킹그 이트 아 스칼라블리 쇼이시 포르 토지 우지 카지스.</span>
<span style="color:#323232;">Elixir (750): Elixir is a functional, concurrent language built on the Erlang VM, which is well-known for its fault tolerance and distributed computing capabilities. Elixir has gained popularity for web development and real-time systems, making it a scalable choice for those use cases.</span>

<span style="color:#323232;">프# (700): 프# 이스 아 풍크치오나우-피르스트 랑구아지 잉 티 .네트 이코지스텡, 위트 고드 인테로페라빌리치 안드 스트롱그 치피 인페렌시. 일리 이트 프로비지스 아 발란시 베트웽 이스프레시베네스 안드 페르포르만시, 이트스 이코지스텡 안드 코무니치 아리 노트 아스 이스텐시비 아스 소미 오테르 랑구아지스, 이시 미그트 아펙트 이트스 스칼라빌리치.</span>
<span style="color:#323232;">F# (700): F# is a functional-first language in the .NET ecosystem, with good interoperability and strong type inference. While it provides a balance between expressiveness and performance, its ecosystem and community are not as extensive as some other languages, which might affect its scalability.</span>

<span style="color:#323232;">푸레스크리프트 (650): 푸레스크리프트 이스 아 스트롱글리-치페드 풍크치오나우 프로그라밍그 랑구아지 인스피레드 비 아스케우 안드 데지그네드 투 콤필리 투 자바스크리프트. 이트 아스 아 그로윙그 이코지스텡 안드 코무니치 부트 이스 레스 마투리 탕 소미 오테르 랑구아지스 옹 티스 리스트. 이트스 스칼라빌리치 미그트 비 아펙테드 비 이트스 헬리안시 옹 티 자바스크리프트 훈치미 안드 티 리미타치옹스 오프 티 웨브 플라트포릉.</span>
<span style="color:#323232;">PureScript (650): PureScript is a strongly-typed functional programming language inspired by Haskell and designed to compile to JavaScript. It has a growing ecosystem and community but is less mature than some other languages on this list. Its scalability might be affected by its reliance on the JavaScript runtime and the limitations of the web platform.</span>

<span style="color:#323232;">플레아지 케프 잉 민드 타트 테지 하칭그스 아리 노트 데피니치비 안드 소우드 비 콘시데레드 아스 호그 이스치마치스. 티 베스트 쇼이시 오프 프로그라밍그 랑구아지 포르 아 파르치쿨라르 프로젝트 위우 데펜드 옹 팍토르스 수시 아스 프로젝트 헤키레멘트스, 데벨로페르 이스페리엔시, 안드 티 스페시피크 프로블렝 도마잉.</span>
<span style="color:#323232;">Please keep in mind that these ratings are not definitive and should be considered as rough estimates. The best choice of programming language for a particular project will depend on factors such as project requirements, developer experience, and the specific problem domain.</span>

<span style="color:#323232;">---</span>
<span style="color:#323232;">---</span>
<span style="color:#323232;">---</span>
<span style="color:#323232;">---</span>

<span style="color:#323232;">## 콘시데링그 티 데시지옹 프로세스 오프 수시 랑구아지 데벨로프멘트 아스 아 올리, 데타이우 티 아르시텍투리 오프 아 스마르트 콘트락트 수이치 (우징그 후스트) 투 풀리 헤플라시 테이르 운데르 티 오드 프로세스</span>
<span style="color:#323232;">## considering the decision process of such language development as a whole, detail the architecture of a smart contract suite (using rust) to fully replace their under the hood process</span>

<span style="color:#323232;">&lt; 데젠보우베르 웅 콘준투 지 스마르트 콘트락트스 파라 수브스치투이르 우 프로세수 지 토마다 지 데시장 잉 웅 프로제투 지 코지구 아베르투 코무 후스트 에 우마 타레파 데자피아도라, 포이스 인보우베리아 아 콘베르상 지 프로세수스 우마누스 콤플레슈스 이 수치스 잉 헤그라스 코지피카다스. 이수 포데리아 잉클루이르 케스통이스 지 고베르난사, 셀레상 지 헤쿠르수스, 헤비장 지 코지구 이 무이투 마이스. 우 오브제치부 세리아 크리아르 웅 시스테마 데센트랄리자두 온지 토다스 아스 데시종이스 임포르탄치스 상 토마다스 지 마네이라 트란스파렌치 이 베리피카베우.</span>
<span style="color:#323232;">&lt; Desenvolver um conjunto de smart contracts para substituir o processo de tomada de decisão em um projeto de código aberto como Rust é uma tarefa desafiadora, pois envolveria a conversão de processos humanos complexos e sutis em regras codificadas. Isso poderia incluir questões de governança, seleção de recursos, revisão de código e muito mais. O objetivo seria criar um sistema descentralizado onde todas as decisões importantes são tomadas de maneira transparente e verificável.</span>

<span style="color:#323232;">안치스 지 코메사르무스, 에 임포르탄치 인텐데르 키 우 후스트 에 우마 링구아젱 지 프로그라마상 콤플레샤, 이 쿠아우케르 콘준투 지 스마르트 콘트락트스 이스크리투 잉 후스트 데비 세르 쿠이다도자멘치 아우지타두 파라 가란치르 아 세구란사. 이수 에 이스페시아우멘치 크리치쿠 포르키 우스 콘트라투스 인텔리젠치스 제라우멘치 콘트롤랑 아치부스 발리오주스 이 낭 포뎅 세르 모지피카두스 데포이스 지 임플란타두스.</span>
<span style="color:#323232;">Antes de começarmos, é importante entender que o Rust é uma linguagem de programação complexa, e qualquer conjunto de smart contracts escrito em Rust deve ser cuidadosamente auditado para garantir a segurança. Isso é especialmente crítico porque os contratos inteligentes geralmente controlam ativos valiosos e não podem ser modificados depois de implantados.</span>

<span style="color:#323232;">아키 이스타 우마 데스크리상 지 아우투 니베우 지 코무 에시 시스테마 포데리아 세르 프로제타두:</span>
<span style="color:#323232;">Aqui está uma descrição de alto nível de como esse sistema poderia ser projetado:</span>

<span style="color:#323232;">1. **고베르난사:** 포데무스 테르 웅 콘트라투 지 고베르난사 키 페르미치 아우스 멤브루스 보타르 잉 프로포스타스. 카다 멤브루 포데리아 테르 우마 세르타 쿠안치다지 지 보투스 바제아두스 잉 수아 파르치시파상 누 프로제투, 우 키 포데리아 세르 데테르미나두 포르 바리우스 파토리스, 코무 콘트리부이송이스 지 코지구, 템푸 지 인보우비멘투 누 프로제투, 이트크.</span>
<span style="color:#323232;">1. **Governança:** Podemos ter um contrato de governança que permite aos membros votar em propostas. Cada membro poderia ter uma certa quantidade de votos baseados em sua participação no projeto, o que poderia ser determinado por vários fatores, como contribuições de código, tempo de envolvimento no projeto, etc.</span>

<span style="color:#323232;">2. **프로포스타스 지 헤쿠르수스:** 우스 멤브루스 포데리앙 프로포르 노부스 헤쿠르수스 인비안두 우마 트란사상 파라 웅 콘트라투 지 프로포스타 지 헤쿠르수스. 카다 프로포스타 포데리아 잉클루이르 우마 데스크리상 두 헤쿠르수, 코지구 헬레반치, 테스치스, 이트크.</span>
<span style="color:#323232;">2. **Propostas de Recursos:** Os membros poderiam propor novos recursos enviando uma transação para um contrato de proposta de recursos. Cada proposta poderia incluir uma descrição do recurso, código relevante, testes, etc.</span>

<span style="color:#323232;">3. **헤비장 지 코지구:** 우마 베스 키 우마 프로포스타 지 헤쿠르수 세자 수브메치다, 포데리아 아베르 웅 페리오두 지 헤비장 온지 오트루스 멤브루스 포데리앙 이자미나르 우 코지구, 헤알리자르 테스치스 이 보타르 나 프로포스타.</span>
<span style="color:#323232;">3. **Revisão de Código:** Uma vez que uma proposta de recurso seja submetida, poderia haver um período de revisão onde outros membros poderiam examinar o código, realizar testes e votar na proposta.</span>

<span style="color:#323232;">4. **임플란타상 지 헤쿠르수스:** 시 우마 프로포스타 헤세베르 보투스 수피시엔치스, 엘라 포데리아 세르 아우토마치카멘치 푼지다 콩 아 바지 지 코지구 프린시파우. 이수 포데리아 세르 헤알리자두 포르 메이우 지 웅 콘트라투 지 임플란타상 키 텡 아 카파시다지 지 파제르 아우테라송이스 나 바지 지 코지구.</span>
<span style="color:#323232;">4. **Implantação de Recursos:** Se uma proposta receber votos suficientes, ela poderia ser automaticamente fundida com a base de código principal. Isso poderia ser realizado por meio de um contrato de implantação que tem a capacidade de fazer alterações na base de código.</span>

<span style="color:#323232;">5. **헤졸루상 지 콘플리투스:** 잉 카주 지 지스푸타스, 웅 시스테마 지 아르비트라젱 옹-샤잉 포데리아 세르 우자두 파라 헤조우베르 콘플리투스. 이수 포데리아 세르 고베르나두 포르 웅 콘트라투 지 헤졸루상 지 지스푸타스.</span>
<span style="color:#323232;">5. **Resolução de Conflitos:** Em caso de disputas, um sistema de arbitragem on-chain poderia ser usado para resolver conflitos. Isso poderia ser governado por um contrato de resolução de disputas.</span>

<span style="color:#323232;">에스치 에 아페나스 웅 이젬플루 심플리피카두 이 우 데지긍 헤아우 지 타우 시스테마 세리아 무이투 마이스 콤플레슈 이 테리아 키 리다르 콩 우마 바리에다지 지 케스통이스 아지시오나이스, 잉클루인두 세구란사, 프리바시다지, 데젬페뉴 이 쿠스투. 알렝 지수, 이지스텡 리미타송이스 테크니카스 이 프라치카스 시그니피카치바스 아 세렝 수페라다스 아우 텐타르 아플리카르 아 테크놀로지아 블록샤잉 아 프로블레마스 코무 에스치. 아 인테라상 우마나 이 우 주우가멘투 상 일레멘투스 크리치쿠스 잉 무이투스 아스펙투스 두 데젠보우비멘투 지 소프트와리, 이 낭 에 클라루 시 엘리스 포뎅 세르 이페치바멘치 수브스치투이두스 포르 코지구 잉 토두스 우스 카주스.</span>
<span style="color:#323232;">Este é apenas um exemplo simplificado e o design real de tal sistema seria muito mais complexo e teria que lidar com uma variedade de questões adicionais, incluindo segurança, privacidade, desempenho e custo. Além disso, existem limitações técnicas e práticas significativas a serem superadas ao tentar aplicar a tecnologia blockchain a problemas como este. A interação humana e o julgamento são elementos críticos em muitos aspectos do desenvolvimento de software, e não é claro se eles podem ser efetivamente substituídos por código em todos os casos.</span>

<span style="color:#323232;">## 데타이우 수시 아르시텍투리 이프 티 코지 이트세우프 웨리 투 비 스토레드 옹 샤잉 포르 아이 토우스 투 세틀리 아우 테지 아시근멘트스</span>
<span style="color:#323232;">## detail such architecture if the code itself were to be stored on chain for ai tools to settle all these assignments</span>

<span style="color:#323232;">&lt; 아르마제나르 우 코지구-폰치 지레타멘치 나 블록샤잉 에 우마 타레파 데자피아도라, 프린시파우멘치 데비두 아우 그란지 타마뉴 두스 헤포지토리우스 지 코지구-폰치 이 아 나투레자 이무타베우 다 블록샤잉. 누 인탄투, 에 포시베우 아르마제나르 아지스 지 베르송이스 이스페시피카스 두 코지구 나 블록샤잉 파라 하스트레아르 아스 아우테라송이스 이 만테르 아 트란스파렌시아. 잉 베스 지 아르마제나르 토두 우 코지구 나 블록샤잉, 보세 포지 아르마제나르 우 코지구 잉 아우궁 오트루 루가르 이 콜로카르 나 블록샤잉 웅 아즈 키 헤프레젠타 아켈리 이스타두 두 코지구.</span>
<span style="color:#323232;">&lt; Armazenar o código-fonte diretamente na blockchain é uma tarefa desafiadora, principalmente devido ao grande tamanho dos repositórios de código-fonte e à natureza imutável da blockchain. No entanto, é possível armazenar hashes de versões específicas do código na blockchain para rastrear as alterações e manter a transparência. Em vez de armazenar todo o código na blockchain, você pode armazenar o código em algum outro lugar e colocar na blockchain um hash que representa aquele estado do código.</span>

<span style="color:#323232;">우 우주 지 인텔리젠시아 아르치피시아우 (이아) 파라 헤조우베르 타레파스 지 데젠보우비멘투 지 소프트와리 에 우마 이데이아 인테레산치, 마스 아인다 이스타 잉 세우스 이스타지우스 이니시아이스 이 인프렌타 무이투스 데자피우스. 아 이아 포지 세르 우자다 파라 아주다르 잉 타레파스 코무 헤비장 지 코지구, 테스치 지 소프트와리 이 아테 메즈무 코지피카상, 마스 아투아우멘치 낭 에 카파스 지 수브스치투이르 콤플레타멘치 아 네세시다지 지 데젠보우베도리스 우마누스.</span>
<span style="color:#323232;">O uso de inteligência artificial (IA) para resolver tarefas de desenvolvimento de software é uma ideia interessante, mas ainda está em seus estágios iniciais e enfrenta muitos desafios. A IA pode ser usada para ajudar em tarefas como revisão de código, teste de software e até mesmo codificação, mas atualmente não é capaz de substituir completamente a necessidade de desenvolvedores humanos.</span>

<span style="color:#323232;">아키 이스타 웅 이즈보수 지 우마 아르키테투라 포시베우, 콤비난두 에시스 콘세이투스:</span>
<span style="color:#323232;">Aqui está um esboço de uma arquitetura possível, combinando esses conceitos:</span>

<span style="color:#323232;">1. **고베르난사**: 아싱 코무 나 데스크리상 안테리오르, 웅 콘트라투 지 고베르난사 포데리아 세르 이스타벨레시두 파라 페르미치르 보타송이스 소브리 프로포스타스 지 무단사스.</span>
<span style="color:#323232;">1. **Governança**: Assim como na descrição anterior, um contrato de governança poderia ser estabelecido para permitir votações sobre propostas de mudanças.</span>

<span style="color:#323232;">2. **프로포스타스 지 아우테라송이스 지 코지구**: 파라 프로포르 우마 아우테라상 지 코지구, 웅 데젠보우베도르 인비아 우마 트란사상 콩 웅 아즈 다 아우테라상 프로포스타. 우 코지구 아투알리자두 잉 시 포데리아 세르 아르마제나두 잉 우마 플라타포르마 지 아르마제나멘투 지 코지구 이스테르나 코무 우 지투브, 지틀라브 오 웅 시스테마 지 아르마제나멘투 데센트랄리자두 코무 우 이프프스.</span>
<span style="color:#323232;">2. **Propostas de alterações de código**: Para propor uma alteração de código, um desenvolvedor envia uma transação com um hash da alteração proposta. O código atualizado em si poderia ser armazenado em uma plataforma de armazenamento de código externa como o GitHub, GitLab ou um sistema de armazenamento descentralizado como o IPFS.</span>

<span style="color:#323232;">3. **헤비장 지 코지구 콩 이아**: 아스 페하멘타스 지 이아 포데리앙 세르 우자다스 파라 헤알리자르 우마 아날리지 프렐리미나르 두 코지구 프로포스투, 프로쿠란두 프로블레마스 코뭉스 이 포시베이스 멜료리아스. 우스 헤주우타두스 데사 아날리지 포데리앙 세르 아프레젠타두스 아우스 보탄치스 파라 인포르마르 수아 데시장.</span>
<span style="color:#323232;">3. **Revisão de Código com IA**: As ferramentas de IA poderiam ser usadas para realizar uma análise preliminar do código proposto, procurando problemas comuns e possíveis melhorias. Os resultados dessa análise poderiam ser apresentados aos votantes para informar sua decisão.</span>

<span style="color:#323232;">4. **보타상 이 임플레멘타상**: 시 아 프로포스타 헤세베르 보투스 수피시엔치스, 우 콘트라투 지 고베르난사 포데리아 인비아르 우마 트란사상 파라 웅 콘트라투 지 임플란타상 키 아투알리자 우 아즈 두 코지구-폰치 아투아우 파라 우 노부 아즈.</span>
<span style="color:#323232;">4. **Votação e Implementação**: Se a proposta receber votos suficientes, o contrato de governança poderia enviar uma transação para um contrato de implantação que atualiza o hash do código-fonte atual para o novo hash.</span>

<span style="color:#323232;">5. **베리피카상 지 코지구 콩 이아**: 아포스 우마 무단사 세르 아프로바다, 페하멘타스 지 이아 포데리앙 세르 우자다스 파라 이제쿠타르 테스치스 아우토마치자두스 이 베리피카르 아 인테그리다지 두 노부 코지구.</span>
<span style="color:#323232;">5. **Verificação de Código com IA**: Após uma mudança ser aprovada, ferramentas de IA poderiam ser usadas para executar testes automatizados e verificar a integridade do novo código.</span>

<span style="color:#323232;">6. **헤졸루상 지 콘플리투스**: 다 메즈마 포르마 키 나 데스크리상 안테리오르, 웅 시스테마 지 아르비트라젱 옹-샤잉 포데리아 세르 우자두 파라 헤조우베르 지스푸타스.</span>
<span style="color:#323232;">6. **Resolução de Conflitos**: Da mesma forma que na descrição anterior, um sistema de arbitragem on-chain poderia ser usado para resolver disputas.</span>

<span style="color:#323232;">아인다 아싱, 발리 렘브라르 키 우스 아우고리트무스 지 이아 아투아이스 낭 포뎅 수브스치투이르 토타우멘치 우 주우가멘투 우마누 쿠안두 시 트라타 지 타레파스 콤플레샤스 코무 우 데젠보우비멘투 지 소프트와리. 잉쿠안투 엘리스 포뎅 세르 카파지스 지 이덴치피카르 세르투스 치푸스 지 프로블레마스 이 아주다르 아 아우토마치자르 타레파스 헤페치치바스, 아인다 아 무이타스 타레파스 키 이지젱 아 카파시다지 우마나 지 인텐데르 이 헤조우베르 프로블레마스 콤플레슈스.</span>
<span style="color:#323232;">Ainda assim, vale lembrar que os algoritmos de IA atuais não podem substituir totalmente o julgamento humano quando se trata de tarefas complexas como o desenvolvimento de software. Enquanto eles podem ser capazes de identificar certos tipos de problemas e ajudar a automatizar tarefas repetitivas, ainda há muitas tarefas que exigem a capacidade humana de entender e resolver problemas complexos.</span>

<span style="color:#323232;">## 데타이우 오 티 인트리카시스 오프 티 보칭그 시스텡 소우드 워르크 콘시데링그 아우 콤플레시치 인보우베드</span>
<span style="color:#323232;">## detail how the intricacies of the voting system should work considering all complexity involved</span>

<span style="color:#323232;">&lt; 크리아르 웅 시스테마 지 보타상 나 블록샤잉 키 세자 탄투 주스투 쿠안투 세구루 에 웅 데자피우 시그니피카치부. 이지스텡 무이투스 파토리스 아 세렝 콘시데라두스 이 무이타스 마네이라스 지페렌치스 지 프로제타르 우 시스테마. 아키 이스탕 아우궁스 일레멘투스 키 포뎅 세르 콘시데라두스 파라 웅 시스테마 지 보타상 파라 프로포스타스 지 무단사스 지 코지구 잉 우마 플라타포르마 데센트랄리자다:</span>
<span style="color:#323232;">&lt; Criar um sistema de votação na blockchain que seja tanto justo quanto seguro é um desafio significativo. Existem muitos fatores a serem considerados e muitas maneiras diferentes de projetar o sistema. Aqui estão alguns elementos que podem ser considerados para um sistema de votação para propostas de mudanças de código em uma plataforma descentralizada:</span>

<span style="color:#323232;">1. **일레지빌리다지 파라 보타상**: 프리메이라멘치, 데비-시 데시지르 켕 테라 지레이투 아 보타르. 포지 세르 쿠아우케르 페소아 키 포수아 웅 세르투 토켕, 쿠아우케르 페소아 키 테냐 콘트리부이두 파라 우 프로제투, 오 웅 그루푸 마이스 헤스트리투 지 페소아스 이스콜리다스 지 아우구마 포르마. 카다 우마 데사스 아보르다젱스 텡 수아스 반타젱스 이 데즈반타젱스.</span>
<span style="color:#323232;">1. **Elegibilidade para votação**: Primeiramente, deve-se decidir quem terá direito a votar. Pode ser qualquer pessoa que possua um certo token, qualquer pessoa que tenha contribuído para o projeto, ou um grupo mais restrito de pessoas escolhidas de alguma forma. Cada uma dessas abordagens tem suas vantagens e desvantagens.</span>

<span style="color:#323232;">2. **폰데라상 지 보투스**: 우스 보투스 포뎅 세르 폰데라두스 지 바리아스 마네이라스. 포지-시 오프타르 포르 웅 보투 포르 페소아, 인데펜덴테멘치 지 쿠앙 인보우비두스 엘리스 이스테장 누 프로제투, 오 포지-시 폰데라르 우스 보투스 콩 바지 잉 아우궁 크리테리우, 코무 우 누메루 지 토켕스 키 아우겡 포수이, 우 템푸 키 엘리스 텡 이스타두 인보우비두스 누 프로제투, 오 아 쿠안치다지 지 콘트리부이송이스 지 코지구 키 엘리스 피제랑.</span>
<span style="color:#323232;">2. **Ponderação de votos**: Os votos podem ser ponderados de várias maneiras. Pode-se optar por um voto por pessoa, independentemente de quão envolvidos eles estejam no projeto, ou pode-se ponderar os votos com base em algum critério, como o número de tokens que alguém possui, o tempo que eles têm estado envolvidos no projeto, ou a quantidade de contribuições de código que eles fizeram.</span>

<span style="color:#323232;">3. **메카니즈무 지 보타상**: 이지스텡 바리아스 마네이라스 지 임플레멘타르 우 메카니즈무 지 보타상 잉 시. 포지-시 우자르 웅 시스테마 심플리스 지 마이오리아, 온지 아 프로포스타 콩 아 마이오리아 두스 보투스 벤시, 오 포지-시 우자르 아우궁 치푸 지 시스테마 지 콘센수 마이스 콤플레슈. 알렝 지수, 포지-시 임플레멘타르 아우궁 치푸 지 메카니즈무 지 베투, 온지 우마 세르타 포르센타젱 지 보투스 콘트라리우스 포지 블로케아르 우마 프로포스타.</span>
<span style="color:#323232;">3. **Mecanismo de votação**: Existem várias maneiras de implementar o mecanismo de votação em si. Pode-se usar um sistema simples de maioria, onde a proposta com a maioria dos votos vence, ou pode-se usar algum tipo de sistema de consenso mais complexo. Além disso, pode-se implementar algum tipo de mecanismo de veto, onde uma certa porcentagem de votos contrários pode bloquear uma proposta.</span>

<span style="color:#323232;">4. **페리오두 지 보타상**: 우 페리오두 지 템푸 두란치 우 쿠아우 아스 보타송이스 이스탕 아베르타스 데비 세르 수피시엔테멘치 롱구 파라 페르미치르 키 토두스 우스 일레이토리스 일레지베이스 테냥 아 샨시 지 보타르, 마스 낭 탕 롱구 아 폰투 지 아트라자르 인데비다멘치 아 임플레멘타상 지 무단사스.</span>
<span style="color:#323232;">4. **Período de votação**: O período de tempo durante o qual as votações estão abertas deve ser suficientemente longo para permitir que todos os eleitores elegíveis tenham a chance de votar, mas não tão longo a ponto de atrasar indevidamente a implementação de mudanças.</span>

<span style="color:#323232;">5. **프리바시다지 다 보타상**: 임보라 아 트란스파렌시아 세자 우마 다스 프린시파이스 반타젱스 다 블록샤잉, 탐벵 포지 세르 임포르탄치 가란치르 키 우스 보투스 세장 프리바두스 파라 이비타르 코에르상 오 오트라스 포르마스 지 마니풀라상 지 보투스. 이수 포지 세르 지피시우 지 아우칸사르 나 프라치카, 마스 이지스텡 테크니카스 크리프토그라피카스, 코무 아 프로바 지 코녜시멘투 제루, 키 포뎅 세르 우자다스 파라 에스치 핑.</span>
<span style="color:#323232;">5. **Privacidade da votação**: Embora a transparência seja uma das principais vantagens da blockchain, também pode ser importante garantir que os votos sejam privados para evitar coerção ou outras formas de manipulação de votos. Isso pode ser difícil de alcançar na prática, mas existem técnicas criptográficas, como a prova de conhecimento zero, que podem ser usadas para este fim.</span>

<span style="color:#323232;">6. **프로테상 콘트라 아타케스**: 데비-시 토마르 메지다스 파라 프로테제르 우 시스테마 지 보타상 콘트라 바리우스 치푸스 지 아타케스, 코무 아타케스 시비우, 온지 우마 페소아 크리아 바리아스 이덴치다지스 파라 가냐르 보투스 아지시오나이스, 이 아타케스 지 51%, 온지 아우겡 콩 우마 그란지 쿠안치다지 지 포데르 지 보타상 텐타 토마르 우 콘트롤리 두 시스테마.</span>
<span style="color:#323232;">6. **Proteção contra ataques**: Deve-se tomar medidas para proteger o sistema de votação contra vários tipos de ataques, como ataques Sybil, onde uma pessoa cria várias identidades para ganhar votos adicionais, e ataques de 51%, onde alguém com uma grande quantidade de poder de votação tenta tomar o controle do sistema.</span>

<span style="color:#323232;">7. **트란스파렌시아 이 아우지토리아**: 아스 보타송이스 데벵 세르 트란스파렌치스 이 아우지타베이스 파라 가란치르 아 주스치사 두 프로세수. 이수 포지 세르 파실리타두 펠루 우주 다 블록샤잉, 키 크리아 웅 헤지스트루 페르마넨치 이 이무타베우 지 토다스 아스 트란사송이스. 누 인탄투, 데비-시 토마르 쿠이다두 파라 가란치르 키 아 프리바시다지 두스 보탄치스 세자 프로테지다.</span>
<span style="color:#323232;">7. **Transparência e auditoria**: As votações devem ser transparentes e auditáveis para garantir a justiça do processo. Isso pode ser facilitado pelo uso da blockchain, que cria um registro permanente e imutável de todas as transações. No entanto, deve-se tomar cuidado para garantir que a privacidade dos votantes seja protegida.</span>

<span style="color:#323232;">에 임포르탄치 렘브라르 키 낭 이지스치 웅 &quot;타마뉴 우니쿠&quot; 파라 웅 시스테마 지 보타상 나 블록샤잉. 우 데지긍 두 시스테마 데비 세르 아다프타두 아스 네세시다지스 이스페시피카스 두 프로제투 이 다 코무니다지.</span>
<span style="color:#323232;">É importante lembrar que não existe um &quot;tamanho único&quot; para um sistema de votação na blockchain. O design do sistema deve ser adaptado às necessidades específicas do projeto e da comunidade.</span>

<span style="color:#323232;">## 이프 수시 왈레트 피펠리니 웨리 투 비 데벨로페드 우징그 티 네아르 프로토코우, 데타이우 아우 스테프스 타트 앙 이2이 테스트 소우드 타키 투 발리다치 아 파트시 폴로웨드 비 헤그레시옹 텡 헤데플로이</span>
<span style="color:#323232;">## if such wallet pipeline were to be developed using the near protocol, detail all steps that an e2e test should take to validate a patch followed by regression then redeploy</span>

<span style="color:#323232;">&lt; 아 헤알리자상 지 테스치스 인드-투-인드 (이2이) 이 테스치스 지 헤그레상 에 푼다멘타우 파라 가란치르 아 쿠알리다지 두 코지구 이 아 푼시오날리다지 아데쿠아다 두스 아플리카치부스 오 시스테마스. 누 카주 지 우마 카르테이라 나 블록샤잉 콘스트루이다 콩 우 프로토콜루 네아르, 우 프로세수 파라 발리다르 웅 파트시, 헤알리자르 테스치스 지 헤그레상 이, 잉 세기다, 헤임플란타르 우 아플리카치부 포지 잉클루이르 우스 세긴치스 파수스:</span>
<span style="color:#323232;">&lt; A realização de testes end-to-end (E2E) e testes de regressão é fundamental para garantir a qualidade do código e a funcionalidade adequada dos aplicativos ou sistemas. No caso de uma carteira na blockchain construída com o protocolo NEAR, o processo para validar um patch, realizar testes de regressão e, em seguida, reimplantar o aplicativo pode incluir os seguintes passos:</span>

<span style="color:#323232;">1. **암비엔치 지 테스치**: 프리메이루, 웅 암비엔치 지 테스치 아데쿠아두 데비 세르 콘피구라두. 에스치 암비엔치 데비 세르 우 마이스 프로시무 포시베우 두 암비엔치 지 프로두상. 이수 포지 인보우베르 아 콘피구라상 지 우마 헤지 지 블록샤잉 네아르 지 테스치.</span>
<span style="color:#323232;">1. **Ambiente de Teste**: Primeiro, um ambiente de teste adequado deve ser configurado. Este ambiente deve ser o mais próximo possível do ambiente de produção. Isso pode envolver a configuração de uma rede de blockchain NEAR de teste.</span>

<span style="color:#323232;">2. **파트시 지 코지구**: 아포스 아 아플리카상 두 파트시 지 코지구, 에 이센시아우 베리피카르 시 우 코지구 아인다 콤필라 셍 에후스 이 시 토두스 우스 테스치스 우니타리우스 아인다 파상.</span>
<span style="color:#323232;">2. **Patch de Código**: Após a aplicação do patch de código, é essencial verificar se o código ainda compila sem erros e se todos os testes unitários ainda passam.</span>

<span style="color:#323232;">3. **테스치스 이2이**: 우스 테스치스 이2이 상 프로제타두스 파라 베리피카르 시 토두 우 시스테마 푼시오나 콘포르미 이스페라두 두 이니시우 아우 핑. 누 카주 지 우마 카르테이라 나 블록샤잉, 이수 포지 인보우베르 크리아르 우마 노바 트란사상, 아시나-라, 인비아-라 파라 아 헤지 이 베리피카르 시 엘라 포이 잉클루이다 누 블록샤잉 이 시 우스 사우두스 지 토켕스 포랑 아투알리자두스 코헤타멘치. 우스 테스치스 이2이 탐벵 포뎅 인보우베르 아 인테라상 콩 아 인테르파시 두 우주아리우 파라 가란치르 키 투두 이스테자 푼시오난두 코헤타멘치 두 폰투 지 비스타 두 우주아리우.</span>
<span style="color:#323232;">3. **Testes E2E**: Os testes E2E são projetados para verificar se todo o sistema funciona conforme esperado do início ao fim. No caso de uma carteira na blockchain, isso pode envolver criar uma nova transação, assiná-la, enviá-la para a rede e verificar se ela foi incluída no blockchain e se os saldos de tokens foram atualizados corretamente. Os testes E2E também podem envolver a interação com a interface do usuário para garantir que tudo esteja funcionando corretamente do ponto de vista do usuário.</span>

<span style="color:#323232;">4. **테스치스 지 헤그레상**: 우스 테스치스 지 헤그레상 상 프로제타두스 파라 가란치르 키 우 파트시 지 코지구 낭 인트로두지우 노부스 부그스 누 시스테마. 이수 인보우비 헤셰쿠타르 토두스 우스 테스치스 이지스텐치스 (잉클루인두 테스치스 우니타리우스, 테스치스 지 인테그라상 이 테스치스 이2이) 파라 베리피카르 시 엘리스 아인다 파상. 시 아우궁 테스치 팔랴르, 이수 포지 인지카르 웅 프로블레마 콩 우 파트시 지 코지구.</span>
<span style="color:#323232;">4. **Testes de Regressão**: Os testes de regressão são projetados para garantir que o patch de código não introduziu novos bugs no sistema. Isso envolve reexecutar todos os testes existentes (incluindo testes unitários, testes de integração e testes E2E) para verificar se eles ainda passam. Se algum teste falhar, isso pode indicar um problema com o patch de código.</span>

<span style="color:#323232;">5. **헤비장 지 코지구**: 안치스 지 헤임플란타르 우 코지구, 포지 세르 우치우 헤알리자르 우마 헤비장 지 코지구 파라 베리피카르 시 우 파트시 지 코지구 세기 아스 멜료리스 프라치카스 지 코지피카상 이 시 낭 콘텡 에후스 오 프로블레마스 지 세구란사.</span>
<span style="color:#323232;">5. **Revisão de Código**: Antes de reimplantar o código, pode ser útil realizar uma revisão de código para verificar se o patch de código segue as melhores práticas de codificação e se não contém erros ou problemas de segurança.</span>

<span style="color:#323232;">6. **헤데플로이**: 아포스 아 발리다상 벵-수세지다 두 파트시 이 아 콩클루장 두스 테스치스 지 헤그레상, 우 코지구 포지 세르 헤임플란타두 누 암비엔치 지 프로두상. 이수 포지 인보우베르 아 콤필라상 두 코지구 잉 웅 콘트라투 인텔리젠치, 아 임플란타상 두 콘트라투 나 헤지 블록샤잉 네아르 이 아 아투알리자상 지 쿠아이스케르 인테르파시스 지 우주아리우 오 아피스 네세사리아스.</span>
<span style="color:#323232;">6. **Redeploy**: Após a validação bem-sucedida do patch e a conclusão dos testes de regressão, o código pode ser reimplantado no ambiente de produção. Isso pode envolver a compilação do código em um contrato inteligente, a implantação do contrato na rede blockchain NEAR e a atualização de quaisquer interfaces de usuário ou APIs necessárias.</span>

<span style="color:#323232;">7. **모니토라멘투**: 아포스 아 헤임플란타상, 에 임포르탄치 모니토라르 우 아플리카치부 파라 가란치르 키 엘리 이스테자 푼시오난두 코헤타멘치. 이수 포지 인보우베르 우 모니토라멘투 지 로그스 지 에후스, 메트리카스 지 데젬페뉴 이 페드바크 두 우주아리우.</span>
<span style="color:#323232;">7. **Monitoramento**: Após a reimplantação, é importante monitorar o aplicativo para garantir que ele esteja funcionando corretamente. Isso pode envolver o monitoramento de logs de erros, métricas de desempenho e feedback do usuário.</span>

<span style="color:#323232;">에시스 파수스 데벵 세르 아우토마치자두스 우 마시무 포시베우 파라 토르나르 우 프로세수 지 테스치 이 헤임플란타상 마이스 이피시엔치 이 헤두지르 아 포시빌리다지 지 에후스 우마누스. 알렝 지수, 우스 테스치스 데벵 세르 프로제타두스 지 포르마 키 쿠브랑 우 마이오르 누메루 포시베우 지 세나리우스 지 우주 파라 마시미자르 아 프로바빌리다지 지 잉콘트라르 이 코히지르 부그스.</span>
<span style="color:#323232;">Esses passos devem ser automatizados o máximo possível para tornar o processo de teste e reimplantação mais eficiente e reduzir a possibilidade de erros humanos. Além disso, os testes devem ser projetados de forma que cubram o maior número possível de cenários de uso para maximizar a probabilidade de encontrar e corrigir bugs.</span>

<span style="color:#323232;">## 데타이우 티 이2이 피펠리니 포르 티 심플레스트 보칭그 시르쿠이트스, 데타일링그 아우 트란삭치옹스 인보우베드 프롱 티 파르치스. 프로비지 이트 아스 아 삼플리 우징그 포웨르제우 신타스 (프스1 필리) 타트 워우드 프로바블리 비 잉 티 호트 오프 아 프로젝트, 부이우징그 프론텐드스, 아피스, 데플로잉그 콘트락트스 옹 네아르데브, 이트크</span>
<span style="color:#323232;">## detail the e2e pipeline for the simplest voting circuits, detailing all transactions involved from the parties. provide it as a sample using powershell syntax (ps1 file) that would probably be in the root of a project, building frontends, apis, deploying contracts on neardev, etc</span>

<span style="color:#323232;">&lt; 임플레멘칭그 아 데타일레드 이2이 피펠리니 우징그 포웨르제우 포르 아 심플리 보칭그 시르쿠이트 옹 네아르 프로토코우 인보우베스 무우치플리 스테프스 수시 아스 세칭그 우프 티 인비론멘트, 콤필링그 안드 데플로잉그 티 스마르트 콘트락트스, 프레파링그 티 프론텐드 안드 바켄드 아피스, 안드 후닝그 티 테스트스.</span>
<span style="color:#323232;">&lt; Implementing a detailed E2E pipeline using PowerShell for a simple voting circuit on NEAR protocol involves multiple steps such as setting up the environment, compiling and deploying the smart contracts, preparing the frontend and backend APIs, and running the tests.</span>

<span style="color:#323232;">에리 이스 아 심플리피에드 이잠플리 잉 포웨르제우. 티스 스크리프트 아수메스 요 아비 네아르 클리, 노지.즈스 안드 오테르 데펜덴시스 아우헤아지 인스탈레드 잉 요르 인비론멘트.</span>
<span style="color:#323232;">Here is a simplified example in PowerShell. This script assumes you have NEAR CLI, Node.js and other dependencies already installed in your environment.</span>

<span style="color:#323232;">플레아지 노치, 티스 이스 아 이그-레베우 아브스트락치옹 오프 아트 티 스크리프트 코우드 로크 리키 안드 이트&#39;스 노트 풀리 풍크치오나우. 플레아지 우지 이트 아스 아 기지 투 리치 요르 옹 스크리프트 아코르징그 투 요르 프로젝트&#39;스 스페시피크 네드스.</span>
<span style="color:#323232;">Please note, this is a high-level abstraction of what the script could look like and it&#39;s not fully functional. Please use it as a guide to write your own script according to your project&#39;s specific needs.</span>

<span style="color:#323232;">```포웨르제우</span>
<span style="color:#323232;">```powershell</span>
<span style="color:#323232;"># 스크리프트.프스1</span>
<span style="color:#323232;"># Script.ps1</span>
<span style="color:#323232;"># 인수리 이호르 옹 파이우</span>
<span style="color:#323232;"># Ensure Error on Fail</span>
<span style="color:#323232;">$이호락치온프레페렌시 = &quot;스토프&quot;</span>
<span style="color:#323232;">$ErrorActionPreference = &quot;Stop&quot;</span>

<span style="color:#323232;"># 스테프 1: 콤필리 스마르트 콘트락트</span>
<span style="color:#323232;"># Step 1: Compile smart contract</span>
<span style="color:#323232;">리치-오트푸트 &quot;콤필링그 스마르트 콘트락트...&quot;</span>
<span style="color:#323232;">Write-Output &quot;Compiling smart contract...&quot;</span>
<span style="color:#323232;">세트-로카치옹 .\콘트락트</span>
<span style="color:#323232;">Set-Location .\contract</span>
<span style="color:#323232;">&amp; 카르구 부이우드 --헬레아지</span>
<span style="color:#323232;">&amp; cargo build --release</span>
<span style="color:#323232;">세트-로카치옹 ..</span>
<span style="color:#323232;">Set-Location ..</span>

<span style="color:#323232;"># 스테프 2: 데플로이 스마르트 콘트락트 투 네아르 테스트네트</span>
<span style="color:#323232;"># Step 2: Deploy smart contract to NEAR testnet</span>
<span style="color:#323232;">리치-오트푸트 &quot;데플로잉그 스마르트 콘트락트 투 네아르 테스트네트...&quot;</span>
<span style="color:#323232;">Write-Output &quot;Deploying smart contract to NEAR testnet...&quot;</span>
<span style="color:#323232;">&amp; 네아르 데브-데플로이 .\콘트락트\타르제트\와증32-웅크농-웅크농\헬레아지\콘트락트.와증</span>
<span style="color:#323232;">&amp; near dev-deploy .\contract\target\wasm32-unknown-unknown\release\contract.wasm</span>

<span style="color:#323232;"># 스테프 3: 프레파리 아피 세르베르</span>
<span style="color:#323232;"># Step 3: Prepare API Server</span>
<span style="color:#323232;">리치-오트푸트 &quot;인스탈링그 아피 세르베르 데펜덴시스...&quot;</span>
<span style="color:#323232;">Write-Output &quot;Installing API server dependencies...&quot;</span>
<span style="color:#323232;">세트-로카치옹 .\아피-세르베르</span>
<span style="color:#323232;">Set-Location .\api-server</span>
<span style="color:#323232;">&amp; 느픙 인스타우</span>
<span style="color:#323232;">&amp; npm install</span>
<span style="color:#323232;">리치-오트푸트 &quot;스타르칭그 아피 세르베르...&quot;</span>
<span style="color:#323232;">Write-Output &quot;Starting API server...&quot;</span>
<span style="color:#323232;">스타르트-프로세스 &quot;느픙&quot; -아르구멘틀리스트 &quot;스타르트&quot; -노네윈도</span>
<span style="color:#323232;">Start-Process &quot;npm&quot; -ArgumentList &quot;start&quot; -NoNewWindow</span>
<span style="color:#323232;">세트-로카치옹 ..</span>
<span style="color:#323232;">Set-Location ..</span>

<span style="color:#323232;"># 스테프 4: 프레파리 프론텐드</span>
<span style="color:#323232;"># Step 4: Prepare Frontend</span>
<span style="color:#323232;">리치-오트푸트 &quot;인스탈링그 프론텐드 데펜덴시스...&quot;</span>
<span style="color:#323232;">Write-Output &quot;Installing frontend dependencies...&quot;</span>
<span style="color:#323232;">세트-로카치옹 .\프론텐드</span>
<span style="color:#323232;">Set-Location .\frontend</span>
<span style="color:#323232;">&amp; 느픙 인스타우</span>
<span style="color:#323232;">&amp; npm install</span>
<span style="color:#323232;">리치-오트푸트 &quot;스타르칭그 프론텐드...&quot;</span>
<span style="color:#323232;">Write-Output &quot;Starting frontend...&quot;</span>
<span style="color:#323232;">스타르트-프로세스 &quot;느픙&quot; -아르구멘틀리스트 &quot;스타르트&quot; -노네윈도</span>
<span style="color:#323232;">Start-Process &quot;npm&quot; -ArgumentList &quot;start&quot; -NoNewWindow</span>
<span style="color:#323232;">세트-로카치옹 ..</span>
<span style="color:#323232;">Set-Location ..</span>

<span style="color:#323232;"># 스테프 5: 훙 이2이 테스트스</span>
<span style="color:#323232;"># Step 5: Run E2E tests</span>
<span style="color:#323232;">리치-오트푸트 &quot;후닝그 이2이 테스트스...&quot;</span>
<span style="color:#323232;">Write-Output &quot;Running E2E tests...&quot;</span>
<span style="color:#323232;">&amp; 느픙 훙 이2이</span>
<span style="color:#323232;">&amp; npm run e2e</span>

<span style="color:#323232;"># 셰크 포르 아니 이호르스 두링그 티 프로세스</span>
<span style="color:#323232;"># Check for any errors during the process</span>
<span style="color:#323232;">이프 ($라스테시트코지 -니 0) {</span>
<span style="color:#323232;">if ($LASTEXITCODE -ne 0) {</span>
<span style="color:#323232;">리치-오트푸트 &quot;앙 이호르 오쿠헤드 두링그 티 이2이 테스칭그 프로세스&quot;</span>
<span style="color:#323232;">Write-Output &quot;An error occurred during the E2E testing process&quot;</span>
<span style="color:#323232;">이지트 $라스테시트코지</span>
<span style="color:#323232;">exit $LASTEXITCODE</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

<span style="color:#323232;">리치-오트푸트 &quot;이2이 테스트스 콤플레테드 수세스풀리. 보칭그 시르쿠이트 이스 풍크치오닝그 아스 이스펙테드.&quot;</span>
<span style="color:#323232;">Write-Output &quot;E2E tests completed successfully. Voting circuit is functioning as expected.&quot;</span>

</pre><pre>
<span style="color:#323232;">티스 스크리프트 잉클루지스 바지크 스테프스, 부트 헤아우-워루드 세나리우스 워우드 세르타인리 비 모리 콤플레스. 테이 워우드 리켈리 인보우비 아지치오나우 콘시데라치옹스 수시 아스 트란삭치옹 안들링그, 테스트 카지 세투프 안드 테아르동, 이호르 안들링그, 안드 페라프스 이벵 오르셰스트라치옹 우징그 콘치누오스 인테그라치옹 (시) 피펠리니스.</span>
<span style="color:#323232;">This script includes basic steps, but real-world scenarios would certainly be more complex. They would likely involve additional considerations such as transaction handling, test case setup and teardown, error handling, and perhaps even orchestration using continuous integration (CI) pipelines.</span>

<span style="color:#323232;">노치 타트 네아르&#39;스 데브-데플로이 코만드 위우 데플로이 티 콘트락트 투 아 네 아콘트 옹 티 테스트 네트워르크. 이프 요 완트 투 데플로이 투 아 스페시피크 아콘트, 요&#39;르 네드 투 우지 아 지페렌트 코만드 안드 인수리 타트 티 아콘트 아스 수피시엔트 푼드스 포르 티 데플로이멘트.</span>
<span style="color:#323232;">Note that NEAR&#39;s dev-deploy command will deploy the contract to a new account on the test network. If you want to deploy to a specific account, you&#39;ll need to use a different command and ensure that the account has sufficient funds for the deployment.</span>

<span style="color:#323232;">아우수, 헤멤베르 투 크레아치 아프로프리아치 테스트스 운데르 요르 느픙 훙 이2이 스크리프트 잉 요르 파카지.즈송. 테지 테스트스 소우드 인보우비 인테락치옹 위트 요르 프론텐드, 아피스, 안드 스마르트 콘트락트스 투 풀리 발리다치 요르 보칭그 시르쿠이트.</span>
<span style="color:#323232;">Also, remember to create appropriate tests under your npm run e2e script in your package.json. These tests should involve interaction with your frontend, APIs, and smart contracts to fully validate your voting circuit.</span>

<span style="color:#323232;">라스틀리, 플레아지 인수리 타트 요 폴로 티 베스트 프락치시스 포르 포웨르제우 스크리프칭그 수시 아스 우징그 스트릭트 모지, 안들링그 안드 로징그 이호르스 아프로프리아텔리, 안드 세쿠링그 아니 센시치비 인포르마치옹.</span>
<span style="color:#323232;">Lastly, please ensure that you follow the best practices for PowerShell scripting such as using strict mode, handling and logging errors appropriately, and securing any sensitive information.</span>

<span style="color:#323232;">## 노 데타이우 티 우니트 테스트 포르 티 콘트락트 이트세우프</span>
<span style="color:#323232;">## now detail the unit test for the contract itself</span>

<span style="color:#323232;">&lt; 우니트 테스칭그 포르 후스트 스마르트 콘트락트스 옹 티 네아르 프로토코우 캉 비 도니 위트 티 네아르-스드크-싱 크라치, 이시 알로스 포르 파스트 안드 헬리아블리 우니트 테스칭그.</span>
<span style="color:#323232;">&lt; Unit testing for Rust smart contracts on the NEAR protocol can be done with the near-sdk-sim crate, which allows for fast and reliable unit testing.</span>

<span style="color:#323232;">벨로 이스 앙 이잠플리 오프 아 우니트 테스트 포르 아 심플리 보칭그 콘트락트:</span>
<span style="color:#323232;">Below is an example of a unit test for a simple voting contract:</span>

<span style="color:#323232;">```후스트</span>
<span style="color:#323232;">```rust</span>
<span style="color:#323232;">우지 네아르_스드크::즈송_치페스::우128</span>
<span style="color:#323232;">use near_sdk::json_types::U128;</span>
<span style="color:#323232;">우지 네아르_스드크::세르지_즈송::즈송</span>
<span style="color:#323232;">use near_sdk::serde_json::json;</span>
<span style="color:#323232;">우지 네아르_스드크_싱::{카우, 데플로이, 이니트_시물라토르, 투_욕투, 비에, 콘트락타콘트, 우제라콘트}</span>
<span style="color:#323232;">use near_sdk_sim::{call, deploy, init_simulator, to_yocto, view, ContractAccount, UserAccount};</span>

<span style="color:#323232;">// 로아드 잉 콘트락트 비치스 아트 훈치미</span>
<span style="color:#323232;">// Load in contract bytes at runtime</span>
<span style="color:#323232;">네아르_스드크_싱::라지_스타치크_잉클루지::라지_스타치크_잉클루지_비치스! {</span>
<span style="color:#323232;">near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {</span>
<span style="color:#323232;">콘트락트_비치스 =&gt; &quot;히스/보칭그_콘트락트.와증&quot;,</span>
<span style="color:#323232;">CONTRACT_BYTES =&gt; &quot;res/voting_contract.wasm&quot;,</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

<span style="color:#323232;">// 이니치알리지 티 시물라토르</span>
<span style="color:#323232;">// Initialize the simulator</span>
<span style="color:#323232;">#[테스트]</span>
<span style="color:#323232;">#[test]</span>
<span style="color:#323232;">픙 이니트() {</span>
<span style="color:#323232;">fn init() {</span>
<span style="color:#323232;">레트 콘테스트 = 이니트_시물라토르(노니)</span>
<span style="color:#323232;">let context = init_simulator(None);</span>
<span style="color:#323232;">레트 콘트락트_이드 = 콘테스트.아콘트스[0].아콘트_이드().투_스트링그()</span>
<span style="color:#323232;">let contract_id = context.accounts[0].account_id().to_string();</span>
<span style="color:#323232;">레트 콘트락트 = 데플로이! {</span>
<span style="color:#323232;">let contract = deploy! {</span>
<span style="color:#323232;">콘트락트: 보칭그_콘트락트,</span>
<span style="color:#323232;">contract: voting_contract,</span>
<span style="color:#323232;">콘트락트_이드: 콘트락트_이드,</span>
<span style="color:#323232;">contract_id: contract_id,</span>
<span style="color:#323232;">비치스: &amp;콘트락트_비치스,</span>
<span style="color:#323232;">bytes: &amp;CONTRACT_BYTES,</span>
<span style="color:#323232;">시그네르_아콘트: 콘테스트.아콘트스[0],</span>
<span style="color:#323232;">signer_account: context.accounts[0],</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">};</span>

<span style="color:#323232;">// 베리피 타트 티 콘트락트 와스 데플로예드 코헥틀리</span>
<span style="color:#323232;">// Verify that the contract was deployed correctly</span>
<span style="color:#323232;">레트 토타우_보치스: 우128 = 비에!(콘트락트.제트_토타우_보치스()).운으라프_즈송()</span>
<span style="color:#323232;">let total_votes: U128 = view!(contract.get_total_votes()).unwrap_json();</span>
<span style="color:#323232;">아세르트_이크!(토타우_보치스.0, 0)</span>
<span style="color:#323232;">assert_eq!(total_votes.0, 0);</span>

<span style="color:#323232;">// 크레아치 아 네 보치</span>
<span style="color:#323232;">// Create a new vote</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[0],</span>
<span style="color:#323232;">context.accounts[0],</span>
<span style="color:#323232;">콘트락트.크레아치_보치(즈송!({ &quot;보치&quot;: &quot;보치 1&quot; })),</span>
<span style="color:#323232;">contract.create_vote(json!({ &quot;vote&quot;: &quot;Vote 1&quot; })),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_오크())</span>
<span style="color:#323232;">assert!(res.is_ok());</span>

<span style="color:#323232;">// 베리피 타트 티 보치 와스 크레아테드 코헥틀리</span>
<span style="color:#323232;">// Verify that the vote was created correctly</span>
<span style="color:#323232;">레트 토타우_보치스: 우128 = 비에!(콘트락트.제트_토타우_보치스()).운으라프_즈송()</span>
<span style="color:#323232;">let total_votes: U128 = view!(contract.get_total_votes()).unwrap_json();</span>
<span style="color:#323232;">아세르트_이크!(토타우_보치스.0, 1)</span>
<span style="color:#323232;">assert_eq!(total_votes.0, 1);</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

</pre><pre>
<span style="color:#323232;">티스 테스트 위우 이니치알리지 아 보칭그 콘트락트, 베리피 이트스 이니치아우 스타치, 크레아치 아 네 보치, 안드 텡 베리피 타트 티 보치 와스 코헥틀리 크레아테드.</span>
<span style="color:#323232;">This test will initialize a voting contract, verify its initial state, create a new vote, and then verify that the vote was correctly created.</span>

<span style="color:#323232;">노치 타트 잉 오르데르 포르 티스 투 워르크, 요르 콘트락트 위우 네드 투 아비 아 메토드 크레아치_보치 타트 아세프트스 아 즈송 오브젝트 위트 아 싱글리 &quot;보치&quot; 피에우드 안드 아 제트_토타우_보치스 메토드 타트 헤투릉스 티 토타우 눔베르 오프 보치스. 아우수, 플레아지 헤플라시 &quot;히스/보칭그_콘트락트.와증&quot; 위트 티 파트 투 요르 콤필레드 콘트락트.</span>
<span style="color:#323232;">Note that in order for this to work, your contract will need to have a method create_vote that accepts a JSON object with a single &quot;vote&quot; field and a get_total_votes method that returns the total number of votes. Also, please replace &quot;res/voting_contract.wasm&quot; with the path to your compiled contract.</span>

<span style="color:#323232;">케프 잉 민드 타트 티스 이스 아 베리 바지크 이잠플리, 안드 악투아우 우니트 테스트스 워우드 리켈리 비 무시 모리 콤플레스 안드 코베르 마니 모리 에드지 카지스. 아우수, 이트&#39;스 고드 프락치시 투 리치 테스트스 노트 온리 포르 수세스풀 카지스 부트 아우수 포르 카지스 에리 요 이스펙트 파일루리스 투 인수리 타트 요르 콘트락트 베아베스 코헥틀리 잉 테지 시투아치옹스 아스 웨우.</span>
<span style="color:#323232;">Keep in mind that this is a very basic example, and actual unit tests would likely be much more complex and cover many more edge cases. Also, it&#39;s good practice to write tests not only for successful cases but also for cases where you expect failures to ensure that your contract behaves correctly in these situations as well.</span>

<span style="color:#323232;">## 프로비지 아우 아세르치옹스 헬라테드 투 수시 시르쿠이트 콘시데링그 티 후스트 랑구아지 테앙 델리베라치옹스</span>
<span style="color:#323232;">## provide all assertions related to such circuit considering the rust language team deliberations</span>

<span style="color:#323232;">&lt; 투 리치 아세르치옹스 포르 아 보칭그 시스텡 타트&#39;스 데지그네드 투 안들리 후스트 랑구아지 테앙 델리베라치옹스, 위 네드 투 콘시데르 아 페 아스펙트스:</span>
<span style="color:#323232;">&lt; To write assertions for a voting system that&#39;s designed to handle Rust language team deliberations, we need to consider a few aspects:</span>

<span style="color:#323232;">1. **지페렌트 보칭그 치페스**: 티 후스트 랑구아지 테앙 마이 헤키리 지페렌트 보칭그 치페스, 수시 아스 심플리 마조리치, 수페르마조리치, 오르 우나니미치, 데펜징그 옹 티 데시지옹 아트 안드.</span>
<span style="color:#323232;">1. **Different Voting Types**: The Rust language team may require different voting types, such as simple majority, supermajority, or unanimity, depending on the decision at hand.</span>

<span style="color:#323232;">2. **일리지빌리치 투 보치**: 노트 이베리오니 마이 비 일리지블리 투 보치 옹 아우 마테르스. 이트 코우드 비 타트 온리 테앙 멤베르스 캉 보치, 오르 페라프스 온리 콘트리부토르스 위트 아 세르타잉 레베우 오프 인보우베멘트.</span>
<span style="color:#323232;">2. **Eligibility to Vote**: Not everyone may be eligible to vote on all matters. It could be that only team members can vote, or perhaps only contributors with a certain level of involvement.</span>

<span style="color:#323232;">3. **프로포징그 데시지옹스**: 테리 네드스 투 비 아 시스텡 잉 플라시 포르 프로포징그 데시지옹스 투 비 보테드 옹.</span>
<span style="color:#323232;">3. **Proposing Decisions**: There needs to be a system in place for proposing decisions to be voted on.</span>

<span style="color:#323232;">4. **콘플릭트 헤졸루치옹**: 잉 카지 오프 아 치, 테리 네드스 투 비 아 메샤니증 포르 브레아킹그 티 데아들로크.</span>
<span style="color:#323232;">4. **Conflict Resolution**: In case of a tie, there needs to be a mechanism for breaking the deadlock.</span>

<span style="color:#323232;">5. **치메프라메스**: 테리 코우드 비 아 치미 리미트 위팅 이시 보치스 무스트 비 카스트.</span>
<span style="color:#323232;">5. **Timeframes**: There could be a time limit within which votes must be cast.</span>

<span style="color:#323232;">에리&#39;스 아 바지크 이잠플리 오프 아트 티 아세르치옹스 미그트 로크 리키:</span>
<span style="color:#323232;">Here&#39;s a basic example of what the assertions might look like:</span>

<span style="color:#323232;">```후스트</span>
<span style="color:#323232;">```rust</span>
<span style="color:#323232;">#[테스트]</span>
<span style="color:#323232;">#[test]</span>
<span style="color:#323232;">픙 보치() {</span>
<span style="color:#323232;">fn vote() {</span>
<span style="color:#323232;">// 이니치알리지 티 콘트락트 안드 크레아치 아 네 데시지옹</span>
<span style="color:#323232;">// Initialize the contract and create a new decision</span>
<span style="color:#323232;">레트 데시지옹 = &quot;네 페아투리 프로포자우&quot;</span>
<span style="color:#323232;">let decision = &quot;New feature proposal&quot;;</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[0],</span>
<span style="color:#323232;">context.accounts[0],</span>
<span style="color:#323232;">콘트락트.크레아치_데시지옹(데시지옹),</span>
<span style="color:#323232;">contract.create_decision(decision),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_오크())</span>
<span style="color:#323232;">assert!(res.is_ok());</span>

<span style="color:#323232;">// 베리피 티 데시지옹 와스 크레아테드</span>
<span style="color:#323232;">// Verify the decision was created</span>
<span style="color:#323232;">레트 데시지옹_다타: 데시지옹 = 비에!(콘트락트.제트_데시지옹(데시지옹)).운으라프_즈송()</span>
<span style="color:#323232;">let decision_data: Decision = view!(contract.get_decision(decision)).unwrap_json();</span>
<span style="color:#323232;">아세르트_이크!(데시지옹_다타.나미, 데시지옹)</span>
<span style="color:#323232;">assert_eq!(decision_data.name, decision);</span>
<span style="color:#323232;">아세르트_이크!(데시지옹_다타.보치_콘트, 0)</span>
<span style="color:#323232;">assert_eq!(decision_data.vote_count, 0);</span>
<span style="color:#323232;">아세르트_이크!(데시지옹_다타.스타투스, 데시지온스타투스::오펭)</span>
<span style="color:#323232;">assert_eq!(decision_data.status, DecisionStatus::Open);</span>

<span style="color:#323232;">// 카스트 아 보치</span>
<span style="color:#323232;">// Cast a vote</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[1],</span>
<span style="color:#323232;">context.accounts[1],</span>
<span style="color:#323232;">콘트락트.보치(데시지옹, 보치::이스),</span>
<span style="color:#323232;">contract.vote(decision, Vote::Yes),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;0.1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;0.1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_오크())</span>
<span style="color:#323232;">assert!(res.is_ok());</span>

<span style="color:#323232;">// 베리피 티 보치 와스 헤코르데드</span>
<span style="color:#323232;">// Verify the vote was recorded</span>
<span style="color:#323232;">레트 데시지옹_다타: 데시지옹 = 비에!(콘트락트.제트_데시지옹(데시지옹)).운으라프_즈송()</span>
<span style="color:#323232;">let decision_data: Decision = view!(contract.get_decision(decision)).unwrap_json();</span>
<span style="color:#323232;">아세르트_이크!(데시지옹_다타.보치_콘트, 1)</span>
<span style="color:#323232;">assert_eq!(decision_data.vote_count, 1);</span>

<span style="color:#323232;">// 베리피 타트 티 보치 탈리 이스 우프다테드</span>
<span style="color:#323232;">// Verify that the vote tally is updated</span>
<span style="color:#323232;">레트 보치_탈리: 보테탈리 = 비에!(콘트락트.제트_보치_탈리(데시지옹)).운으라프_즈송()</span>
<span style="color:#323232;">let vote_tally: VoteTally = view!(contract.get_vote_tally(decision)).unwrap_json();</span>
<span style="color:#323232;">아세르트_이크!(보치_탈리.이스_보치스, 1)</span>
<span style="color:#323232;">assert_eq!(vote_tally.yes_votes, 1);</span>
<span style="color:#323232;">아세르트_이크!(보치_탈리.누_보치스, 0)</span>
<span style="color:#323232;">assert_eq!(vote_tally.no_votes, 0);</span>

<span style="color:#323232;">// 트리 투 보치 트위시, 소우드 파이우</span>
<span style="color:#323232;">// Try to vote twice, should fail</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[1],</span>
<span style="color:#323232;">context.accounts[1],</span>
<span style="color:#323232;">콘트락트.보치(데시지옹, 보치::누),</span>
<span style="color:#323232;">contract.vote(decision, Vote::No),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;0.1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;0.1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_이흐())</span>
<span style="color:#323232;">assert!(res.is_err());</span>

<span style="color:#323232;">// 베리피 타트 티 보치 탈리 이스 스치우 티 사미</span>
<span style="color:#323232;">// Verify that the vote tally is still the same</span>
<span style="color:#323232;">레트 보치_탈리: 보테탈리 = 비에!(콘트락트.제트_보치_탈리(데시지옹)).운으라프_즈송()</span>
<span style="color:#323232;">let vote_tally: VoteTally = view!(contract.get_vote_tally(decision)).unwrap_json();</span>
<span style="color:#323232;">아세르트_이크!(보치_탈리.이스_보치스, 1)</span>
<span style="color:#323232;">assert_eq!(vote_tally.yes_votes, 1);</span>
<span style="color:#323232;">아세르트_이크!(보치_탈리.누_보치스, 0)</span>
<span style="color:#323232;">assert_eq!(vote_tally.no_votes, 0);</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

</pre><pre>
<span style="color:#323232;">테지 아세르치옹스 인수리 타트 티 데시지옹 크레아치옹, 보칭그, 안드 보치 탈링그 프로세시스 아리 풍크치오닝그 코헥틀리. 테이 아우수 인수리 타트 이아시 우제르 캉 온리 보치 온시 페르 데시지옹. 테리 워우드 비 아지치오나우 테스트스 헤키레드 투 인수리 아우 파르트스 오프 티 콘트락트 워르크 코헥틀리, 수시 아스 일리지빌리치 셰킹그, 데시지옹 이스피리, 보치 치피 안들링그, 안드 콘플릭트 헤졸루치옹.</span>
<span style="color:#323232;">These assertions ensure that the decision creation, voting, and vote tallying processes are functioning correctly. They also ensure that each user can only vote once per decision. There would be additional tests required to ensure all parts of the contract work correctly, such as eligibility checking, decision expiry, vote type handling, and conflict resolution.</span>

<span style="color:#323232;">## 프로비지 아 테스트세트 위트 40 아세르치옹스. 이프 티 테스트 쿠트 이&#39;르 클리크 잉 &#39;콘치누이 헤스폰시&#39;</span>
<span style="color:#323232;">## provide a testset with 40 assertions. if the text cut i&#39;ll click in &#39;continue response&#39;</span>

<span style="color:#323232;">부이우징그 옹 티 프레비오스 이잠플리, 위 캉 이스판드 티 테스트 세트 투 코베르 모리 풍크치오날리치스 오프 티 스마르트 콘트락트. 에리 아리 소미 아지치오나우 아세르치옹스 포르 티 스마르트 콘트락트:</span>
<span style="color:#323232;">Building on the previous example, we can expand the test set to cover more functionalities of the smart contract. Here are some additional assertions for the smart contract:</span>

<span style="color:#323232;">```후스트</span>
<span style="color:#323232;">```rust</span>
<span style="color:#323232;">#[테스트]</span>
<span style="color:#323232;">#[test]</span>
<span style="color:#323232;">픙 이스텐시비_보치_테스트() {</span>
<span style="color:#323232;">fn extensive_vote_test() {</span>
<span style="color:#323232;">// 이니치알리지 티 콘트락트 안드 크레아치 아 네 데시지옹</span>
<span style="color:#323232;">// Initialize the contract and create a new decision</span>
<span style="color:#323232;">레트 데시지옹 = &quot;네 페아투리 프로포자우&quot;</span>
<span style="color:#323232;">let decision = &quot;New feature proposal&quot;;</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[0],</span>
<span style="color:#323232;">context.accounts[0],</span>
<span style="color:#323232;">콘트락트.크레아치_데시지옹(데시지옹),</span>
<span style="color:#323232;">contract.create_decision(decision),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_오크(), &quot;1. 크레아치 데시지옹 파일레드&quot;)</span>
<span style="color:#323232;">assert!(res.is_ok(), &quot;1. Create decision failed&quot;);</span>

<span style="color:#323232;">// 베리피 티 데시지옹 와스 크레아테드</span>
<span style="color:#323232;">// Verify the decision was created</span>
<span style="color:#323232;">레트 데시지옹_다타: 데시지옹 = 비에!(콘트락트.제트_데시지옹(데시지옹)).운으라프_즈송()</span>
<span style="color:#323232;">let decision_data: Decision = view!(contract.get_decision(decision)).unwrap_json();</span>
<span style="color:#323232;">아세르트_이크!(데시지옹_다타.나미, 데시지옹, &quot;2. 데시지옹 나미 잉코헥트&quot;)</span>
<span style="color:#323232;">assert_eq!(decision_data.name, decision, &quot;2. Decision name incorrect&quot;);</span>
<span style="color:#323232;">아세르트_이크!(데시지옹_다타.보치_콘트, 0, &quot;3. 이니치아우 보치 콘트 잉코헥트&quot;)</span>
<span style="color:#323232;">assert_eq!(decision_data.vote_count, 0, &quot;3. Initial vote count incorrect&quot;);</span>
<span style="color:#323232;">아세르트_이크!(데시지옹_다타.스타투스, 데시지온스타투스::오펭, &quot;4. 데시지옹 스타투스 잉코헥트&quot;)</span>
<span style="color:#323232;">assert_eq!(decision_data.status, DecisionStatus::Open, &quot;4. Decision status incorrect&quot;);</span>

<span style="color:#323232;">// 카스트 아 보치</span>
<span style="color:#323232;">// Cast a vote</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[1],</span>
<span style="color:#323232;">context.accounts[1],</span>
<span style="color:#323232;">콘트락트.보치(데시지옹, 보치::이스),</span>
<span style="color:#323232;">contract.vote(decision, Vote::Yes),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;0.1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;0.1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_오크(), &quot;5. 피르스트 보치 파일레드&quot;)</span>
<span style="color:#323232;">assert!(res.is_ok(), &quot;5. First vote failed&quot;);</span>

<span style="color:#323232;">// 베리피 티 보치 와스 헤코르데드</span>
<span style="color:#323232;">// Verify the vote was recorded</span>
<span style="color:#323232;">레트 데시지옹_다타: 데시지옹 = 비에!(콘트락트.제트_데시지옹(데시지옹)).운으라프_즈송()</span>
<span style="color:#323232;">let decision_data: Decision = view!(contract.get_decision(decision)).unwrap_json();</span>
<span style="color:#323232;">아세르트_이크!(데시지옹_다타.보치_콘트, 1, &quot;6. 보치 콘트 잉코헥트 아프테르 피르스트 보치&quot;)</span>
<span style="color:#323232;">assert_eq!(decision_data.vote_count, 1, &quot;6. Vote count incorrect after first vote&quot;);</span>

<span style="color:#323232;">// 베리피 타트 티 보치 탈리 이스 우프다테드</span>
<span style="color:#323232;">// Verify that the vote tally is updated</span>
<span style="color:#323232;">레트 보치_탈리: 보테탈리 = 비에!(콘트락트.제트_보치_탈리(데시지옹)).운으라프_즈송()</span>
<span style="color:#323232;">let vote_tally: VoteTally = view!(contract.get_vote_tally(decision)).unwrap_json();</span>
<span style="color:#323232;">아세르트_이크!(보치_탈리.이스_보치스, 1, &quot;7. 이스 보치 탈리 잉코헥트 아프테르 피르스트 보치&quot;)</span>
<span style="color:#323232;">assert_eq!(vote_tally.yes_votes, 1, &quot;7. Yes vote tally incorrect after first vote&quot;);</span>
<span style="color:#323232;">아세르트_이크!(보치_탈리.누_보치스, 0, &quot;8. 누 보치 탈리 잉코헥트 아프테르 피르스트 보치&quot;)</span>
<span style="color:#323232;">assert_eq!(vote_tally.no_votes, 0, &quot;8. No vote tally incorrect after first vote&quot;);</span>

<span style="color:#323232;">// 트리 투 보치 트위시, 소우드 파이우</span>
<span style="color:#323232;">// Try to vote twice, should fail</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[1],</span>
<span style="color:#323232;">context.accounts[1],</span>
<span style="color:#323232;">콘트락트.보치(데시지옹, 보치::누),</span>
<span style="color:#323232;">contract.vote(decision, Vote::No),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;0.1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;0.1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_이흐(), &quot;9. 도블리 보칭그 알로웨드&quot;)</span>
<span style="color:#323232;">assert!(res.is_err(), &quot;9. Double voting allowed&quot;);</span>

<span style="color:#323232;">// 베리피 타트 티 보치 탈리 이스 스치우 티 사미</span>
<span style="color:#323232;">// Verify that the vote tally is still the same</span>
<span style="color:#323232;">레트 보치_탈리: 보테탈리 = 비에!(콘트락트.제트_보치_탈리(데시지옹)).운으라프_즈송()</span>
<span style="color:#323232;">let vote_tally: VoteTally = view!(contract.get_vote_tally(decision)).unwrap_json();</span>
<span style="color:#323232;">아세르트_이크!(보치_탈리.이스_보치스, 1, &quot;10. 이스 보치 탈리 잉코헥트 아프테르 도블리 보치 아템프트&quot;)</span>
<span style="color:#323232;">assert_eq!(vote_tally.yes_votes, 1, &quot;10. Yes vote tally incorrect after double vote attempt&quot;);</span>
<span style="color:#323232;">아세르트_이크!(보치_탈리.누_보치스, 0, &quot;11. 누 보치 탈리 잉코헥트 아프테르 도블리 보치 아템프트&quot;)</span>
<span style="color:#323232;">assert_eq!(vote_tally.no_votes, 0, &quot;11. No vote tally incorrect after double vote attempt&quot;);</span>

<span style="color:#323232;">// 카스트 아 누 보치</span>
<span style="color:#323232;">// Cast a no vote</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[2],</span>
<span style="color:#323232;">context.accounts[2],</span>
<span style="color:#323232;">콘트락트.보치(데시지옹, 보치::누),</span>
<span style="color:#323232;">contract.vote(decision, Vote::No),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;0.1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;0.1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_오크(), &quot;12. 세콘드 보치 파일레드&quot;)</span>
<span style="color:#323232;">assert!(res.is_ok(), &quot;12. Second vote failed&quot;);</span>

<span style="color:#323232;">// 베리피 티 보치 와스 헤코르데드</span>
<span style="color:#323232;">// Verify the vote was recorded</span>
<span style="color:#323232;">레트 데시지옹_다타: 데시지옹 = 비에!(콘트락트.제트_데시지옹(데시지옹)).운으라프_즈송()</span>
<span style="color:#323232;">let decision_data: Decision = view!(contract.get_decision(decision)).unwrap_json();</span>
<span style="color:#323232;">아세르트_이크!(데시지옹_다타.보치_콘트, 2, &quot;13. 보치 콘트 잉코헥트 아프테르 세콘드 보치&quot;)</span>
<span style="color:#323232;">assert_eq!(decision_data.vote_count, 2, &quot;13. Vote count incorrect after second vote&quot;);</span>

<span style="color:#323232;">// 베리피 타트 티 보치 탈리 이스 우프다테드</span>
<span style="color:#323232;">// Verify that the vote tally is updated</span>
<span style="color:#323232;">레트 보치_탈리: 보테탈리 = 비에!(콘트락트.제트_보치_탈리(데시지옹)).운으라프_즈송()</span>
<span style="color:#323232;">let vote_tally: VoteTally = view!(contract.get_vote_tally(decision)).unwrap_json();</span>
<span style="color:#323232;">아세르트_이크!(보치_탈리.이스_보치스, 1, &quot;14. 이스 보치 탈리 잉코헥트 아프테르 세콘드 보치&quot;)</span>
<span style="color:#323232;">assert_eq!(vote_tally.yes_votes, 1, &quot;14. Yes vote tally incorrect after second vote&quot;);</span>
<span style="color:#323232;">아세르트_이크!(보치_탈리.누_보치스, 1, &quot;15. 누 보치 탈리 잉코헥트 아프테르 세콘드 보치&quot;)</span>
<span style="color:#323232;">assert_eq!(vote_tally.no_votes, 1, &quot;15. No vote tally incorrect after second vote&quot;);</span>

<span style="color:#323232;">// 베리피 타트 아 데시지옹 캉&#39;트 비 클로제드 이아를리</span>
<span style="color:#323232;">// Verify that a decision can&#39;t be closed early</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[0],</span>
<span style="color:#323232;">context.accounts[0],</span>
<span style="color:#323232;">콘트락트.클로지_데시지옹(데시지옹),</span>
<span style="color:#323232;">contract.close_decision(decision),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_이흐(), &quot;16. 데시지옹 와스 아블리 투 비 클로제드 이아를리&quot;)</span>
<span style="color:#323232;">assert!(res.is_err(), &quot;16. Decision was able to be closed early&quot;);</span>

<span style="color:#323232;">// 카스트 아 피나우 이스 보치</span>
<span style="color:#323232;">// Cast a final yes vote</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[3],</span>
<span style="color:#323232;">context.accounts[3],</span>
<span style="color:#323232;">콘트락트.보치(데시지옹, 보치::이스),</span>
<span style="color:#323232;">contract.vote(decision, Vote::Yes),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;0.1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;0.1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_오크(), &quot;17. 피나우 보치 파일레드&quot;)</span>
<span style="color:#323232;">assert!(res.is_ok(), &quot;17. Final vote failed&quot;);</span>

<span style="color:#323232;">// 베리피 티 보치 와스 헤코르데드</span>
<span style="color:#323232;">// Verify the vote was recorded</span>
<span style="color:#323232;">레트 데시지옹_다타: 데시지옹 = 비에!(콘트락트.제트_데시지옹(데시지옹)).운으라프_즈송()</span>
<span style="color:#323232;">let decision_data: Decision = view!(contract.get_decision(decision)).unwrap_json();</span>
<span style="color:#323232;">아세르트_이크!(데시지옹_다타.보치_콘트, 3, &quot;18. 보치 콘트 잉코헥트 아프테르 피나우 보치&quot;)</span>
<span style="color:#323232;">assert_eq!(decision_data.vote_count, 3, &quot;18. Vote count incorrect after final vote&quot;);</span>

<span style="color:#323232;">// 베리피 타트 티 보치 탈리 이스 우프다테드</span>
<span style="color:#323232;">// Verify that the vote tally is updated</span>
<span style="color:#323232;">레트 보치_탈리: 보테탈리 = 비에!(콘트락트.제트_보치_탈리(데시지옹)).운으라프_즈송()</span>
<span style="color:#323232;">let vote_tally: VoteTally = view!(contract.get_vote_tally(decision)).unwrap_json();</span>
<span style="color:#323232;">아세르트_이크!(보치_탈리.이스_보치스, 2, &quot;19. 이스 보치 탈리 잉코헥트 아프테르 피나우 보치&quot;)</span>
<span style="color:#323232;">assert_eq!(vote_tally.yes_votes, 2, &quot;19. Yes vote tally incorrect after final vote&quot;);</span>
<span style="color:#323232;">아세르트_이크!(보치_탈리.누_보치스, 1, &quot;20. 누 보치 탈리 잉코헥트 아프테르 피나우 보치&quot;)</span>
<span style="color:#323232;">assert_eq!(vote_tally.no_votes, 1, &quot;20. No vote tally incorrect after final vote&quot;);</span>

<span style="color:#323232;">// 클로지 티 데시지옹</span>
<span style="color:#323232;">// Close the decision</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[0],</span>
<span style="color:#323232;">context.accounts[0],</span>
<span style="color:#323232;">콘트락트.클로지_데시지옹(데시지옹),</span>
<span style="color:#323232;">contract.close_decision(decision),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_오크(), &quot;21. 클로징그 데시지옹 파일레드&quot;)</span>
<span style="color:#323232;">assert!(res.is_ok(), &quot;21. Closing decision failed&quot;);</span>

<span style="color:#323232;">// 베리피 티 데시지옹 와스 클로제드</span>
<span style="color:#323232;">// Verify the decision was closed</span>
<span style="color:#323232;">레트 데시지옹_다타: 데시지옹 = 비에!(콘트락트.제트_데시지옹(데시지옹)).운으라프_즈송()</span>
<span style="color:#323232;">let decision_data: Decision = view!(contract.get_decision(decision)).unwrap_json();</span>
<span style="color:#323232;">아세르트_이크!(데시지옹_다타.스타투스, 데시지온스타투스::클로제드, &quot;22. 데시지옹 스타투스 잉코헥트 아프테르 클로징그&quot;)</span>
<span style="color:#323232;">assert_eq!(decision_data.status, DecisionStatus::Closed, &quot;22. Decision status incorrect after closing&quot;);</span>

<span style="color:#323232;">// 베리피 타트 보칭그 옹 아 클로제드 데시지옹 파이우스</span>
<span style="color:#323232;">// Verify that voting on a closed decision fails</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[4],</span>
<span style="color:#323232;">context.accounts[4],</span>
<span style="color:#323232;">콘트락트.보치(데시지옹, 보치::누),</span>
<span style="color:#323232;">contract.vote(decision, Vote::No),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;0.1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;0.1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_이흐(), &quot;23. 보칭그 알로웨드 옹 클로제드 데시지옹&quot;)</span>
<span style="color:#323232;">assert!(res.is_err(), &quot;23. Voting allowed on closed decision&quot;);</span>

<span style="color:#323232;">// 베리피 타트 티 보치 탈리 이스 운샨제드</span>
<span style="color:#323232;">// Verify that the vote tally is unchanged</span>
<span style="color:#323232;">레트 보치_탈리: 보테탈리 = 비에!(콘트락트.제트_보치_탈리(데시지옹)).운으라프_즈송()</span>
<span style="color:#323232;">let vote_tally: VoteTally = view!(contract.get_vote_tally(decision)).unwrap_json();</span>
<span style="color:#323232;">아세르트_이크!(보치_탈리.이스_보치스, 2, &quot;24. 이스 보치 탈리 잉코헥트 아프테르 아템프트 투 보치 옹 클로제드 데시지옹&quot;)</span>
<span style="color:#323232;">assert_eq!(vote_tally.yes_votes, 2, &quot;24. Yes vote tally incorrect after attempt to vote on closed decision&quot;);</span>
<span style="color:#323232;">아세르트_이크!(보치_탈리.누_보치스, 1, &quot;25. 누 보치 탈리 잉코헥트 아프테르 아템프트 투 보치 옹 클로제드 데시지옹&quot;)</span>
<span style="color:#323232;">assert_eq!(vote_tally.no_votes, 1, &quot;25. No vote tally incorrect after attempt to vote on closed decision&quot;);</span>

<span style="color:#323232;">// 베리피 타트 클로징그 아 데시지옹 트위시 파이우스</span>
<span style="color:#323232;">// Verify that closing a decision twice fails</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[0],</span>
<span style="color:#323232;">context.accounts[0],</span>
<span style="color:#323232;">콘트락트.클로지_데시지옹(데시지옹),</span>
<span style="color:#323232;">contract.close_decision(decision),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_이흐(), &quot;26. 데시지옹 아블리 투 비 클로제드 트위시&quot;)</span>
<span style="color:#323232;">assert!(res.is_err(), &quot;26. Decision able to be closed twice&quot;);</span>

<span style="color:#323232;">// 크레아치 아노테르 데시지옹</span>
<span style="color:#323232;">// Create another decision</span>
<span style="color:#323232;">레트 데시지옹_2 = &quot;아노테르 페아투리 프로포자우&quot;</span>
<span style="color:#323232;">let decision_2 = &quot;Another feature proposal&quot;;</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[0],</span>
<span style="color:#323232;">context.accounts[0],</span>
<span style="color:#323232;">콘트락트.크레아치_데시지옹(데시지옹_2),</span>
<span style="color:#323232;">contract.create_decision(decision_2),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_오크(), &quot;27. 크레아치 세콘드 데시지옹 파일레드&quot;)</span>
<span style="color:#323232;">assert!(res.is_ok(), &quot;27. Create second decision failed&quot;);</span>

<span style="color:#323232;">// 베리피 티 세콘드 데시지옹 와스 크레아테드</span>
<span style="color:#323232;">// Verify the second decision was created</span>
<span style="color:#323232;">레트 데시지옹_다타: 데시지옹 = 비에!(콘트락트.제트_데시지옹(데시지옹_2)).운으라프_즈송()</span>
<span style="color:#323232;">let decision_data: Decision = view!(contract.get_decision(decision_2)).unwrap_json();</span>
<span style="color:#323232;">아세르트_이크!(데시지옹_다타.나미, 데시지옹_2, &quot;28. 세콘드 데시지옹 나미 잉코헥트&quot;)</span>
<span style="color:#323232;">assert_eq!(decision_data.name, decision_2, &quot;28. Second decision name incorrect&quot;);</span>
<span style="color:#323232;">아세르트_이크!(데시지옹_다타.보치_콘트, 0, &quot;29. 이니치아우 보치 콘트 잉코헥트 포르 세콘드 데시지옹&quot;)</span>
<span style="color:#323232;">assert_eq!(decision_data.vote_count, 0, &quot;29. Initial vote count incorrect for second decision&quot;);</span>
<span style="color:#323232;">아세르트_이크!(데시지옹_다타.스타투스, 데시지온스타투스::오펭, &quot;30. 세콘드 데시지옹 스타투스 잉코헥트&quot;)</span>
<span style="color:#323232;">assert_eq!(decision_data.status, DecisionStatus::Open, &quot;30. Second decision status incorrect&quot;);</span>

<span style="color:#323232;">// 베리피 타트 티 피르스트 데시지옹 이스 운샨제드</span>
<span style="color:#323232;">// Verify that the first decision is unchanged</span>
<span style="color:#323232;">레트 데시지옹_다타: 데시지옹 = 비에!(콘트락트.제트_데시지옹(데시지옹)).운으라프_즈송()</span>
<span style="color:#323232;">let decision_data: Decision = view!(contract.get_decision(decision)).unwrap_json();</span>
<span style="color:#323232;">아세르트_이크!(데시지옹_다타.나미, 데시지옹, &quot;31. 피르스트 데시지옹 나미 잉코헥트 아프테르 세콘드 데시지옹 크레아테드&quot;)</span>
<span style="color:#323232;">assert_eq!(decision_data.name, decision, &quot;31. First decision name incorrect after second decision created&quot;);</span>
<span style="color:#323232;">아세르트_이크!(데시지옹_다타.보치_콘트, 3, &quot;32. 피르스트 데시지옹 보치 콘트 잉코헥트 아프테르 세콘드 데시지옹 크레아테드&quot;)</span>
<span style="color:#323232;">assert_eq!(decision_data.vote_count, 3, &quot;32. First decision vote count incorrect after second decision created&quot;);</span>
<span style="color:#323232;">아세르트_이크!(데시지옹_다타.스타투스, 데시지온스타투스::클로제드, &quot;33. 피르스트 데시지옹 스타투스 잉코헥트 아프테르 세콘드 데시지옹 크레아테드&quot;)</span>
<span style="color:#323232;">assert_eq!(decision_data.status, DecisionStatus::Closed, &quot;33. First decision status incorrect after second decision created&quot;);</span>

<span style="color:#323232;">// 트리 투 크레아치 아 데시지옹 위트 티 사미 나미, 소우드 파이우</span>
<span style="color:#323232;">// Try to create a decision with the same name, should fail</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[0],</span>
<span style="color:#323232;">context.accounts[0],</span>
<span style="color:#323232;">콘트락트.크레아치_데시지옹(데시지옹),</span>
<span style="color:#323232;">contract.create_decision(decision),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_이흐(), &quot;34. 아블리 투 크레아치 데시지옹 위트 사미 나미&quot;)</span>
<span style="color:#323232;">assert!(res.is_err(), &quot;34. Able to create decision with same name&quot;);</span>

<span style="color:#323232;">// 베리피 타트 티 피르스트 데시지옹 이스 운샨제드</span>
<span style="color:#323232;">// Verify that the first decision is unchanged</span>
<span style="color:#323232;">레트 데시지옹_다타: 데시지옹 = 비에!(콘트락트.제트_데시지옹(데시지옹)).운으라프_즈송()</span>
<span style="color:#323232;">let decision_data: Decision = view!(contract.get_decision(decision)).unwrap_json();</span>
<span style="color:#323232;">아세르트_이크!(데시지옹_다타.나미, 데시지옹, &quot;35. 피르스트 데시지옹 나미 잉코헥트 아프테르 아템프트 투 크레아치 데시지옹 위트 사미 나미&quot;)</span>
<span style="color:#323232;">assert_eq!(decision_data.name, decision, &quot;35. First decision name incorrect after attempt to create decision with same name&quot;);</span>
<span style="color:#323232;">아세르트_이크!(데시지옹_다타.보치_콘트, 3, &quot;36. 피르스트 데시지옹 보치 콘트 잉코헥트 아프테르 아템프트 투 크레아치 데시지옹 위트 사미 나미&quot;)</span>
<span style="color:#323232;">assert_eq!(decision_data.vote_count, 3, &quot;36. First decision vote count incorrect after attempt to create decision with same name&quot;);</span>
<span style="color:#323232;">아세르트_이크!(데시지옹_다타.스타투스, 데시지온스타투스::클로제드, &quot;37. 피르스트 데시지옹 스타투스 잉코헥트 아프테르 아템프트 투 크레아치 데시지옹 위트 사미 나미&quot;)</span>
<span style="color:#323232;">assert_eq!(decision_data.status, DecisionStatus::Closed, &quot;37. First decision status incorrect after attempt to create decision with same name&quot;);</span>

<span style="color:#323232;">// 트리 투 보치 옹 아 농-이지스텐트 데시지옹, 소우드 파이우</span>
<span style="color:#323232;">// Try to vote on a non-existent decision, should fail</span>
<span style="color:#323232;">레트 농_이지스텐트_데시지옹 = &quot;농-이지스텐트 데시지옹&quot;</span>
<span style="color:#323232;">let non_existent_decision = &quot;Non-existent decision&quot;;</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[1],</span>
<span style="color:#323232;">context.accounts[1],</span>
<span style="color:#323232;">콘트락트.보치(농_이지스텐트_데시지옹, 보치::이스),</span>
<span style="color:#323232;">contract.vote(non_existent_decision, Vote::Yes),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;0.1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;0.1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_이흐(), &quot;38. 아블리 투 보치 옹 농-이지스텐트 데시지옹&quot;)</span>
<span style="color:#323232;">assert!(res.is_err(), &quot;38. Able to vote on non-existent decision&quot;);</span>

<span style="color:#323232;">// 트리 투 제트 아 농-이지스텐트 데시지옹, 소우드 파이우</span>
<span style="color:#323232;">// Try to get a non-existent decision, should fail</span>
<span style="color:#323232;">레트 히스 = 비에!(콘트락트.제트_데시지옹(농_이지스텐트_데시지옹))</span>
<span style="color:#323232;">let res = view!(contract.get_decision(non_existent_decision));</span>
<span style="color:#323232;">아세르트!(히스.이스_이흐(), &quot;39. 아블리 투 제트 농-이지스텐트 데시지옹&quot;)</span>
<span style="color:#323232;">assert!(res.is_err(), &quot;39. Able to get non-existent decision&quot;);</span>

<span style="color:#323232;">// 트리 투 제트 보치 탈리 오프 아 농-이지스텐트 데시지옹, 소우드 파이우</span>
<span style="color:#323232;">// Try to get vote tally of a non-existent decision, should fail</span>
<span style="color:#323232;">레트 히스 = 비에!(콘트락트.제트_보치_탈리(농_이지스텐트_데시지옹))</span>
<span style="color:#323232;">let res = view!(contract.get_vote_tally(non_existent_decision));</span>
<span style="color:#323232;">아세르트!(히스.이스_이흐(), &quot;40. 아블리 투 제트 보치 탈리 오프 농-이지스텐트 데시지옹&quot;)</span>
<span style="color:#323232;">assert!(res.is_err(), &quot;40. Able to get vote tally of non-existent decision&quot;);</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">// 41. 트리 투 클로지 아 농-이지스텐트 데시지옹, 소우드 파이우</span>
<span style="color:#323232;">// 41. Try to close a non-existent decision, should fail</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[0],</span>
<span style="color:#323232;">context.accounts[0],</span>
<span style="color:#323232;">콘트락트.클로지_데시지옹(농_이지스텐트_데시지옹),</span>
<span style="color:#323232;">contract.close_decision(non_existent_decision),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_이흐(), &quot;41. 아블리 투 클로지 농-이지스텐트 데시지옹&quot;)</span>
<span style="color:#323232;">assert!(res.is_err(), &quot;41. Able to close non-existent decision&quot;);</span>

<span style="color:#323232;">// 42. 트리 투 크레아치 아 데시지옹 위토트 아 데포지트, 소우드 파이우</span>
<span style="color:#323232;">// 42. Try to create a decision without a deposit, should fail</span>
<span style="color:#323232;">레트 데시지옹_3 = &quot;티르드 데시지옹 프로포자우&quot;</span>
<span style="color:#323232;">let decision_3 = &quot;Third decision proposal&quot;;</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[0],</span>
<span style="color:#323232;">context.accounts[0],</span>
<span style="color:#323232;">콘트락트.크레아치_데시지옹(데시지옹_3)</span>
<span style="color:#323232;">contract.create_decision(decision_3)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_이흐(), &quot;42. 아블리 투 크레아치 데시지옹 위토트 아 데포지트&quot;)</span>
<span style="color:#323232;">assert!(res.is_err(), &quot;42. Able to create decision without a deposit&quot;);</span>

<span style="color:#323232;">// 43. 트리 투 보치 위토트 아 데포지트, 소우드 파이우</span>
<span style="color:#323232;">// 43. Try to vote without a deposit, should fail</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[2],</span>
<span style="color:#323232;">context.accounts[2],</span>
<span style="color:#323232;">콘트락트.보치(데시지옹_2, 보치::누)</span>
<span style="color:#323232;">contract.vote(decision_2, Vote::No)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_이흐(), &quot;43. 아블리 투 보치 위토트 아 데포지트&quot;)</span>
<span style="color:#323232;">assert!(res.is_err(), &quot;43. Able to vote without a deposit&quot;);</span>

<span style="color:#323232;">// 44. 베리피 타트 아 우제르 카노트 보치 모리 탕 온시 옹 티 사미 데시지옹</span>
<span style="color:#323232;">// 44. Verify that a user cannot vote more than once on the same decision</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[1],</span>
<span style="color:#323232;">context.accounts[1],</span>
<span style="color:#323232;">콘트락트.보치(데시지옹_2, 보치::이스),</span>
<span style="color:#323232;">contract.vote(decision_2, Vote::Yes),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;0.1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;0.1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_오크(), &quot;44. 우제르 노트 아블리 투 보치 피르스트 치미&quot;)</span>
<span style="color:#323232;">assert!(res.is_ok(), &quot;44. User not able to vote first time&quot;);</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[1],</span>
<span style="color:#323232;">context.accounts[1],</span>
<span style="color:#323232;">콘트락트.보치(데시지옹_2, 보치::이스),</span>
<span style="color:#323232;">contract.vote(decision_2, Vote::Yes),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;0.1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;0.1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_이흐(), &quot;45. 우제르 아블리 투 보치 모리 탕 온시&quot;)</span>
<span style="color:#323232;">assert!(res.is_err(), &quot;45. User able to vote more than once&quot;);</span>

<span style="color:#323232;">// 46. 베리피 타트 티 보칭그 리미트 이스 인포르세드</span>
<span style="color:#323232;">// 46. Verify that the voting limit is enforced</span>
<span style="color:#323232;">포르 이 잉 4..15 {</span>
<span style="color:#323232;">for i in 4..15 {</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[이],</span>
<span style="color:#323232;">context.accounts[i],</span>
<span style="color:#323232;">콘트락트.보치(데시지옹_2, 보치::이스),</span>
<span style="color:#323232;">contract.vote(decision_2, Vote::Yes),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;0.1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;0.1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">이프 이 &lt; 10 {</span>
<span style="color:#323232;">if i &lt; 10 {</span>
<span style="color:#323232;">아세르트!(히스.이스_오크(), &quot;46. 우제르 노트 아블리 투 보치 위팅 리미트&quot;)</span>
<span style="color:#323232;">assert!(res.is_ok(), &quot;46. User not able to vote within limit&quot;);</span>
<span style="color:#323232;">} 에우시 {</span>
<span style="color:#323232;">} else {</span>
<span style="color:#323232;">아세르트!(히스.이스_이흐(), &quot;47. 보칭그 리미트 노트 인포르세드&quot;)</span>
<span style="color:#323232;">assert!(res.is_err(), &quot;47. Voting limit not enforced&quot;);</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

<span style="color:#323232;">// 48. 크레아치 아 데시지옹 위트 아 라르지 눔베르 오프 보치스, 베리피 타트 티 콘트락트 캉 안들리 이트</span>
<span style="color:#323232;">// 48. Create a decision with a large number of votes, verify that the contract can handle it</span>
<span style="color:#323232;">레트 데시지옹_4 = &quot;라르지 데시지옹 프로포자우&quot;</span>
<span style="color:#323232;">let decision_4 = &quot;Large decision proposal&quot;;</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[0],</span>
<span style="color:#323232;">context.accounts[0],</span>
<span style="color:#323232;">콘트락트.크레아치_데시지옹(데시지옹_4),</span>
<span style="color:#323232;">contract.create_decision(decision_4),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_오크(), &quot;48. 크레아치 라르지 데시지옹 파일레드&quot;)</span>
<span style="color:#323232;">assert!(res.is_ok(), &quot;48. Create large decision failed&quot;);</span>
<span style="color:#323232;">포르 이 잉 1..100 {</span>
<span style="color:#323232;">for i in 1..100 {</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[이 % 10],</span>
<span style="color:#323232;">context.accounts[i % 10],</span>
<span style="color:#323232;">콘트락트.보치(데시지옹_4, 이프 이 % 2 == 0 { 보치::이스 } 에우시 { 보치::누 }),</span>
<span style="color:#323232;">contract.vote(decision_4, if i % 2 == 0 { Vote::Yes } else { Vote::No }),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;0.1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;0.1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_오크(), &quot;49. 보칭그 옹 라르지 데시지옹 파일레드&quot;)</span>
<span style="color:#323232;">assert!(res.is_ok(), &quot;49. Voting on large decision failed&quot;);</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

<span style="color:#323232;">// 50. 클로지 티 라르지 데시지옹</span>
<span style="color:#323232;">// 50. Close the large decision</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[0],</span>
<span style="color:#323232;">context.accounts[0],</span>
<span style="color:#323232;">콘트락트.클로지_데시지옹(데시지옹_4),</span>
<span style="color:#323232;">contract.close_decision(decision_4),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_오크(), &quot;50. 클로징그 라르지 데시지옹 파일레드&quot;)</span>
<span style="color:#323232;">assert!(res.is_ok(), &quot;50. Closing large decision failed&quot;);</span>

<span style="color:#323232;">// 51. 베리피 타트 티 피나우 보치 콘트 안드 탈리스 아리 코헥트 포르 티 라르지 데시지옹</span>
<span style="color:#323232;">// 51. Verify that the final vote count and tallies are correct for the large decision</span>
<span style="color:#323232;">레트 데시지옹_다타: 데시지옹 = 비에!(콘트락트.제트_데시지옹(데시지옹_4)).운으라프_즈송()</span>
<span style="color:#323232;">let decision_data: Decision = view!(contract.get_decision(decision_4)).unwrap_json();</span>
<span style="color:#323232;">아세르트_이크!(데시지옹_다타.보치_콘트, 99, &quot;51. 보치 콘트 잉코헥트 포르 라르지 데시지옹&quot;)</span>
<span style="color:#323232;">assert_eq!(decision_data.vote_count, 99, &quot;51. Vote count incorrect for large decision&quot;);</span>
<span style="color:#323232;">레트 보치_탈리: 보테탈리 = 비에!(콘트락트.제트_보치_탈리(데시지옹_4)).운으라프_즈송()</span>
<span style="color:#323232;">let vote_tally: VoteTally = view!(contract.get_vote_tally(decision_4)).unwrap_json();</span>
<span style="color:#323232;">아세르트_이크!(보치_탈리.이스, 50, &quot;52. 이스 보치 탈리 잉코헥트 포르 라르지 데시지옹&quot;)</span>
<span style="color:#323232;">assert_eq!(vote_tally.yes, 50, &quot;52. Yes vote tally incorrect for large decision&quot;);</span>
<span style="color:#323232;">아세르트_이크!(보치_탈리.누, 49, &quot;53. 누 보치 탈리 잉코헥트 포르 라르지 데시지옹&quot;)</span>
<span style="color:#323232;">assert_eq!(vote_tally.no, 49, &quot;53. No vote tally incorrect for large decision&quot;);</span>
<span style="color:#323232;">아세르트_이크!(보치_탈리.아브스타잉, 0, &quot;54. 아브스타잉 보치 탈리 잉코헥트 포르 라르지 데시지옹&quot;)</span>
<span style="color:#323232;">assert_eq!(vote_tally.abstain, 0, &quot;54. Abstain vote tally incorrect for large decision&quot;);</span>

<span style="color:#323232;">// 55. 트리 투 보치 아프테르 티 데시지옹 아스 벵 클로제드, 소우드 파이우</span>
<span style="color:#323232;">// 55. Try to vote after the decision has been closed, should fail</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[1],</span>
<span style="color:#323232;">context.accounts[1],</span>
<span style="color:#323232;">콘트락트.보치(데시지옹_4, 보치::이스),</span>
<span style="color:#323232;">contract.vote(decision_4, Vote::Yes),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;0.1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;0.1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_이흐(), &quot;55. 아블리 투 보치 아프테르 데시지옹 클로제드&quot;)</span>
<span style="color:#323232;">assert!(res.is_err(), &quot;55. Able to vote after decision closed&quot;);</span>

<span style="color:#323232;">// 56. 크레아치 아 네 데시지옹 안드 트리 투 클로지 이트 이메지아텔리, 소우드 파이우</span>
<span style="color:#323232;">// 56. Create a new decision and try to close it immediately, should fail</span>
<span style="color:#323232;">레트 데시지옹_5 = &quot;이아를리 클로주리 데시지옹&quot;</span>
<span style="color:#323232;">let decision_5 = &quot;Early closure decision&quot;;</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[0],</span>
<span style="color:#323232;">context.accounts[0],</span>
<span style="color:#323232;">콘트락트.크레아치_데시지옹(데시지옹_5),</span>
<span style="color:#323232;">contract.create_decision(decision_5),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_오크(), &quot;56. 크레아치 이아를리 클로주리 데시지옹 파일레드&quot;)</span>
<span style="color:#323232;">assert!(res.is_ok(), &quot;56. Create early closure decision failed&quot;);</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[0],</span>
<span style="color:#323232;">context.accounts[0],</span>
<span style="color:#323232;">콘트락트.클로지_데시지옹(데시지옹_5),</span>
<span style="color:#323232;">contract.close_decision(decision_5),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_이흐(), &quot;57. 아블리 투 클로지 데시지옹 이메지아텔리 아프테르 크레아치옹&quot;)</span>
<span style="color:#323232;">assert!(res.is_err(), &quot;57. Able to close decision immediately after creation&quot;);</span>

<span style="color:#323232;">// 58. 트리 투 크레아치 아 데시지옹 위트 앙 임프치 나미, 소우드 파이우</span>
<span style="color:#323232;">// 58. Try to create a decision with an empty name, should fail</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[0],</span>
<span style="color:#323232;">context.accounts[0],</span>
<span style="color:#323232;">콘트락트.크레아치_데시지옹(&quot;&quot;),</span>
<span style="color:#323232;">contract.create_decision(&quot;&quot;),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_이흐(), &quot;58. 아블리 투 크레아치 데시지옹 위트 임프치 나미&quot;)</span>
<span style="color:#323232;">assert!(res.is_err(), &quot;58. Able to create decision with empty name&quot;);</span>

<span style="color:#323232;">// 59. 트리 투 보치 위트 앙 임프치 보치, 소우드 파이우</span>
<span style="color:#323232;">// 59. Try to vote with an empty vote, should fail</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[1],</span>
<span style="color:#323232;">context.accounts[1],</span>
<span style="color:#323232;">콘트락트.보치(데시지옹_2, &quot;&quot;),</span>
<span style="color:#323232;">contract.vote(decision_2, &quot;&quot;),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;0.1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;0.1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_이흐(), &quot;59. 아블리 투 보치 위트 임프치 보치&quot;)</span>
<span style="color:#323232;">assert!(res.is_err(), &quot;59. Able to vote with empty vote&quot;);</span>

<span style="color:#323232;">// 60. 크레아치 아 네 데시지옹, 텡 아템프트 투 보치 옹 이트 아스 티 크레아토르, 소우드 파이우</span>
<span style="color:#323232;">// 60. Create a new decision, then attempt to vote on it as the creator, should fail</span>
<span style="color:#323232;">레트 데시지옹_6 = &quot;크레아토르 보칭그 데시지옹&quot;</span>
<span style="color:#323232;">let decision_6 = &quot;Creator voting decision&quot;;</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[0],</span>
<span style="color:#323232;">context.accounts[0],</span>
<span style="color:#323232;">콘트락트.크레아치_데시지옹(데시지옹_6),</span>
<span style="color:#323232;">contract.create_decision(decision_6),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_오크(), &quot;60. 크레아치 크레아토르 보칭그 데시지옹 파일레드&quot;)</span>
<span style="color:#323232;">assert!(res.is_ok(), &quot;60. Create creator voting decision failed&quot;);</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[0],</span>
<span style="color:#323232;">context.accounts[0],</span>
<span style="color:#323232;">콘트락트.보치(데시지옹_6, 보치::이스),</span>
<span style="color:#323232;">contract.vote(decision_6, Vote::Yes),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;0.1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;0.1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_이흐(), &quot;61. 크레아토르 아블리 투 보치 옹 테이르 옹 데시지옹&quot;)</span>
<span style="color:#323232;">assert!(res.is_err(), &quot;61. Creator able to vote on their own decision&quot;);</span>

<span style="color:#323232;">// 62. 트리 투 클로지 아 데시지옹 타트 아스 아우헤아지 벵 클로제드, 소우드 파이우</span>
<span style="color:#323232;">// 62. Try to close a decision that has already been closed, should fail</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[0],</span>
<span style="color:#323232;">context.accounts[0],</span>
<span style="color:#323232;">콘트락트.클로지_데시지옹(데시지옹_2),</span>
<span style="color:#323232;">contract.close_decision(decision_2),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_이흐(), &quot;62. 아블리 투 클로지 데시지옹 타트 아스 아우헤아지 벵 클로제드&quot;)</span>
<span style="color:#323232;">assert!(res.is_err(), &quot;62. Able to close decision that has already been closed&quot;);</span>

<span style="color:#323232;">// 63. 아템프트 투 제트 티 보치 탈리 베포리 티 데시지옹 아스 벵 클로제드, 소우드 파이우</span>
<span style="color:#323232;">// 63. Attempt to get the vote tally before the decision has been closed, should fail</span>
<span style="color:#323232;">레트 히스 = 비에!(콘트락트.제트_보치_탈리(데시지옹_6))</span>
<span style="color:#323232;">let res = view!(contract.get_vote_tally(decision_6));</span>
<span style="color:#323232;">아세르트!(히스.이스_이흐(), &quot;63. 아블리 투 제트 보치 탈리 베포리 데시지옹 클로제드&quot;)</span>
<span style="color:#323232;">assert!(res.is_err(), &quot;63. Able to get vote tally before decision closed&quot;);</span>

<span style="color:#323232;">// 64. 트리 투 크레아치 아 데시지옹 위트 아 베리 롱그 나미, 소우드 파이우</span>
<span style="color:#323232;">// 64. Try to create a decision with a very long name, should fail</span>
<span style="color:#323232;">레트 롱그_나미 = &quot;아&quot;.헤페아트(256)</span>
<span style="color:#323232;">let long_name = &quot;a&quot;.repeat(256);</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[0],</span>
<span style="color:#323232;">context.accounts[0],</span>
<span style="color:#323232;">콘트락트.크레아치_데시지옹(&amp;롱그_나미),</span>
<span style="color:#323232;">contract.create_decision(&amp;long_name),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_이흐(), &quot;64. 아블리 투 크레아치 데시지옹 위트 베리 롱그 나미&quot;)</span>
<span style="color:#323232;">assert!(res.is_err(), &quot;64. Able to create decision with very long name&quot;);</span>

<span style="color:#323232;">// 65. 트리 투 크레아치 아 데시지옹 위트 아 나미 타트 콘타잉스 스페시아우 샤락테르스, 소우드 파이우</span>
<span style="color:#323232;">// 65. Try to create a decision with a name that contains special characters, should fail</span>
<span style="color:#323232;">레트 스페시아우_나미 = &quot;테스트 &amp; 데시지옹 %1&quot;</span>
<span style="color:#323232;">let special_name = &quot;Test &amp; Decision %1&quot;;</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[0],</span>
<span style="color:#323232;">context.accounts[0],</span>
<span style="color:#323232;">콘트락트.크레아치_데시지옹(&amp;스페시아우_나미),</span>
<span style="color:#323232;">contract.create_decision(&amp;special_name),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_이흐(), &quot;65. 아블리 투 크레아치 데시지옹 위트 스페시아우 샤락테르스 잉 나미&quot;)</span>
<span style="color:#323232;">assert!(res.is_err(), &quot;65. Able to create decision with special characters in name&quot;);</span>

<span style="color:#323232;">// 66. 베리피 타트 티 토타우 보치스 두 노트 이세드 티 보칭그 리미트 포르 아 데시지옹</span>
<span style="color:#323232;">// 66. Verify that the total votes do not exceed the voting limit for a decision</span>
<span style="color:#323232;">레트 데시지옹_7 = &quot;보칭그 리미트 데시지옹&quot;</span>
<span style="color:#323232;">let decision_7 = &quot;Voting limit decision&quot;;</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[0],</span>
<span style="color:#323232;">context.accounts[0],</span>
<span style="color:#323232;">콘트락트.크레아치_데시지옹(데시지옹_7),</span>
<span style="color:#323232;">contract.create_decision(decision_7),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_오크(), &quot;66. 크레아치 보칭그 리미트 데시지옹 파일레드&quot;)</span>
<span style="color:#323232;">assert!(res.is_ok(), &quot;66. Create voting limit decision failed&quot;);</span>
<span style="color:#323232;">포르 이 잉 0..101 {</span>
<span style="color:#323232;">for i in 0..101 {</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[이 % 10],</span>
<span style="color:#323232;">context.accounts[i % 10],</span>
<span style="color:#323232;">콘트락트.보치(데시지옹_7, 이프 이 % 2 == 0 { 보치::이스 } 에우시 { 보치::누 }),</span>
<span style="color:#323232;">contract.vote(decision_7, if i % 2 == 0 { Vote::Yes } else { Vote::No }),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;0.1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;0.1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">이프 이 &lt; 100 {</span>
<span style="color:#323232;">if i &lt; 100 {</span>
<span style="color:#323232;">아세르트!(히스.이스_오크(), &quot;67. 보칭그 위팅 리미트 파일레드&quot;)</span>
<span style="color:#323232;">assert!(res.is_ok(), &quot;67. Voting within limit failed&quot;);</span>
<span style="color:#323232;">} 에우시 {</span>
<span style="color:#323232;">} else {</span>
<span style="color:#323232;">아세르트!(히스.이스_이흐(), &quot;68. 아블리 투 보치 베욘드 리미트&quot;)</span>
<span style="color:#323232;">assert!(res.is_err(), &quot;68. Able to vote beyond limit&quot;);</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

<span style="color:#323232;">// 69. 클로지 티 보칭그 리미트 데시지옹</span>
<span style="color:#323232;">// 69. Close the voting limit decision</span>
<span style="color:#323232;">레트 히스 = 카우!(</span>
<span style="color:#323232;">let res = call!(</span>
<span style="color:#323232;">콘테스트.아콘트스[0],</span>
<span style="color:#323232;">context.accounts[0],</span>
<span style="color:#323232;">콘트락트.클로지_데시지옹(데시지옹_7),</span>
<span style="color:#323232;">contract.close_decision(decision_7),</span>
<span style="color:#323232;">데포지트 = 투_욕투(&quot;1&quot;)</span>
<span style="color:#323232;">deposit = to_yocto(&quot;1&quot;)</span>
<span style="color:#323232;">)</span>
<span style="color:#323232;">);</span>
<span style="color:#323232;">아세르트!(히스.이스_오크(), &quot;69. 클로징그 보칭그 리미트 데시지옹 파일레드&quot;)</span>
<span style="color:#323232;">assert!(res.is_ok(), &quot;69. Closing voting limit decision failed&quot;);</span>

<span style="color:#323232;">// 70. 베리피 타트 티 피나우 보치 콘트 안드 탈리스 아리 코헥트 포르 티 보칭그 리미트 데시지옹</span>
<span style="color:#323232;">// 70. Verify that the final vote count and tallies are correct for the voting limit decision</span>
<span style="color:#323232;">레트 데시지옹_다타: 데시지옹 = 비에!(콘트락트.제트_데시지옹(데시지옹_7)).운으라프_즈송()</span>
<span style="color:#323232;">let decision_data: Decision = view!(contract.get_decision(decision_7)).unwrap_json();</span>
<span style="color:#323232;">아세르트_이크!(데시지옹_다타.보치_콘트, 100, &quot;70. 보치 콘트 잉코헥트 포르 보칭그 리미트 데시지옹&quot;)</span>
<span style="color:#323232;">assert_eq!(decision_data.vote_count, 100, &quot;70. Vote count incorrect for voting limit decision&quot;);</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

</pre><pre>
<span style="color:#323232;">이 무스트 헤이테라치 타트 테지 아리 제네랄리제드 테스트 카지스 안드 테리 미그트 비 스페시피크 시투아치옹스 오르 헤키레멘트스 잉 요르 코데바지 타트 네드 투 비 테스테드 아코르징글리.</span>
<span style="color:#323232;">I must reiterate that these are generalized test cases and there might be specific situations or requirements in your codebase that need to be tested accordingly.</span>

<span style="color:#323232;">## 리치 프롱 71 투 90 티 모스트 임포르탄트 프로페르치 바제드 테스트스 우징그 아프로프리아치 크라치스 포르 이트 콘시데링그 수시 인트리카치 보칭그 시스텡</span>
<span style="color:#323232;">## write from 71 to 90 the most important property based tests using appropriate crates for it considering such intricate voting system</span>

<span style="color:#323232;">&lt; 프로페르치-바제드 테스칭그 인보우베스 제네라칭그 한동 인푸트스 안드 베리핑그 타트 세르타잉 프로페르치스 오우드, 하테르 탕 셰킹그 티 헤주우트 포르 아 스페시피크 인푸트. 이트&#39;스 모리 아보트 티 베아비오르 오프 요르 프로그랑 지벵 아 라르지 아몬트 오프 다타 안드 레스 아보트 티 코헥트네스 오프 스페시피크 헤주우트스. 잉 후스트, 티 프로프테스트 크라치 이스 치피칼리 우제드 포르 프로페르치-바제드 테스칭그.</span>
<span style="color:#323232;">&lt; Property-based testing involves generating random inputs and verifying that certain properties hold, rather than checking the result for a specific input. It&#39;s more about the behavior of your program given a large amount of data and less about the correctness of specific results. In Rust, the proptest crate is typically used for property-based testing.</span>

<span style="color:#323232;">```후스트</span>
<span style="color:#323232;">```rust</span>
<span style="color:#323232;">우지 프로프테스트::프렐루지::*</span>
<span style="color:#323232;">use proptest::prelude::*;</span>
<span style="color:#323232;">우지 크라치::콘트락트::{콘트락트, 보치, 데시지옹}</span>
<span style="color:#323232;">use crate::contract::{Contract, Vote, Decision};</span>
<span style="color:#323232;">우지 네아르_스드크::아콘치드</span>
<span style="color:#323232;">use near_sdk::AccountId;</span>
<span style="color:#323232;">우지 네아르_스드크_싱::투_욕투</span>
<span style="color:#323232;">use near_sdk_sim::to_yocto;</span>

<span style="color:#323232;">// 71. 테스트 타트 데시지옹 나미 렝그트 이스 아우와이스 발리드</span>
<span style="color:#323232;">// 71. Test that decision name length is always valid</span>
<span style="color:#323232;">프로프테스트! {</span>
<span style="color:#323232;">proptest! {</span>
<span style="color:#323232;">#[테스트]</span>
<span style="color:#323232;">#[test]</span>
<span style="color:#323232;">픙 프로프_데시지옹_나미_렝그트(스 잉 &quot;\\프크*&quot;) {</span>
<span style="color:#323232;">fn prop_decision_name_length(s in &quot;\\PC*&quot;) {</span>
<span style="color:#323232;">레트 콘트락트 = 콘트락트::네()</span>
<span style="color:#323232;">let contract = Contract::new();</span>
<span style="color:#323232;">레트 히스 = 콘트락트.크레아치_데시지옹(&amp;스, 데포지트 = 투_욕투(&quot;1&quot;))</span>
<span style="color:#323232;">let res = contract.create_decision(&amp;s, deposit = to_yocto(&quot;1&quot;));</span>
<span style="color:#323232;">프로프_아세르트!(스.렝() &lt;= 255, &quot;71. 데시지옹 나미 토 롱그&quot;)</span>
<span style="color:#323232;">prop_assert!(s.len() &lt;= 255, &quot;71. Decision name too long&quot;);</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

<span style="color:#323232;">// 72. 테스트 타트 보치 치페스 아리 아우와이스 발리드</span>
<span style="color:#323232;">// 72. Test that vote types are always valid</span>
<span style="color:#323232;">프로프테스트! {</span>
<span style="color:#323232;">proptest! {</span>
<span style="color:#323232;">#[테스트]</span>
<span style="color:#323232;">#[test]</span>
<span style="color:#323232;">픙 프로프_보치_치피(보치 잉 아니::&lt;보치&gt;()) {</span>
<span style="color:#323232;">fn prop_vote_type(vote in any::&lt;Vote&gt;()) {</span>
<span style="color:#323232;">프로프_아세르트!(보치 == 보치::이스 || 보치 == 보치::누 || 보치 == 보치::아브스타잉, &quot;72. 인발리드 보치 치피&quot;)</span>
<span style="color:#323232;">prop_assert!(vote == Vote::Yes || vote == Vote::No || vote == Vote::Abstain, &quot;72. Invalid vote type&quot;);</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

<span style="color:#323232;">// 73. 테스트 타트 데포지트 아몬트 이스 아우와이스 발리드 포르 데시지옹 크레아치옹</span>
<span style="color:#323232;">// 73. Test that deposit amount is always valid for decision creation</span>
<span style="color:#323232;">프로프테스트! {</span>
<span style="color:#323232;">proptest! {</span>
<span style="color:#323232;">#[테스트]</span>
<span style="color:#323232;">#[test]</span>
<span style="color:#323232;">픙 프로프_데시지옹_데포지트_아몬트(데포지트 잉 아니::&lt;우128&gt;()) {</span>
<span style="color:#323232;">fn prop_decision_deposit_amount(deposit in any::&lt;u128&gt;()) {</span>
<span style="color:#323232;">레트 콘트락트 = 콘트락트::네()</span>
<span style="color:#323232;">let contract = Contract::new();</span>
<span style="color:#323232;">레트 히스 = 콘트락트.크레아치_데시지옹(&quot;데시지옹&quot;, 데포지트 = 데포지트)</span>
<span style="color:#323232;">let res = contract.create_decision(&quot;decision&quot;, deposit = deposit);</span>
<span style="color:#323232;">프로프_아세르트!(데포지트 &gt;= 투_욕투(&quot;1&quot;), &quot;73. 데포지트 토 스마우 포르 데시지옹 크레아치옹&quot;)</span>
<span style="color:#323232;">prop_assert!(deposit &gt;= to_yocto(&quot;1&quot;), &quot;73. Deposit too small for decision creation&quot;);</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

<span style="color:#323232;">// 74. 테스트 타트 데포지트 아몬트 이스 아우와이스 발리드 포르 보칭그</span>
<span style="color:#323232;">// 74. Test that deposit amount is always valid for voting</span>
<span style="color:#323232;">프로프테스트! {</span>
<span style="color:#323232;">proptest! {</span>
<span style="color:#323232;">#[테스트]</span>
<span style="color:#323232;">#[test]</span>
<span style="color:#323232;">픙 프로프_보치_데포지트_아몬트(데포지트 잉 아니::&lt;우128&gt;()) {</span>
<span style="color:#323232;">fn prop_vote_deposit_amount(deposit in any::&lt;u128&gt;()) {</span>
<span style="color:#323232;">레트 콘트락트 = 콘트락트::네()</span>
<span style="color:#323232;">let contract = Contract::new();</span>
<span style="color:#323232;">콘트락트.크레아치_데시지옹(&quot;데시지옹&quot;, 데포지트 = 투_욕투(&quot;1&quot;)).운으라프()</span>
<span style="color:#323232;">contract.create_decision(&quot;decision&quot;, deposit = to_yocto(&quot;1&quot;)).unwrap();</span>
<span style="color:#323232;">레트 히스 = 콘트락트.보치(&quot;데시지옹&quot;, 보치::이스, 데포지트 = 데포지트)</span>
<span style="color:#323232;">let res = contract.vote(&quot;decision&quot;, Vote::Yes, deposit = deposit);</span>
<span style="color:#323232;">프로프_아세르트!(데포지트 &gt;= 투_욕투(&quot;0.1&quot;), &quot;74. 데포지트 토 스마우 포르 보칭그&quot;)</span>
<span style="color:#323232;">prop_assert!(deposit &gt;= to_yocto(&quot;0.1&quot;), &quot;74. Deposit too small for voting&quot;);</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

<span style="color:#323232;">// 75. 테스트 타트 데시지옹 카노트 비 클로제드 이메지아텔리 아프테르 크레아치옹</span>
<span style="color:#323232;">// 75. Test that decision cannot be closed immediately after creation</span>
<span style="color:#323232;">프로프테스트! {</span>
<span style="color:#323232;">proptest! {</span>
<span style="color:#323232;">#[테스트]</span>
<span style="color:#323232;">#[test]</span>
<span style="color:#323232;">픙 프로프_데시지옹_클로지_치밍그(스 잉 &quot;\\프크*&quot;) {</span>
<span style="color:#323232;">fn prop_decision_close_timing(s in &quot;\\PC*&quot;) {</span>
<span style="color:#323232;">레트 콘트락트 = 콘트락트::네()</span>
<span style="color:#323232;">let contract = Contract::new();</span>
<span style="color:#323232;">콘트락트.크레아치_데시지옹(&amp;스, 데포지트 = 투_욕투(&quot;1&quot;)).운으라프()</span>
<span style="color:#323232;">contract.create_decision(&amp;s, deposit = to_yocto(&quot;1&quot;)).unwrap();</span>
<span style="color:#323232;">레트 히스 = 콘트락트.클로지_데시지옹(&amp;스, 데포지트 = 투_욕투(&quot;1&quot;))</span>
<span style="color:#323232;">let res = contract.close_decision(&amp;s, deposit = to_yocto(&quot;1&quot;));</span>
<span style="color:#323232;">프로프_아세르트!(히스.이스_이흐(), &quot;75. 데시지옹 클로제드 이메지아텔리 아프테르 크레아치옹&quot;)</span>
<span style="color:#323232;">prop_assert!(res.is_err(), &quot;75. Decision closed immediately after creation&quot;);</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

<span style="color:#323232;">// 76. 테스트 타트 크레아토르 카노트 보치 옹 테이르 옹 데시지옹</span>
<span style="color:#323232;">// 76. Test that creator cannot vote on their own decision</span>
<span style="color:#323232;">프로프테스트! {</span>
<span style="color:#323232;">proptest! {</span>
<span style="color:#323232;">#[테스트]</span>
<span style="color:#323232;">#[test]</span>
<span style="color:#323232;">픙 프로프_크레아토르_카노트_보치(스 잉 &quot;\\프크*&quot;) {</span>
<span style="color:#323232;">fn prop_creator_cannot_vote(s in &quot;\\PC*&quot;) {</span>
<span style="color:#323232;">레트 콘트락트 = 콘트락트::네()</span>
<span style="color:#323232;">let contract = Contract::new();</span>
<span style="color:#323232;">콘트락트.크레아치_데시지옹(&amp;스, 데포지트 = 투_욕투(&quot;1&quot;)).운으라프()</span>
<span style="color:#323232;">contract.create_decision(&amp;s, deposit = to_yocto(&quot;1&quot;)).unwrap();</span>
<span style="color:#323232;">레트 히스 = 콘트락트.보치(&amp;스, 보치::이스, 데포지트 = 투_욕투(&quot;0.1&quot;))</span>
<span style="color:#323232;">let res = contract.vote(&amp;s, Vote::Yes, deposit = to_yocto(&quot;0.1&quot;));</span>
<span style="color:#323232;">프로프_아세르트!(히스.이스_이흐(), &quot;76. 크레아토르 보테드 옹 테이르 옹 데시지옹&quot;)</span>
<span style="color:#323232;">prop_assert!(res.is_err(), &quot;76. Creator voted on their own decision&quot;);</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

<span style="color:#323232;">// 77. 테스트 타트 보치 콘트 도이스 노트 이세드 티 보칭그 리미트 포르 아 데시지옹</span>
<span style="color:#323232;">// 77. Test that vote count does not exceed the voting limit for a decision</span>
<span style="color:#323232;">프로프테스트! {</span>
<span style="color:#323232;">proptest! {</span>
<span style="color:#323232;">#[테스트]</span>
<span style="color:#323232;">#[test]</span>
<span style="color:#323232;">픙 프로프_보치_콘트_리미트(스 잉 &quot;\\프크*&quot;) {</span>
<span style="color:#323232;">fn prop_vote_count_limit(s in &quot;\\PC*&quot;) {</span>
<span style="color:#323232;">레트 콘트락트 = 콘트락트::네()</span>
<span style="color:#323232;">let contract = Contract::new();</span>
<span style="color:#323232;">콘트락트.크레아치_데시지옹(&amp;스, 데포지트 = 투_욕투(&quot;1&quot;)).운으라프()</span>
<span style="color:#323232;">contract.create_decision(&amp;s, deposit = to_yocto(&quot;1&quot;)).unwrap();</span>
<span style="color:#323232;">포르 이 잉 0..101 {</span>
<span style="color:#323232;">for i in 0..101 {</span>
<span style="color:#323232;">레트 히스 = 콘트락트.보치(&amp;스, 이프 이 % 2 == 0 { 보치::이스 } 에우시 { 보치::누 }, 데포지트 = 투_욕투(&quot;0.1&quot;))</span>
<span style="color:#323232;">let res = contract.vote(&amp;s, if i % 2 == 0 { Vote::Yes } else { Vote::No }, deposit = to_yocto(&quot;0.1&quot;));</span>
<span style="color:#323232;">이프 이 &lt; 100 {</span>
<span style="color:#323232;">if i &lt; 100 {</span>
<span style="color:#323232;">프로프_아세르트!(히스.이스_오크(), &quot;77. 보칭그 위팅 리미트 파일레드&quot;)</span>
<span style="color:#323232;">prop_assert!(res.is_ok(), &quot;77. Voting within limit failed&quot;);</span>
<span style="color:#323232;">} 에우시 {</span>
<span style="color:#323232;">} else {</span>
<span style="color:#323232;">프로프_아세르트!(히스.이스_이흐(), &quot;78. 아블리 투 보치 베욘드 리미트&quot;)</span>
<span style="color:#323232;">prop_assert!(res.is_err(), &quot;78. Able to vote beyond limit&quot;);</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

<span style="color:#323232;">// 79. 테스트 타트 티 피나우 보치 콘트 안드 탈리스 아리 코헥트 포르 아 데시지옹</span>
<span style="color:#323232;">// 79. Test that the final vote count and tallies are correct for a decision</span>
<span style="color:#323232;">프로프테스트! {</span>
<span style="color:#323232;">proptest! {</span>
<span style="color:#323232;">#[테스트]</span>
<span style="color:#323232;">#[test]</span>
<span style="color:#323232;">픙 프로프_피나우_보치_콘트(스 잉 &quot;\\프크*&quot;) {</span>
<span style="color:#323232;">fn prop_final_vote_count(s in &quot;\\PC*&quot;) {</span>
<span style="color:#323232;">레트 콘트락트 = 콘트락트::네()</span>
<span style="color:#323232;">let contract = Contract::new();</span>
<span style="color:#323232;">콘트락트.크레아치_데시지옹(&amp;스, 데포지트 = 투_욕투(&quot;1&quot;)).운으라프()</span>
<span style="color:#323232;">contract.create_decision(&amp;s, deposit = to_yocto(&quot;1&quot;)).unwrap();</span>
<span style="color:#323232;">포르 이 잉 0..100 {</span>
<span style="color:#323232;">for i in 0..100 {</span>
<span style="color:#323232;">콘트락트.보치(&amp;스, 이프 이 % 2 == 0 { 보치::이스 } 에우시 { 보치::누 }, 데포지트 = 투_욕투(&quot;0.1&quot;)).운으라프()</span>
<span style="color:#323232;">contract.vote(&amp;s, if i % 2 == 0 { Vote::Yes } else { Vote::No }, deposit = to_yocto(&quot;0.1&quot;)).unwrap();</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">콘트락트.클로지_데시지옹(&amp;스, 데포지트 = 투_욕투(&quot;1&quot;)).운으라프()</span>
<span style="color:#323232;">contract.close_decision(&amp;s, deposit = to_yocto(&quot;1&quot;)).unwrap();</span>
<span style="color:#323232;">레트 데시지옹_다타: 데시지옹 = 콘트락트.제트_데시지옹(&amp;스).운으라프()</span>
<span style="color:#323232;">let decision_data: Decision = contract.get_decision(&amp;s).unwrap();</span>
<span style="color:#323232;">프로프_아세르트_이크!(데시지옹_다타.보치_콘트, 100, &quot;79. 보치 콘트 잉코헥트 포르 데시지옹&quot;)</span>
<span style="color:#323232;">prop_assert_eq!(decision_data.vote_count, 100, &quot;79. Vote count incorrect for decision&quot;);</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

<span style="color:#323232;">// 80. 테스트 타트 티 토타우 데포지테드 아몬트 이스 코헥트 포르 아 데시지옹</span>
<span style="color:#323232;">// 80. Test that the total deposited amount is correct for a decision</span>
<span style="color:#323232;">프로프테스트! {</span>
<span style="color:#323232;">proptest! {</span>
<span style="color:#323232;">#[테스트]</span>
<span style="color:#323232;">#[test]</span>
<span style="color:#323232;">픙 프로프_토타우_데포지트(스 잉 &quot;\\프크*&quot;) {</span>
<span style="color:#323232;">fn prop_total_deposit(s in &quot;\\PC*&quot;) {</span>
<span style="color:#323232;">레트 콘트락트 = 콘트락트::네()</span>
<span style="color:#323232;">let contract = Contract::new();</span>
<span style="color:#323232;">콘트락트.크레아치_데시지옹(&amp;스, 데포지트 = 투_욕투(&quot;1&quot;)).운으라프()</span>
<span style="color:#323232;">contract.create_decision(&amp;s, deposit = to_yocto(&quot;1&quot;)).unwrap();</span>
<span style="color:#323232;">포르 이 잉 0..100 {</span>
<span style="color:#323232;">for i in 0..100 {</span>
<span style="color:#323232;">콘트락트.보치(&amp;스, 이프 이 % 2 == 0 { 보치::이스 } 에우시 { 보치::누 }, 데포지트 = 투_욕투(&quot;0.1&quot;)).운으라프()</span>
<span style="color:#323232;">contract.vote(&amp;s, if i % 2 == 0 { Vote::Yes } else { Vote::No }, deposit = to_yocto(&quot;0.1&quot;)).unwrap();</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">레트 데시지옹_다타: 데시지옹 = 콘트락트.제트_데시지옹(&amp;스).운으라프()</span>
<span style="color:#323232;">let decision_data: Decision = contract.get_decision(&amp;s).unwrap();</span>
<span style="color:#323232;">프로프_아세르트_이크!(데시지옹_다타.토타우_데포지트, 투_욕투(&quot;10&quot;) + 투_욕투(&quot;1&quot;), &quot;80. 토타우 데포지트 잉코헥트 포르 데시지옹&quot;)</span>
<span style="color:#323232;">prop_assert_eq!(decision_data.total_deposit, to_yocto(&quot;10&quot;) + to_yocto(&quot;1&quot;), &quot;80. Total deposit incorrect for decision&quot;);</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

<span style="color:#323232;">// 81. 테스트 타트 티 보칭그 헤주우트스 아리 아우와이스 코헥트</span>
<span style="color:#323232;">// 81. Test that the voting results are always correct</span>
<span style="color:#323232;">프로프테스트! {</span>
<span style="color:#323232;">proptest! {</span>
<span style="color:#323232;">#[테스트]</span>
<span style="color:#323232;">#[test]</span>
<span style="color:#323232;">픙 프로프_보칭그_헤주우트스(스 잉 &quot;\\프크*&quot;) {</span>
<span style="color:#323232;">fn prop_voting_results(s in &quot;\\PC*&quot;) {</span>
<span style="color:#323232;">레트 콘트락트 = 콘트락트::네()</span>
<span style="color:#323232;">let contract = Contract::new();</span>
<span style="color:#323232;">콘트락트.크레아치_데시지옹(&amp;스, 데포지트 = 투_욕투(&quot;1&quot;)).운으라프()</span>
<span style="color:#323232;">contract.create_decision(&amp;s, deposit = to_yocto(&quot;1&quot;)).unwrap();</span>
<span style="color:#323232;">포르 이 잉 0..100 {</span>
<span style="color:#323232;">for i in 0..100 {</span>
<span style="color:#323232;">콘트락트.보치(&amp;스, 이프 이 % 2 == 0 { 보치::이스 } 에우시 { 보치::누 }, 데포지트 = 투_욕투(&quot;0.1&quot;)).운으라프()</span>
<span style="color:#323232;">contract.vote(&amp;s, if i % 2 == 0 { Vote::Yes } else { Vote::No }, deposit = to_yocto(&quot;0.1&quot;)).unwrap();</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">콘트락트.클로지_데시지옹(&amp;스, 데포지트 = 투_욕투(&quot;1&quot;)).운으라프()</span>
<span style="color:#323232;">contract.close_decision(&amp;s, deposit = to_yocto(&quot;1&quot;)).unwrap();</span>
<span style="color:#323232;">레트 데시지옹_다타: 데시지옹 = 콘트락트.제트_데시지옹(&amp;스).운으라프()</span>
<span style="color:#323232;">let decision_data: Decision = contract.get_decision(&amp;s).unwrap();</span>
<span style="color:#323232;">레트 이스펙테드_이스_보치스 = 50</span>
<span style="color:#323232;">let expected_yes_votes = 50;</span>
<span style="color:#323232;">레트 이스펙테드_누_보치스 = 50</span>
<span style="color:#323232;">let expected_no_votes = 50;</span>
<span style="color:#323232;">프로프_아세르트_이크!(데시지옹_다타.이스_보치스, 이스펙테드_이스_보치스, &quot;81. 이스 보치스 잉코헥트 포르 데시지옹&quot;)</span>
<span style="color:#323232;">prop_assert_eq!(decision_data.yes_votes, expected_yes_votes, &quot;81. Yes votes incorrect for decision&quot;);</span>
<span style="color:#323232;">프로프_아세르트_이크!(데시지옹_다타.누_보치스, 이스펙테드_누_보치스, &quot;82. 누 보치스 잉코헥트 포르 데시지옹&quot;)</span>
<span style="color:#323232;">prop_assert_eq!(decision_data.no_votes, expected_no_votes, &quot;82. No votes incorrect for decision&quot;);</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

<span style="color:#323232;">// 83. 테스트 타트 온리 티 크레아토르 캉 클로지 티 데시지옹</span>
<span style="color:#323232;">// 83. Test that only the creator can close the decision</span>
<span style="color:#323232;">프로프테스트! {</span>
<span style="color:#323232;">proptest! {</span>
<span style="color:#323232;">#[테스트]</span>
<span style="color:#323232;">#[test]</span>
<span style="color:#323232;">픙 프로프_온리_크레아토르_캉_클로지(스 잉 &quot;\\프크*&quot;, 이드 잉 아니::&lt;아콘치드&gt;()) {</span>
<span style="color:#323232;">fn prop_only_creator_can_close(s in &quot;\\PC*&quot;, id in any::&lt;AccountId&gt;()) {</span>
<span style="color:#323232;">레트 콘트락트 = 콘트락트::네()</span>
<span style="color:#323232;">let contract = Contract::new();</span>
<span style="color:#323232;">콘트락트.크레아치_데시지옹(&amp;스, 데포지트 = 투_욕투(&quot;1&quot;)).운으라프()</span>
<span style="color:#323232;">contract.create_decision(&amp;s, deposit = to_yocto(&quot;1&quot;)).unwrap();</span>
<span style="color:#323232;">레트 히스 = 콘트락트.아스(이드).클로지_데시지옹(&amp;스, 데포지트 = 투_욕투(&quot;1&quot;))</span>
<span style="color:#323232;">let res = contract.as(id).close_decision(&amp;s, deposit = to_yocto(&quot;1&quot;));</span>
<span style="color:#323232;">프로프_아세르트!(히스.이스_이흐(), &quot;83. 농-크레아토르 클로제드 데시지옹&quot;)</span>
<span style="color:#323232;">prop_assert!(res.is_err(), &quot;83. Non-creator closed decision&quot;);</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

<span style="color:#323232;">// 84. 테스트 타트 보치스 카노트 비 카스트 아프테르 데시지옹 이스 클로제드</span>
<span style="color:#323232;">// 84. Test that votes cannot be cast after decision is closed</span>
<span style="color:#323232;">프로프테스트! {</span>
<span style="color:#323232;">proptest! {</span>
<span style="color:#323232;">#[테스트]</span>
<span style="color:#323232;">#[test]</span>
<span style="color:#323232;">픙 프로프_누_보치스_아프테르_클로지(스 잉 &quot;\\프크*&quot;) {</span>
<span style="color:#323232;">fn prop_no_votes_after_close(s in &quot;\\PC*&quot;) {</span>
<span style="color:#323232;">레트 콘트락트 = 콘트락트::네()</span>
<span style="color:#323232;">let contract = Contract::new();</span>
<span style="color:#323232;">콘트락트.크레아치_데시지옹(&amp;스, 데포지트 = 투_욕투(&quot;1&quot;)).운으라프()</span>
<span style="color:#323232;">contract.create_decision(&amp;s, deposit = to_yocto(&quot;1&quot;)).unwrap();</span>
<span style="color:#323232;">콘트락트.클로지_데시지옹(&amp;스, 데포지트 = 투_욕투(&quot;1&quot;)).운으라프()</span>
<span style="color:#323232;">contract.close_decision(&amp;s, deposit = to_yocto(&quot;1&quot;)).unwrap();</span>
<span style="color:#323232;">레트 히스 = 콘트락트.보치(&amp;스, 보치::이스, 데포지트 = 투_욕투(&quot;0.1&quot;))</span>
<span style="color:#323232;">let res = contract.vote(&amp;s, Vote::Yes, deposit = to_yocto(&quot;0.1&quot;));</span>
<span style="color:#323232;">프로프_아세르트!(히스.이스_이흐(), &quot;84. 아블리 투 보치 아프테르 데시지옹 클로제드&quot;)</span>
<span style="color:#323232;">prop_assert!(res.is_err(), &quot;84. Able to vote after decision closed&quot;);</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

<span style="color:#323232;">// 85. 테스트 타트 티 피나우 데시지옹 오트코미 이스 코헥트 바제드 옹 티 마조리치 오프 보치스</span>
<span style="color:#323232;">// 85. Test that the final decision outcome is correct based on the majority of votes</span>
<span style="color:#323232;">프로프테스트! {</span>
<span style="color:#323232;">proptest! {</span>
<span style="color:#323232;">#[테스트]</span>
<span style="color:#323232;">#[test]</span>
<span style="color:#323232;">픙 프로프_피나우_데시지옹_오트코미(스 잉 &quot;\\프크*&quot;) {</span>
<span style="color:#323232;">fn prop_final_decision_outcome(s in &quot;\\PC*&quot;) {</span>
<span style="color:#323232;">레트 콘트락트 = 콘트락트::네()</span>
<span style="color:#323232;">let contract = Contract::new();</span>
<span style="color:#323232;">콘트락트.크레아치_데시지옹(&amp;스, 데포지트 = 투_욕투(&quot;1&quot;)).운으라프()</span>
<span style="color:#323232;">contract.create_decision(&amp;s, deposit = to_yocto(&quot;1&quot;)).unwrap();</span>
<span style="color:#323232;">포르 이 잉 0..60 {</span>
<span style="color:#323232;">for i in 0..60 {</span>
<span style="color:#323232;">콘트락트.보치(&amp;스, 보치::이스, 데포지트 = 투_욕투(&quot;0.1&quot;)).운으라프()</span>
<span style="color:#323232;">contract.vote(&amp;s, Vote::Yes, deposit = to_yocto(&quot;0.1&quot;)).unwrap();</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">포르 이 잉 0..40 {</span>
<span style="color:#323232;">for i in 0..40 {</span>
<span style="color:#323232;">콘트락트.보치(&amp;스, 보치::누, 데포지트 = 투_욕투(&quot;0.1&quot;)).운으라프()</span>
<span style="color:#323232;">contract.vote(&amp;s, Vote::No, deposit = to_yocto(&quot;0.1&quot;)).unwrap();</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">콘트락트.클로지_데시지옹(&amp;스, 데포지트 = 투_욕투(&quot;1&quot;)).운으라프()</span>
<span style="color:#323232;">contract.close_decision(&amp;s, deposit = to_yocto(&quot;1&quot;)).unwrap();</span>
<span style="color:#323232;">레트 데시지옹_다타: 데시지옹 = 콘트락트.제트_데시지옹(&amp;스).운으라프()</span>
<span style="color:#323232;">let decision_data: Decision = contract.get_decision(&amp;s).unwrap();</span>
<span style="color:#323232;">프로프_아세르트_이크!(데시지옹_다타.오트코미, 소미(보치::이스), &quot;85. 데시지옹 오트코미 잉코헥트&quot;)</span>
<span style="color:#323232;">prop_assert_eq!(decision_data.outcome, Some(Vote::Yes), &quot;85. Decision outcome incorrect&quot;);</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

<span style="color:#323232;">// 86. 테스트 타트 콘트락트 카우스 파이우 위트 인수피시엔트 푼드스</span>
<span style="color:#323232;">// 86. Test that contract calls fail with insufficient funds</span>
<span style="color:#323232;">프로프테스트! {</span>
<span style="color:#323232;">proptest! {</span>
<span style="color:#323232;">#[테스트]</span>
<span style="color:#323232;">#[test]</span>
<span style="color:#323232;">픙 프로프_인수피시엔트_푼드스(스 잉 &quot;\\프크*&quot;) {</span>
<span style="color:#323232;">fn prop_insufficient_funds(s in &quot;\\PC*&quot;) {</span>
<span style="color:#323232;">레트 콘트락트 = 콘트락트::네()</span>
<span style="color:#323232;">let contract = Contract::new();</span>
<span style="color:#323232;">레트 히스 = 콘트락트.크레아치_데시지옹(&amp;스, 데포지트 = 0)</span>
<span style="color:#323232;">let res = contract.create_decision(&amp;s, deposit = 0);</span>
<span style="color:#323232;">프로프_아세르트!(히스.이스_이흐(), &quot;86. 데시지옹 크레아테드 위트 인수피시엔트 푼드스&quot;)</span>
<span style="color:#323232;">prop_assert!(res.is_err(), &quot;86. Decision created with insufficient funds&quot;);</span>
<span style="color:#323232;">레트 히스 = 콘트락트.보치(&amp;스, 보치::이스, 데포지트 = 0)</span>
<span style="color:#323232;">let res = contract.vote(&amp;s, Vote::Yes, deposit = 0);</span>
<span style="color:#323232;">프로프_아세르트!(히스.이스_이흐(), &quot;87. 보치 카스트 위트 인수피시엔트 푼드스&quot;)</span>
<span style="color:#323232;">prop_assert!(res.is_err(), &quot;87. Vote cast with insufficient funds&quot;);</span>
<span style="color:#323232;">레트 히스 = 콘트락트.클로지_데시지옹(&amp;스, 데포지트 = 0)</span>
<span style="color:#323232;">let res = contract.close_decision(&amp;s, deposit = 0);</span>
<span style="color:#323232;">프로프_아세르트!(히스.이스_이흐(), &quot;88. 데시지옹 클로제드 위트 인수피시엔트 푼드스&quot;)</span>
<span style="color:#323232;">prop_assert!(res.is_err(), &quot;88. Decision closed with insufficient funds&quot;);</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

<span style="color:#323232;">// 89. 테스트 타트 데시지옹 나메스 아리 아우와이스 우니키</span>
<span style="color:#323232;">// 89. Test that decision names are always unique</span>
<span style="color:#323232;">프로프테스트! {</span>
<span style="color:#323232;">proptest! {</span>
<span style="color:#323232;">#[테스트]</span>
<span style="color:#323232;">#[test]</span>
<span style="color:#323232;">픙 프로프_우니키_데시지옹_나미(스 잉 &quot;\\프크*&quot;) {</span>
<span style="color:#323232;">fn prop_unique_decision_name(s in &quot;\\PC*&quot;) {</span>
<span style="color:#323232;">레트 콘트락트 = 콘트락트::네()</span>
<span style="color:#323232;">let contract = Contract::new();</span>
<span style="color:#323232;">콘트락트.크레아치_데시지옹(&amp;스, 데포지트 = 투_욕투(&quot;1&quot;)).운으라프()</span>
<span style="color:#323232;">contract.create_decision(&amp;s, deposit = to_yocto(&quot;1&quot;)).unwrap();</span>
<span style="color:#323232;">레트 히스 = 콘트락트.크레아치_데시지옹(&amp;스, 데포지트 = 투_욕투(&quot;1&quot;))</span>
<span style="color:#323232;">let res = contract.create_decision(&amp;s, deposit = to_yocto(&quot;1&quot;));</span>
<span style="color:#323232;">프로프_아세르트!(히스.이스_이흐(), &quot;89. 두플리카치 데시지옹 나미&quot;)</span>
<span style="color:#323232;">prop_assert!(res.is_err(), &quot;89. Duplicate decision name&quot;);</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

<span style="color:#323232;">// 90. 테스트 타트 데시지옹 나미 카노트 비 임프치</span>
<span style="color:#323232;">// 90. Test that decision name cannot be empty</span>
<span style="color:#323232;">프로프테스트! {</span>
<span style="color:#323232;">proptest! {</span>
<span style="color:#323232;">#[테스트]</span>
<span style="color:#323232;">#[test]</span>
<span style="color:#323232;">픙 프로프_농_임프치_데시지옹_나미(스 잉 &quot;\\프크*&quot;) {</span>
<span style="color:#323232;">fn prop_non_empty_decision_name(s in &quot;\\PC*&quot;) {</span>
<span style="color:#323232;">레트 콘트락트 = 콘트락트::네()</span>
<span style="color:#323232;">let contract = Contract::new();</span>
<span style="color:#323232;">레트 히스 = 콘트락트.크레아치_데시지옹(&quot;&quot;, 데포지트 = 투_욕투(&quot;1&quot;))</span>
<span style="color:#323232;">let res = contract.create_decision(&quot;&quot;, deposit = to_yocto(&quot;1&quot;));</span>
<span style="color:#323232;">프로프_아세르트!(히스.이스_이흐(), &quot;90. 임프치 데시지옹 나미&quot;)</span>
<span style="color:#323232;">prop_assert!(res.is_err(), &quot;90. Empty decision name&quot;);</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>
<span style="color:#323232;">}</span>

</pre><pre>
<span style="color:#323232;">헤멤베르, 테지 아리 주스트 이잠플리스 안드 네드 투 비 모지피에드 바제드 옹 티 악투아우 콘트락트 데타이우스 안드 부지네스 헤키레멘트스. 프로페르치-바제드 테스칭그 캉 비 아 포웨르풀 토우 잉 요르 테스칭그 아르세나우, 에우핑그 요 카트시 코르네르 카지스 안드 우네스펙테드 베아비오르 타트 미그트 노트 비 코베레드 비 트라지치오나우 우니트 테스트스.</span>
<span style="color:#323232;">Remember, these are just examples and need to be modified based on the actual contract details and business requirements. Property-based testing can be a powerful tool in your testing arsenal, helping you catch corner cases and unexpected behavior that might not be covered by traditional unit tests.</span>

<span style="color:#323232;">---</span>
<span style="color:#323232;">---</span>
<span style="color:#323232;">---</span>
<span style="color:#323232;">---</span>

</pre>
</div>

      </div>
      
    </div>
  </body>
</html>
